module egret3d {/*** @private*/export class ShaderLib {static lib: { [key:string]: string } = {
AOMap_fs: "uniform sampler2D aoTexture ;\nuniform float aoPower ;\nvoid main(void){\n    float ao = texture2D( aoTexture , varying_uv1 ).x ;\n\tdiffuseColor.xyz *= (ao * aoPower) ; \n}\n",
AmbientOcclusion: "varying vec2 varying_uv0;\nuniform sampler2D positionPass;\nuniform sampler2D normalPass;\nvoid main(){\n    gl_FragColor = texture2D(positionPass,varying_uv0) + texture2D(normalPass,varying_uv0) ;\n}\n",
FakePBR_fs: "#extension GL_OES_standard_derivatives:enable\n#define max_directLight 1 \nstruct DirectLight{\n   vec3 direction;\n\t vec3 diffuse;\n\t vec3 ambient;\n};\nuniform float uniform_directLightSource[9*max_directLight] ;\nvarying vec4 varying_mvPose; \nvarying vec3 varying_eyeNormal; \nvarying vec2 varying_uv0; \nuniform sampler2D albedoTex; \nuniform sampler2D normalTex; \nuniform sampler2D glossTex; \nuniform sampler2D specularTex; \nuniform sampler2D opacityTex; \nuniform samplerCube reflectionMap;\nuniform mat4 uniform_ViewMatrix; \nmat3 TBN; \nmat4 normalMatrix ;\nvec3 normalDirection;\nvec3 light;\nvec3 normalTexColor ;\nvec4 opacityTexColor ;\nvec4 glossTexColor ;\nvec4 specularTexColor ;\nvec4 albedoTexColor ;\nvec2 uv_0;\nmat4 transpose(mat4 inMatrix) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n    mat4 outMatrix = mat4(\n                 vec4(i0.x, i1.x, i2.x, i3.x),\n                 vec4(i0.y, i1.y, i2.y, i3.y),\n                 vec4(i0.z, i1.z, i2.z, i3.z),\n                 vec4(i0.w, i1.w, i2.w, i3.w)\n                 );\n    return outMatrix;\n}\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\nvec3 unpackNormal(vec4 packednormal)\n{\n\treturn packednormal.xyz * 2.0 - 1.0;\n}\nmat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) { \nvec3 dp1 = dFdx(p); \nvec3 dp2 = dFdy(p); \nvec2 duv1 = dFdx(uv); \nvec2 duv2 = dFdy(uv);  \nvec3 dp2perp = cross(dp2, N); \nvec3 dp1perp = cross(N, dp1); \nvec3 T = dp2perp * duv1.x + dp1perp * duv2.x; \nvec3 B = dp2perp * duv1.y + dp1perp * duv2.y; \nfloat invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B))); \nreturn mat3(T * invmax, B * invmax, N); \n}\nvec3 fakePBRLight( vec3 lightDir , vec3 viewDir , vec3 lightColor , vec3 ambient ){\n    vec3 lightDirection = mat3(uniform_ViewMatrix) * normalize(lightDir);\n    vec3 halfDirection = normalize( lightDirection + viewDir) ;\n    float attenuation = 1.0 ;    vec3 attenColor = attenuation * lightColor;\n    float Pi = 3.141592654;\n    float InvPi = 0.31830988618;\n    float gloss = glossTexColor.r;\n    float specPow = exp2( gloss * 10.0 + 1.0 );\n    float NdotL = max(0.0, dot( normalDirection, lightDirection ));\n    float specularMonochrome = max( max(specularTexColor.r, specularTexColor.g), specularTexColor.b);\n    float normTerm = (specPow + 8.0 ) / (8.0 * Pi);\n    vec3 directSpecular =  (floor(attenuation) * lightColor ) * pow(max(0.0,dot(halfDirection,normalDirection)),normTerm) * specularTexColor.xyz * normTerm ;\n    vec3 specular = directSpecular;\n    NdotL = max(0.0,dot( normalDirection , normalize(lightDirection) ));\n    vec3 directDiffuse = max( 0.0, NdotL) * attenColor;\n    vec3 indirectDiffuse = vec3(0.0,0.0,0.0);\n\t\t indirectDiffuse +=  ambient ;    vec3 diffuseColor = albedoTexColor.rgb;\n    diffuseColor *= 1.0-specularMonochrome;\n    vec3 diffuse = (directDiffuse + indirectDiffuse) * diffuseColor;\n    vec3 finalColor = diffuse + specular ;\n    return finalColor ;\n}\nvoid calculateDirectLight(  ){\n    float lambertTerm , specular ; \n    vec3 dir ,viewDir = normalize(varying_mvPose.xyz/varying_mvPose.w); \n    for(int i = 0 ; i < max_directLight ; i++){ \n         DirectLight directLight ; \n         directLight.direction = vec3(uniform_directLightSource[i*10],uniform_directLightSource[i*10+1],uniform_directLightSource[i*10+2]); \n         directLight.diffuse = vec3(uniform_directLightSource[i*10+3],uniform_directLightSource[i*10+4],uniform_directLightSource[i*10+5]); \n         directLight.ambient = vec3(uniform_directLightSource[i*10+6],uniform_directLightSource[i*10+7],uniform_directLightSource[i*10+8]); \n         dir = normalize(directLight.direction) ; \n         light.xyz += fakePBRLight( dir , viewDir , directLight.diffuse , directLight.ambient); \n    }\n}\nvoid main(void){ \n     TBN = cotangentFrame(normalize(varying_eyeNormal), normalize(-varying_mvPose.xyz) , uv_0); \n  \n     albedoTexColor = texture2D(albedoTex, varying_uv0 );\n      normalTexColor = unpackNormal(texture2D(normalTex, uv_0 )) ; \n     opacityTexColor = texture2D(opacityTex, uv_0 ) ; \n     glossTexColor = texture2D(glossTex, uv_0 );\n     specularTexColor = texture2D(specularTex, uv_0 );\n     normalDirection = TBN * normalTexColor.xyz ;\n     if( (step(materialSource.cutAlpha,opacityTexColor.g) - 0.5) < 0.0 ){\n        discard;\n     }\n     calculateDirectLight();\n     vec4 finalRGBA = vec4(light,1.0) ;     gl_FragColor = finalRGBA;   \n}",
FakePBR_vs: "attribute vec3 attribute_position;\nattribute vec3 attribute_normal;\nattribute vec2 attribute_uv0;\nuniform mat4 uniform_ModelMatrix ;\nuniform mat4 uniform_ViewMatrix ;\nuniform mat4 uniform_ProjectionMatrix ;\nvarying vec4 varying_mvPose;\nvarying vec3 varying_eyeNormal;\nvarying vec2 varying_uv0;\nvec4 outPosition; \nmat4 transpose(mat4 inMatrix) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n    mat4 outMatrix = mat4(\n                 vec4(i0.x, i1.x, i2.x, i3.x),\n                 vec4(i0.y, i1.y, i2.y, i3.y),\n                 vec4(i0.z, i1.z, i2.z, i3.z),\n                 vec4(i0.w, i1.w, i2.w, i3.w)\n                 );\n    return outMatrix;\n}\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\nvoid main(void){ \n    mat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n    varying_mvPose = mvMatrix * vec4( attribute_position , 1.0 )  ; \n    \n    mat4 normalMatrix = inverse(mvMatrix) ;\n    normalMatrix = transpose(normalMatrix); \n    \n    varying_eyeNormal = mat3(normalMatrix) * -attribute_normal ; \n    varying_uv0 = attribute_uv0 ;\n    \n    outPosition = uniform_ProjectionMatrix * varying_mvPose ; \n    gl_Position = outPosition; \n}",
MultiUVSprite_fs: "uniform vec4 multiUV ; \nuniform sampler2D diffuseTexture;\nvec4 diffuseColor ;\nvoid main() {\n    vec2 scale = vec2(1.0/multiUV.xy) ; \n    float a = mod(multiUV.w , multiUV.x) ;\n    float b = (multiUV.w / multiUV.x) - fract(multiUV.w / multiUV.x) ; \n    vec2 rec = scale * vec2(a,b) + uv_0 * scale;\n\tdiffuseColor = texture2D(diffuseTexture , rec ); \n    if( diffuseColor.w < materialSource.cutAlpha ){\n\t\tdiscard;\n\t}\n}\n",
SSAO: "#define DL 2.399963229728653\n#define EULER 2.718281828459045\nvarying vec2 varying_uv0; \nfloat aoClamp =  0.5 ; \nfloat lumInfluence =  0.5 ; \nconst vec2 size =  vec2(512.0,512.0); \nconst int samples =  64; \nconst float radius =  2.0; \nconst bool useNoise =  false; \nconst float noiseAmount =  0.00000003; \nconst float diffArea =  0.4; \nconst float gDisplace =  0.4; \nuniform sampler2D positionPass; \nuniform sampler2D normalPass; \nuniform sampler2D colorPass; \nvec2 rand( vec2 coord ) { \nvec2 noise; \nif ( useNoise ) { \nfloat nx = dot ( coord, vec2( 12.9898, 78.233 ) ); \nfloat ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 ); \nnoise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 ); \n} else { \nfloat ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) ); \nfloat gg = fract( coord.t * ( size.y / 2.0 ) ); \nnoise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg; \n} \nreturn ( noise * 2.0  - 1.0 ) * noiseAmount; \n}\nfloat readDepth(vec2 coord){ \nfloat cameraNear = 1.0 ; \nfloat cameraFar = 10000.0; \nfloat cameraFarPlusNear = cameraFar + cameraNear; \nfloat cameraFarMinusNear = cameraFar - cameraNear; \nfloat cameraCoef = 2.0 * cameraNear; \nreturn texture2D(positionPass,coord).z / (cameraFar-cameraNear); \n}\nfloat compareDepths( const in float depth1, const in float depth2, inout int far ) { \nfloat garea = 2.0; \nfloat diff = ( depth1 - depth2 ) * 100.0; \nif ( diff < gDisplace ) { \ngarea = diffArea; \n} else { \nfar = 1; \n} \nfloat dd = diff - gDisplace; \nfloat gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) ); \nreturn gauss; \n}\nfloat calcAO( float depth, float dw, float dh ) { \nfloat dd = radius - depth * radius; \nvec2 vv = vec2( dw, dh ); \nvec2 vUv = varying_uv0 ; \nvec2 coord1 = vUv + dd * vv; \nvec2 coord2 = vUv - dd * vv; \nfloat temp1 = 0.0; \nfloat temp2 = 0.0; \nint far = 0; \ntemp1 = compareDepths( depth, readDepth( coord1 ), far ); \nif ( far > 0 ) { \ntemp2 = compareDepths( readDepth( coord2 ), depth, far ); \ntemp1 += ( 1.0 - temp1 ) * temp2; \n} \nreturn temp1; \n}\nvoid main(){ \nvec2 noise = rand( varying_uv0 ); \nfloat depth = readDepth( varying_uv0 ); \nfloat tt = clamp( depth, aoClamp, 1.0 ); \nfloat w = ( 1.0 / size.x )  / tt + ( noise.x * ( 1.0 - noise.x ) ); \nfloat h = ( 1.0 / size.y ) / tt + ( noise.y * ( 1.0 - noise.y ) ); \nfloat ao = 0.0; \nfloat dz = 1.0 / float( samples ); \nfloat z = 1.0 - dz / 2.0; \nfloat l = 0.0; \nfor ( int i = 0; i <= samples; i ++ ) { \nfloat r = sqrt( 1.0 - z ); \nfloat pw = cos( l ) * r; \nfloat ph = sin( l ) * r; \nao += calcAO( depth, pw * w, ph * h ); \nz = z - dz; \nl = l + DL; \n} \nao /= float( samples ); \nao = 1.0 - ao; \nvec3 color = texture2D(colorPass,varying_uv0).xyz ; \nvec3 lumcoeff = vec3( 0.299, 0.587, 0.114 ); \nfloat lum = dot( color.rgb, lumcoeff ); \nvec3 luminance = vec3( lum ); \nvec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) ); \ngl_FragColor = vec4( final, 1.0 ); \n}",
alphaMask_fs: "uniform sampler2D maskTexture ;\nvoid main(void){\n\tfloat maskAlpha = texture2D( maskTexture , uv_0 ).x;\n\tif(maskAlpha * diffuseColor.w < 0.001){\n\t\tdiscard;\n\t}\n    materialSource.alpha *= maskAlpha;\n}\n",
baseShadowPass_fs: "varying vec2 varying_uv0;\nvarying vec4 varying_color;\nvec4 outColor ; \nvec2 uv_0;\nvoid main() {\n\tuv_0 = varying_uv0;\n}",
baseShadowPass_vs: "attribute vec3 attribute_position;\nattribute vec2 attribute_uv0;\nattribute vec4 attribute_color;\nuniform mat4 uniform_ProjectionMatrix ;\nvarying vec2 varying_uv0;\nvarying vec4 varying_color;\nvec3 e_position = vec3(0.0, 0.0, 0.0);\nvec4 outPosition ;\nvoid main(void){\n    e_position = attribute_position;\n    varying_color = attribute_color;\n    varying_uv0 = attribute_uv0;\n}",
base_fs: "#extension GL_OES_standard_derivatives : enable\nvarying vec3 varying_eyeNormal  ;\nvarying vec2 varying_uv0;\nvarying vec4 varying_color;\nuniform mat4 uniform_ViewMatrix ;\nstruct SurfaceOutput{\n  vec3 Albedo;\n  vec3 Normal;\n  vec4 Specular;\n  float Alpha ;\n};\nSurfaceOutput s ;\nvec4 outColor ;\nvec4 diffuseColor ;\nvec4 light ;\nvec3 normal;\nvec2 uv_0;\nvec3 flatNormals(vec3 pos) {\n  vec3 fdx = dFdx(pos);\n  vec3 fdy = dFdy(pos);\n  return normalize(cross(fdx, fdy));\n}\nvec3 Fresnel_Schlick(float cosT, vec3 F0)\n{\n  return F0 + (1.0-F0) * pow( 1.0 - cosT, 5.0);\n}\nvoid main() {\n\tdiffuseColor  = vec4(1.0);\n\tlight         = vec4(0.0,0.0,0.0,-1.0); \n     \n    normal = normalize(varying_eyeNormal) ;\n\tuv_0 = varying_uv0;\n}",
base_vs: "attribute vec3 attribute_position;\nattribute vec3 attribute_normal;\nattribute vec4 attribute_color;\nattribute vec2 attribute_uv0;\nvec3 e_position = vec3(0.0, 0.0, 0.0);\nvec3 e_normal = vec3(0.0, 0.0, 0.0);\nuniform mat4 uniform_ModelMatrix ;\nuniform mat4 uniform_ViewMatrix ;\nuniform mat4 uniform_ProjectionMatrix ;\nvarying vec3 varying_eyeNormal  ;\nvarying vec2 varying_uv0;\nvarying vec4 varying_color;\nvec4 outPosition ;\nmat4 rotVertexMatrix;\nmat4 transpose(mat4 inMatrix) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n    mat4 outMatrix = mat4(\n                 vec4(i0.x, i1.x, i2.x, i3.x),\n                 vec4(i0.y, i1.y, i2.y, i3.y),\n                 vec4(i0.z, i1.z, i2.z, i3.z),\n                 vec4(i0.w, i1.w, i2.w, i3.w)\n                 );\n    return outMatrix;\n}\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\nvoid main(void){\n\te_position = attribute_position;\n\te_normal = attribute_normal;\n\tvarying_color = attribute_color;\n\tvarying_uv0 = attribute_uv0;\n}",
bezier: "vec2 quadratic_bezier(vec2 A, vec2 B, vec2 C, float t)\n{\n    vec2 D = mix(A, B, t);\n    vec2 E = mix(B, C, t); \n    return mix(D, E, t);\n}\nvec2 cubic_bezier(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    vec2 E = mix(A, B, t);\n    vec2 F = mix(B, C, t);\n    vec2 G = mix(C, D, t);\n    return quadratic_bezier(E, F, G, t);\n}",
bloom_fs: "varying vec2 varying_uv0; \nuniform sampler2D diffuseTexture; \nuniform float bloom_amount = 0.15;\nvoid main(void) { \n\tvec2 uv = vec2( varying_uv0.x , 1.0-varying_uv0.y );\n\tvec4 color = texture2D(diffuseTexture, uv); \n  \tvec4 sum = vec4(0), add = vec4(0), val = texture2D(diffuseTexture, uv);\n  \n        for( int i = -4 ; i < 4; i++) {\n             for ( int j = -4; j < 4; j++) {\n                 add += texture2D(diffuseTexture, uv + vec2(j, i)*0.002) * bloom_amount;\n             }\n        }\n\tif (val.r < 0.2) { sum = add*add*0.012 + val; } else \n\tif (val.r < 0.5) { sum = add*add*0.009 + val; } else {\n      sum = add*add*0.0075 + val;\n  }\n\tgl_FragColor = vec4(sum.rgb, 1.0);\n}",
colorCorrectionRamp_fs: "precision highp float;            \t\nvarying vec2 varying_uv0; \nuniform float saturation; \nuniform sampler2D diffuseTexture; \nuniform sampler2D lutTexture; \nfloat Luminance( vec3 c ){ \nreturn dot( c , vec3(0.22,0.707,0.071) ); \n}\nvoid main() \n{ \nvec2 uv = varying_uv0 ; \nvec4 color = texture2D(diffuseTexture, uv); \nfloat red = texture2D(lutTexture, color.rr).r ;\nfloat green = texture2D(lutTexture,color.gg ).g ;\nfloat blue = texture2D(lutTexture, color.bb ).b ;\ncolor = vec4(red,green,blue, color.a); \ngl_FragColor = color ; \n}",
colorCorrection_fs: "varying vec2 varying_uv0;\nuniform sampler2D diffuseTexture;\nuniform sampler2D lutTexture;\nuniform float saturation ;\nfloat Luminance( vec3 c ){\n    return dot( c , vec3(0.22,0.707,0.071) );\n}\nvoid main()\n{\n     vec2 uv = varying_uv0 ; \n\t vec4 color = texture2D(diffuseTexture, uv); \n\t\t\n\t vec3 red = texture2D(lutTexture, vec2(color.r, 0.5/4.0)).rgb * vec3(1.0,0.0,0.0);\n\t vec3 green = texture2D(lutTexture, vec2(color.g, 1.5/4.0)).rgb * vec3(0.0,1.0,0.0);\n\t vec3 blue = texture2D(lutTexture, vec2(color.b, 2.5/4.0)).rgb * vec3(0.0,0.0,1.0);\n\t \n\t color = vec4(red+green+blue, color.a);\n\t float lum = Luminance(color.rgb);\n     gl_FragColor = color ;\n}",
colorGradients_fs: "varying vec4 varying_mvPose;\nuniform float uniform_colorGradientsSource[6] ;\nvoid main(void){\n\tfloat posStartY = uniform_colorGradientsSource[0]; \n\tfloat posEndY = uniform_colorGradientsSource[1]; \n\tvec4 color = vec4(uniform_colorGradientsSource[2], uniform_colorGradientsSource[3], uniform_colorGradientsSource[4], uniform_colorGradientsSource[5]); \n\tcolor.w *= clamp((varying_mvPose.y - posStartY) / (posEndY - posStartY), 0.0, 1.0); \n\tcolor.xyz *= color.w;\n\toutColor.xyz = outColor.xyz * (1.0 - color.w) + color.xyz * color.w; \n\t\n}\n ",
colorPassEnd_fs: "void main() {\n\t gl_FragColor = vec4(diffuseColor.xyz,1.0);\n}",
colorTransform_fs: "uniform float uniform_colorTransformAlpha ;\nuniform mat4 uniform_colorTransformM44 ;\nvoid main(){\n\tdiffuseColor.xyz = (uniform_colorTransformM44 * vec4(diffuseColor.xyz, 1.0)).xyz;\n\tdiffuseColor.w *= diffuseColor.w * uniform_colorTransformAlpha;\n}\n",
color_fragment: "void main() \r\n{\r\n\t//s.Albedo.xyz = vec3(1.0, 1.0, 1.0);\r\n\t//s.Alpha = 1.0 ; \r\n  \r\n\ts.Albedo.xyz = materialSource.diffuse;\r\n\ts.Alpha = materialSource.alpha;\r\n\t\r\n\tif( varying_color.w < materialSource.cutAlpha ){ \r\n\t\tdiscard; \r\n\t}\r\n}",
combin_fs: "uniform sampler2D colorTexture;\nvoid main(void){\n}",
cube_fragment: "uniform samplerCube diffuseTexture3D ;\nvarying vec3 varying_pos;\nvec4 diffuseColor ;\nvoid main() {\n    if( diffuseColor.w == 0.0 ){\n\t\tdiscard;\n\t}\n\tvec3 uvw = normalize(varying_pos.xyz);\n\tdiffuseColor = vec4(textureCube(diffuseTexture3D, uvw.xyz));\n    \n    if( diffuseColor.w < materialSource.cutAlpha ){\n\t\tdiscard;\n\t}else\n\t\tdiffuseColor.xyz *= diffuseColor.w ;\n}",
cube_vertex: "varying vec3 varying_pos;\nvoid main(void){\n   varying_pos =  e_position;\n} ",
detail_Bending_vs: "uniform float uniformTime[4] ;\nvoid main(void){\n\te_position = attribute_position; \nvarying_uv0 = attribute_uv0; \n  \n  varying_color = attribute_color; \nvec4 curve = SmoothTriangleWave(vec4(sin(uniformTime[0]*0.001),1.0,1.0,1.0));\n e_position.xyz += curve.x * vec3(1.0,0.5,0.0) * ( attribute_color.xyz) ;\n}",
diffuse_fragment: "uniform sampler2D diffuseTexture;\nvarying vec4 varying_mvPose;\nvoid main() {\n  \tvec3 fc = vec3(0.0, 0.0, 0.0);\n\tvec4 c = texture2D( diffuseTexture , uv_0 );\n\tc.a = materialSource.alpha * c.a;\n    c.xyz = c.xyz * materialSource.diffuse * c.a; \n\tif (c.a < materialSource.cutAlpha)\n\t\tdiscard;\n\tif(materialSource.refraction<2.41){ \n       float vl = dot(normal,-normalize(varying_mvPose.xyz)); \n       fc = Fresnel_Schlick(vl,vec3(materialSource.refraction)) * materialSource.refractionintensity ; \n       fc.xyz = max(fc,vec3(0.0)) ; \n    } \n\ts.Normal = normal;\n\ts.Specular = vec4(1.0) ;\n\ts.Albedo = c.rgb + fc.xyz * c.rgb + materialSource.ambient * c.rgb;\n    s.Albedo.x = pow(s.Albedo.x, materialSource.gamma);\n    s.Albedo.y = pow(s.Albedo.y, materialSource.gamma);\n    s.Albedo.z = pow(s.Albedo.z, materialSource.gamma);\n\ts.Alpha = c.a;\n\toutColor.xyz = s.Albedo * 0.5 ;\n\toutColor.w = s.Alpha;\n}\n",
diffuse_vertex: "attribute vec3 attribute_normal;\nattribute vec4 attribute_color;\nvarying vec4 varying_mvPose; \nvoid main(void){\n    \n    mat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n    \n    varying_mvPose = mvMatrix * vec4( e_position , 1.0 )  ; \n    \n    mat4 normalMatrix = inverse(mvMatrix) ;\n    normalMatrix = transpose(normalMatrix); \n    \n    varying_eyeNormal = mat3(normalMatrix) * -attribute_normal ; \n    \n    outPosition = varying_mvPose ; \n    varying_color = attribute_color; \n    \n}\n",
directLight_fragment: "const int max_directLight = 0 ;\nuniform float uniform_directLightSource[10*max_directLight] ;\nvarying vec4 varying_mvPose; \nuniform mat4 uniform_ViewMatrix;\nmat4 normalMatrix ;\nstruct DirectLight{\n    vec3 direction;\n\tvec3 diffuse;\n\tvec3 ambient;\n    float intensity;\n};\nmat4 transpose(mat4 inMatrix) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n    mat4 outMatrix = mat4(\n                 vec4(i0.x, i1.x, i2.x, i3.x),\n                 vec4(i0.y, i1.y, i2.y, i3.y),\n                 vec4(i0.z, i1.z, i2.z, i3.z),\n                 vec4(i0.w, i1.w, i2.w, i3.w)\n                 );\n    return outMatrix;\n}\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\nvec4 calculateDirectLight( MaterialSource materialSource ){ \n    float lambertTerm , specular ; \n    vec3 dir ,viewDir = normalize(varying_mvPose.xyz/varying_mvPose.w); \n    diffuseColor = vec4(0.0,0.0,0.0,1.0);\n    for(int i = 0 ; i < max_directLight ; i++){ \n        DirectLight directLight ; \n        directLight.direction = (normalMatrix * vec4(uniform_directLightSource[i*10],uniform_directLightSource[i*10+1],uniform_directLightSource[i*10+2],0.0)).xyz; \n\t\tdirectLight.diffuse = vec3(uniform_directLightSource[i*10+3],uniform_directLightSource[i*10+4],uniform_directLightSource[i*10+5]); \n\t\tdirectLight.ambient = vec3(uniform_directLightSource[i*10+6],uniform_directLightSource[i*10+7],uniform_directLightSource[i*10+8]); \n\t\tdirectLight.intensity = uniform_directLightSource[i*10+9] ; \n\t\tdir = normalize(directLight.direction) ; \n\t\tdiffuseColor += LightingBlinnPhong(dir,directLight.diffuse,directLight.ambient,s.Normal,viewDir,directLight.intensity); \n    } \n    return diffuseColor ;\n}\nvoid main() {\n\tnormalMatrix = inverse(uniform_ViewMatrix);\n\tnormalMatrix = transpose(normalMatrix);\n\tlight += calculateDirectLight( materialSource ).xyzw ; \n}\n",
endShadowPass_fs: "void main() {\n    if(varying_color.w<=0.0){\n       discard;\n    }\n    outColor.x =  outColor.y = outColor.z = varying_ViewPose.z/varying_ViewPose.w  ;\n    outColor.w = 1.0 ;\n    gl_FragColor = outColor ;\n}\n",
endShadowPass_vs: "void main() {\n\t outPosition = uniform_ProjectionMatrix * outPosition ;\n     gl_Position = outPosition ;\n}\n                      ",
end_fs: "varying vec4 varying_mvPose; \nvec4 diffuseColor ;\nvec4 specularColor ;\nvec4 ambientColor;\nvec4 light ;\nvoid main() {\n\tif(light.w < 0.0 ){\n\t   outColor.xyz = s.Albedo.xyz ; \n\t}else{\n\t   outColor.xyzw = light ; \n\t}\n    outColor.xyzw *= varying_color.xyzw;\n}\n",
end_vs: "vec4 endPosition ;\nuniform float uniform_materialSource[20];\nvoid main() {\n\t gl_PointSize = uniform_materialSource[17];\n     outPosition = uniform_ProjectionMatrix * outPosition ;\n}\n                      ",
environmentDiffuse_vertex: "\nvoid main(){\n}\n",
environmentMapping_fragment: "uniform samplerCube environmentMapTex ;\nuniform float reflectValue;\nvarying vec3 varying_ViewDir ;\nvoid main(){\n\t vec3 N = normalize(normal);\n\tvec3 V = normalize(varying_mvPose.xyz/varying_mvPose.w);\n\tfloat dotNV = clamp(dot(N,V), 0.0, 1.0);\tfloat FV = pow((1.0 - dotNV), 2.0);\n\t\n\tmat4 invViewMatrix = inverse(uniform_ViewMatrix);\n\tvec3 ecReflected = reflect(normalize(varying_ViewDir.xyz), normalize(mat3(invViewMatrix)*normal));\tvec4 reflectiveColor = textureCube(environmentMapTex,-normalize(ecReflected.xyz)); \n\tdiffuseColor.xyz = mix( diffuseColor.xyz,reflectiveColor.xyz, reflectValue + FV );  \n\t\n}\n         ",
expFog_fs: "struct Fog{\n   vec3 fogColor  ;\n   float globalDensity ;\n   vec3 distance ;\n};\nvarying vec4 varying_pos;\nuniform float uniform_globalFog[7];\nvoid main(void){\n    Fog fog; \n    fog.fogColor = vec3(uniform_globalFog[0],uniform_globalFog[1],uniform_globalFog[2]); \n    fog.globalDensity = uniform_globalFog[3]; \n    fog.distance = vec2(uniform_globalFog[4], uniform_globalFog[5]); \n    float d = distance(uniform_eyepos,varying_pos.xyz); \n    float distFog = max( 0.0 , d - fog.distance.x )* fog.distance.y; \n    float fogFactor = (1.0-exp( -distFog * 0.000001 * fog.globalDensity )) ; \n    diffuseColor.xyz = mix( diffuseColor.xyz  , fog.fogColor , min(fogFactor,1.0) ); \n}\n ",
expHeightFog_fs: "struct Fog{\n   vec3 fogColor  ;\n   float globalDensity ;\n   float fogStartDistance ;\n   float fogHeightStart ;\n   float fogAlpha ;\n};\nvarying vec4 varying_pos;\nuniform float uniform_globalFog[7];\nvec3 applyFog( float yDistance, vec3  vpos , Fog fog ) \n{\n    float d = distance(uniform_eyepos,varying_pos.xyz); \n    float distFog = max( 0.0 , d - fog.fogStartDistance ) ; \n    float yFog = max(0.0, (vpos.y - fog.fogHeightStart - yDistance) )  ; \n    float fogAmount =  1.0-(exp(-distFog * fog.globalDensity )) + (exp(-yFog * fog.globalDensity )); \n    return mix( diffuseColor.xyz,fog.fogColor, clamp(fogAmount,0.0,fog.fogAlpha) );\n}\n \nvoid main(void){\n    Fog fog; \n    fog.fogColor = vec3(uniform_globalFog[0],uniform_globalFog[1],uniform_globalFog[2]); \n    fog.globalDensity = uniform_globalFog[3]; \n    fog.fogStartDistance = uniform_globalFog[4] ; \n    fog.fogHeightStart = uniform_globalFog[5] ;\n    fog.fogAlpha = uniform_globalFog[6] ; \n    fog.fogColor *= diffuseColor.w;\n    float yd = uniform_eyepos.y - varying_pos.y ;\n    diffuseColor.xyz = applyFog( yd , varying_pos.xyz , fog );\n}\n ",
flatNormal_fs: "#extension GL_OES_standard_derivatives : enable\nvec3 flatNormal(vec3 pos){\n    vec3 fdx = dFdx(pos);\n    vec3 fdy = dFdy(pos);\n    return normalize(cross(fdx, fdy));\n}",
gamma_fs: "\nconst float gamma = 2.2;\nfloat toLinear_float_v1(float v) {\n  return pow(v, gamma);\n}\nvec2 toLinear_vec2_v1(vec2 v) {\n  return pow(v, vec2(gamma));\n}\nvec3 toLinear_vec3_v1(vec3 v) {\n  return pow(v, vec3(gamma));\n}\nvec4 toLinear_vec4_v1(vec4 v) {\n  return vec4(toLinear_vec3_v1(v.rgb), v.a);\n}\nfloat toGamma_float_v2(float v) {\n  return pow(v, 1.0 / gamma);\n}\nvec2 toGamma_vec2_v2(vec2 v) {\n  return pow(v, vec2(1.0 / gamma));\n}\nvec3 toGamma_vec3_v2(vec3 v) {\n  return pow(v, vec3(1.0 / gamma));\n}\nvec4 toGamma_vec4_v2(vec4 v) {\n  return vec4(toGamma_vec3_v2(v.rgb), v.a);\n}\nvec4 textureLinear(sampler2D uTex, vec2 uv) {\n  return toLinear_vec4_v1(texture2D(uTex, uv));\n}",
gaussian_H_fs: "varying vec2 varying_uv0;\nuniform sampler2D diffuseTexture;\nvec4 blur9_1_0(sampler2D image, vec2 uv, float radius , float resolution, vec2 dir) {\n    vec4 color = vec4(0.0);\n    vec2 tc = uv;\n    float blur = radius/resolution ; \n    float hstep = dir.x;\n    float vstep = dir.y;\n    color += texture2D(image, vec2(tc.x - 4.0*blur*hstep, tc.y - 4.0*blur*vstep)) * 0.0162162162;\n    color += texture2D(image, vec2(tc.x - 3.0*blur*hstep, tc.y - 3.0*blur*vstep)) * 0.0540540541;\n    color += texture2D(image, vec2(tc.x - 2.0*blur*hstep, tc.y - 2.0*blur*vstep)) * 0.1216216216;\n    color += texture2D(image, vec2(tc.x - 1.0*blur*hstep, tc.y - 1.0*blur*vstep)) * 0.1945945946;\n    color += texture2D(image, vec2(tc.x, tc.y)) * 0.2270270270;\n    color += texture2D(image, vec2(tc.x + 1.0*blur*hstep, tc.y + 1.0*blur*vstep)) * 0.1945945946;\n    color += texture2D(image, vec2(tc.x + 2.0*blur*hstep, tc.y + 2.0*blur*vstep)) * 0.1216216216;\n    color += texture2D(image, vec2(tc.x + 3.0*blur*hstep, tc.y + 3.0*blur*vstep)) * 0.0540540541;\n    color += texture2D(image, vec2(tc.x + 4.0*blur*hstep, tc.y + 4.0*blur*vstep)) * 0.0162162162;\n  return color;\n}\nvoid main(void) { \n\tvec4 color = vec4(0.0,0.0,0.0,0.0); \n\tcolor =blur9_1_0(diffuseTexture,varying_uv0,3.0,2048.0,vec2(0.0,1.0));\n\tgl_FragColor  = color; \n}",
gaussian_V_fs: "varying vec2 varying_uv0;\nuniform sampler2D diffuseTexture;\nuniform sampler2D colorTexture;\nvec4 blur9_1_0(sampler2D image, vec2 uv, float radius , float resolution, vec2 dir) {\n    vec4 color = vec4(0.0);\n    vec2 tc = uv;\n    float blur = radius/resolution ; \n    float hstep = dir.x;\n    float vstep = dir.y;\n    color += texture2D(image, vec2(tc.x - 4.0*blur*hstep, tc.y - 4.0*blur*vstep)) * 0.0162162162;\n    color += texture2D(image, vec2(tc.x - 3.0*blur*hstep, tc.y - 3.0*blur*vstep)) * 0.0540540541;\n    color += texture2D(image, vec2(tc.x - 2.0*blur*hstep, tc.y - 2.0*blur*vstep)) * 0.1216216216;\n    color += texture2D(image, vec2(tc.x - 1.0*blur*hstep, tc.y - 1.0*blur*vstep)) * 0.1945945946;\n    color += texture2D(image, vec2(tc.x, tc.y)) * 0.2270270270;\n    color += texture2D(image, vec2(tc.x + 1.0*blur*hstep, tc.y + 1.0*blur*vstep)) * 0.1945945946;\n    color += texture2D(image, vec2(tc.x + 2.0*blur*hstep, tc.y + 2.0*blur*vstep)) * 0.1216216216;\n    color += texture2D(image, vec2(tc.x + 3.0*blur*hstep, tc.y + 3.0*blur*vstep)) * 0.0540540541;\n    color += texture2D(image, vec2(tc.x + 4.0*blur*hstep, tc.y + 4.0*blur*vstep)) * 0.0162162162;\n  return color;\n}\nvoid main(void) { \n\tvec4 color = vec4(0.0,0.0,0.0,0.0); \n\tvec2 uv = vec2(varying_uv0.x,1.0-varying_uv0.y);\n\tcolor = blur9_1_0(diffuseTexture,varying_uv0,3.0,2048.0,vec2(1.0,0.0));\n\tcolor += texture2D(colorTexture,uv);\n\tgl_FragColor  = color; \n}",
grass_fs: "uniform float uniform_lightMap_data[5];\nuniform sampler2D diffuseTexture;\nuniform sampler2D lightMapTexture;\nvarying vec4 varying_scenePose;\nvec4 diffuseColor;\nvoid main() {\n\tvec2 lightUV;\n\tdiffuseColor = texture2D(diffuseTexture, varying_uv0);\n\tif( diffuseColor.w < materialSource.cutAlpha ){\n\t\tdiscard;\n\t}\n\tif(uniform_lightMap_data[0] > 0.5){\n\t\tlightUV.x = (varying_scenePose.x + uniform_lightMap_data[1]) / uniform_lightMap_data[3]; \n\t\tlightUV.y = (varying_scenePose.z + uniform_lightMap_data[2]) / uniform_lightMap_data[4]; \n\t\tdiffuseColor *= texture2D(lightMapTexture, lightUV); \n\t}\n\toutColor = diffuseColor;\n}",
grass_vs: "attribute vec3 attribute_grassOffset;\nattribute float attribute_grassAngleY;\nuniform float uniform_grass_data[9];\nuniform float uniform_squeeze_data[6];\nuniform float uniform_lightMap_data[5];\nuniform mat4 uniform_cameraMatrix;\nuniform mat4 uniform_billboardMatrix;\nvarying vec4 varying_mvPose; \nvarying vec4 varying_scenePose;\nconst float TrueOrFalse = 0.5;\nconst float PI_2 = 6.283;\nstruct SqueezeData{\n\tfloat enable;\n\tvec3 position;\n\tfloat strength;\n\tfloat radius;\n};\nSqueezeData squeezeData;\nmat4 buildRotMat4(vec3 rot)\n{\n\tfloat s;\n\tfloat c;\n\ts = sin(rot.x);\n\tc = cos(rot.x);\n\t\n\tmat4 ret = mat4(\n\tvec4(1.0, 0.0, 0.0, 0.0),\n\tvec4(0.0, c, s, 0.0),\n\tvec4(0.0, -s, c, 0.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n\t);\n\t\n\ts = sin(rot.y);\n\tc = cos(rot.y);\n\t\n\tret = mat4(\n\tvec4(c, 0.0, -s, 0.0),\n\tvec4(0.0, 1.0, 0.0, 0.0),\n\tvec4(s, 0.0, c, 0.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n\t) * ret;\n\ts = sin(rot.z);\n\tc = cos(rot.z);\n\tret = mat4(\n\tvec4(c, s, 0.0, 0.0),\n\tvec4(-s, c, 0.0, 0.0),\n\tvec4(0.0, 0.0, 1.0, 0.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n\t) * ret;\n\treturn ret;\n}\nvec4 buildQuat(vec3 axis, float angle){\n  axis = normalize(axis);\n  vec4 ret;\n  \n  float halfAngle = angle * 0.5;\n  float sin_a = sin(angle);\n  ret.w = cos(halfAngle);\n  ret.x = axis.x * sin_a;\n  ret.y = axis.y * sin_a;\n  ret.z = axis.z * sin_a;\n  \n  ret = normalize(ret);\n  return ret;\n}\nmat4 buildMat4Quat(vec4 quat)\n{\n\tfloat xx = quat.x * quat.x;\n\tfloat xy = quat.x * quat.y;\n\tfloat xz = quat.x * quat.z;\n\tfloat xw = quat.x * quat.w;\n\tfloat yy = quat.y * quat.y;\n\tfloat yz = quat.y * quat.z;\n\tfloat yw = quat.y * quat.w;\n\tfloat zz = quat.z * quat.z;\n\tfloat zw = quat.z * quat.w;\n\treturn mat4(\n\t\t1.0 - 2.0 * (yy + zz),\t\t2.0 * (xy + zw),\t\t2.0 * (xz - yw),\t\t0,\n\t\t2.0 * (xy - zw),\t\t\t\t1.0 - 2.0 * (xx + zz),\t2.0 * (yz + xw),\t\t0,\n\t\t2.0 * (xz + yw),\t\t\t\t2.0 * (yz - xw),\t\t1.0 - 2.0 * (xx + yy),\t0,\n\t\t0.0,\t\t\t\t\t\t\t0.0,\t\t\t\t\t0.0,\t\t\t\t\t1\n\t);\n}\nvoid main(void){\n\t\n\tif(uniform_grass_data[8] > TrueOrFalse){\n\t\trotVertexMatrix = uniform_billboardMatrix;\n\t}else{\n\t\trotVertexMatrix = buildRotMat4(vec3(0.0, attribute_grassAngleY, 0.0));\n\t}\n\te_position.xyz = (rotVertexMatrix * vec4(e_position, 1.0)).xyz;\n\te_normal.xyz = (rotVertexMatrix * vec4(e_normal, 1.0)).xyz;\n\tif(e_position.y > 0.0){ \n\t\tfloat windDirectionX\t\t\t= uniform_grass_data[0];\n\t\tfloat windDirectionZ\t\t\t= uniform_grass_data[1];\n\t\tfloat windSpaceX\t\t\t\t= uniform_grass_data[2];\n\t\tfloat windSpaceZ\t\t\t\t= uniform_grass_data[3];\n\t\tfloat windStrength\t\t\t\t= uniform_grass_data[4];\n\t\tfloat windSpeed\t\t\t\t\t= uniform_grass_data[5];\n\t\tfloat shakeScale\t\t\t\t= uniform_grass_data[6];\n\t\tfloat grassTime\t\t\t\t\t= uniform_grass_data[7];\n\t\tsqueezeData.enable\t\t\t= uniform_squeeze_data[0];\n\t\tsqueezeData.position.x\t\t= uniform_squeeze_data[1];\n\t\tsqueezeData.position.y\t\t= uniform_squeeze_data[2];\n\t\tsqueezeData.position.z\t\t= uniform_squeeze_data[3];\n\t\tsqueezeData.radius\t\t\t= uniform_squeeze_data[4];\n\t\tsqueezeData.strength\t\t= uniform_squeeze_data[5];\n\t\twindSpaceX = PI_2 * (attribute_grassOffset.x + abs(windDirectionX) * windSpeed * grassTime) / windSpaceX;\n\t\twindSpaceZ = PI_2 * (attribute_grassOffset.z + abs(windDirectionZ) * windSpeed * grassTime) / windSpaceZ;\n\t\t\n\t\tfloat angle = sin(windSpaceX + windSpaceZ) * shakeScale + windStrength;\n\t\tangle = clamp(angle, -1.57, 1.57);\n    \n\t\tvec3 windDir = vec3(windSpaceX, 0.0, windSpaceZ);\n\t\tvec3 windDirY = vec3(0.0, 1.0, 0.0);\n\t\twindDir = normalize(windDir);\n    \n\t\tvec3 axis = cross(windDirY,windDir); \n\t\tvec4 quat = buildQuat(axis, angle);\n\t\tmat4 matrix = buildMat4Quat(quat);\n    \n\t\tvec2 orgXZ = vec2(e_position.x, e_position.z);\n\t\te_position.x = e_position.z = 0.0;\n\t\te_position = (matrix * vec4(e_position, 1.0)).xyz;\n   \n\t\te_position.xz += orgXZ;\n\t\tif(squeezeData.enable > TrueOrFalse){\n\t\t\tvec3 distanceVec3 = squeezeData.position - attribute_grassOffset;\n\t\t\tvec2 distance2D = vec2(distanceVec3.x, distanceVec3.z);\n\t\t\tfloat distanceFloat = sqrt(dot(distance2D, distance2D));\n\t\t\tif(distanceFloat < squeezeData.radius){\n\t\t\t\tfloat ratio = distanceFloat / squeezeData.radius;\n\t\t\t\tratio = 1.0 - ratio;\n\t\t\t\tdistanceVec3 = normalize(distanceVec3);\n\t\t\t\tdistanceVec3 *= squeezeData.strength * ratio * abs(e_position.y - squeezeData.position.y);\n\t\t\t\te_position -= distanceVec3;\n\t\t\t}\n\t\t}\n\t}\n\te_position += attribute_grassOffset;\n\tmat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix);\n\tvarying_mvPose = outPosition = mvMatrix * vec4( e_position , 1.0 ); \n    varying_scenePose = vec4( e_position, 1.0 );\n    mat4 normalMatrix = inverse(mvMatrix) ;\n    normalMatrix = transpose(normalMatrix); \n    varying_eyeNormal = mat3(normalMatrix) * - e_normal; \n    varying_color = attribute_color; \n    \n}\n",
gui_fs: "varying vec4 varying_uv; \nvarying vec4 varying_color; \nvarying vec4 varying_pos; \nvarying vec4 varying_mask; \nvec4 diffuseColor; \nuniform sampler2D uiTexture_0; \nuniform sampler2D uiTexture_1; \nuniform sampler2D uiTexture_2; \nuniform sampler2D uiTexture_3; \nuniform sampler2D uiTexture_4; \nuniform sampler2D uiTexture_5; \nuniform sampler2D uiTexture_6; \nconst int FLAG_VALLID_QUAD = 0;\nconst int FLAG_IS_VISIBLE = 1;\nconst int FLAG_HAS_MASK = 2;\nconst int FLAG_HAS_TEXTURE = 3;\nconst int FLAG_IS_TEXTFIELD = 4;\nbool booleanArray[5];\nvoid decodeBooleanArray(float data){\n\tfloat headData;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[0] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[1] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[2] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[3] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[4] = (headData - data) > 0.2;\n}\nvoid main(void){\n\tdecodeBooleanArray(varying_pos.w);\n\t\n\t\n\tif(booleanArray[FLAG_VALLID_QUAD] == false || booleanArray[FLAG_IS_VISIBLE] == false || booleanArray[FLAG_HAS_TEXTURE] == false){\n\t\tdiscard;\n\t}\n\tif(booleanArray[FLAG_HAS_MASK]){\n      vec4 mask = varying_mask;\n      if( (2.0*mask.x-1.0) > varying_pos.x){ \n\t\tdiscard; \n      } \n      if( (-2.0*mask.y+1.0) < varying_pos.y){\n\t\tdiscard; \n      }\n      if( (2.0*mask.z-1.0) < varying_pos.x){\n\t\tdiscard; \n      }\n      if( (-2.0*mask.w+1.0) > varying_pos.y){\n\t\tdiscard; \n      }\n\t}\n\tvec2 uv = varying_uv.xy ;\n\tint index = int(floor(varying_pos.z)); \n\tif(booleanArray[FLAG_HAS_TEXTURE] == false){\n\t\tdiffuseColor = vec4(1.0, 1.0, 1.0, 1.0);\t}\n\telse{\n\t\tif(index==0){\n\t\t\tdiffuseColor = texture2D(uiTexture_0, uv ); \n\t\t}\n\t\telse if(index==1){\n\t\t\tdiffuseColor = texture2D(uiTexture_1, uv ); \n\t\t}\n\t\telse if(index==2){\n\t\t\tdiffuseColor = texture2D(uiTexture_2, uv ); \n\t\t}\n\t\telse if(index==3){\n\t\t\tdiffuseColor = texture2D(uiTexture_3, uv ); \n\t\t}\n\t\telse if(index==4){\n\t\t\tdiffuseColor = texture2D(uiTexture_4, uv ); \n\t\t}\n\t\telse if(index==5){\n\t\t\tdiffuseColor = texture2D(uiTexture_5, uv ); \n\t\t}\n\t\telse if(index==6){\n\t\t\tdiffuseColor = texture2D(uiTexture_6, uv ); \n\t\t}\n\t\tif(booleanArray[FLAG_IS_TEXTFIELD]){\n\t\t\tint clrChannel = int(uv.x);\n\t\t\tuv.x -= float(clrChannel);\n\t\t\tfloat fontAlpha = 1.0;\n\t\t\tif(clrChannel == 0){\n\t\t\t\tfontAlpha = diffuseColor.x;\n\t\t\t}else if(clrChannel == 1){\n\t\t\t\tfontAlpha = diffuseColor.y;\n\t\t\t} else if(clrChannel == 2){\n\t\t\t\tfontAlpha = diffuseColor.z;\n\t\t\t}else if(clrChannel == 3){\n\t\t\t\tfontAlpha = diffuseColor.w;\n\t\t\t}\n\t\t\tif(fontAlpha > 0.9){\n\t\t\t\tfontAlpha = 1.0;\n\t\t\t}\n\t\t\tdiffuseColor = vec4(1.0, 1.0, 1.0, fontAlpha);\n\t\t}\n\t}\n \n\tif(diffuseColor.w < 0.01 || varying_color.w < 0.01){\n\t\tdiscard;\n\t}\n\tdiffuseColor.xyz *= varying_color.xyz;\n\tdiffuseColor.w *= varying_color.w;\n\tdiffuseColor.xyz *= diffuseColor.w;\n\tdiffuseColor = clamp(diffuseColor, 0.0, 1.0); \n\tgl_FragColor = diffuseColor; \n}",
gui_vs: "attribute vec4 attribute_position; \nattribute vec4 attribute_shapePosition; \nattribute vec4 attribute_uvRec; \nattribute vec4 attribute_rotate; \nattribute vec4 attribute_maskRectangle; \nattribute vec4 attribute_quad_color; \nvarying vec4 varying_uv; \nvarying vec4 varying_color; \nvarying vec4 varying_pos; \nvarying vec4 varying_mask; \nvarying float varying_boolList;\nvec4 outPosition; \nuniform mat4 uniform_ModelMatrix; \nuniform mat4 uniform_ViewMatrix; \nuniform mat4 uniform_ProjectionMatrix; \nuniform mat4 uniform_orthProjectMatrix; \nuniform float uniform_materialSource[20]; \nmat4 buildMat4Quat(vec4 quat){ \nfloat xx = quat.x * quat.x; \nfloat xy = quat.x * quat.y; \nfloat xz = quat.x * quat.z; \nfloat xw = quat.x * quat.w; \nfloat yy = quat.y * quat.y; \nfloat yz = quat.y * quat.z; \nfloat yw = quat.y * quat.w; \nfloat zz = quat.z * quat.z; \nfloat zw = quat.z * quat.w; \nreturn mat4( \n1.0 - 2.0 * (yy + zz),\t\t2.0 * (xy + zw),\t\t2.0 * (xz - yw),\t\t0, \n2.0 * (xy - zw),\t\t\t\t1.0 - 2.0 * (xx + zz),\t2.0 * (yz + xw),\t\t0, \n2.0 * (xz + yw),\t\t\t\t2.0 * (yz - xw),\t\t1.0 - 2.0 * (xx + yy),\t0, \n0.0,\t\t\t\t\t\t\t0.0,\t\t\t\t\t0.0,\t\t\t\t\t1 \n); \n}\nconst int FLAG_VALLID_QUAD = 0;\nconst int FLAG_IS_VISIBLE = 1;\nconst int FLAG_HAS_MASK = 2;\nconst int FLAG_HAS_TEXTURE = 3;\nconst int FLAG_IS_TEXTFIELD = 4;\nbool booleanArray[5];\nvoid decodeBooleanArray(float data){\n\tfloat headData;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[0] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[1] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[2] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[3] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[4] = (headData - data) > 0.2;\n}\nvoid main(void){\n\tgl_PointSize = uniform_materialSource[18];\n\tvarying_pos.zw = attribute_shapePosition.zw;\n\tdecodeBooleanArray(attribute_shapePosition.w);\n\tif(booleanArray[FLAG_VALLID_QUAD] == false || booleanArray[FLAG_IS_VISIBLE] == false || booleanArray[FLAG_HAS_TEXTURE] == false){\n\t\toutPosition = vec4(0.0,0.0,0.0,1.0);\n\t\tgl_Position = outPosition; \n\t\treturn;\n\t}\n    float devicePixelRatio = 1.0;    mat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n    mat4 po = buildMat4Quat(attribute_rotate.xyzw); \n    mat4 oth = uniform_orthProjectMatrix; \n    float px = oth[0].x ;\n    float py = oth[1].y ;\n    \n    oth[0].x = oth[0].x / devicePixelRatio ; \n    oth[1].y = oth[1].y / devicePixelRatio ; \n    \n    vec3 pos = mat3(po) * (attribute_position.xyz * vec3(attribute_uvRec.zw,1.0) ) + vec3(attribute_shapePosition.xy,1.0) ; \n    vec3 sceneWH = vec3( 1.0/ oth[0].x, -1.0/oth[1].y , 0.0 )  ; \n    outPosition = mvMatrix * vec4( pos - sceneWH , 1.0 ) ; \n    varying_color = attribute_quad_color ; \n    \n    outPosition = oth * outPosition ; \n\tvarying_pos.xy = outPosition.xy;\n    vec4 maskk = attribute_maskRectangle;\n    \n    sceneWH = vec3(2.0/px*devicePixelRatio,2.0/py*devicePixelRatio,1.0) ;\n    \n    varying_mask = vec4(maskk.xy/sceneWH.xy,(maskk.x+maskk.z)/sceneWH.x, (maskk.y+maskk.w)/(sceneWH.y)) ; \n    varying_uv = attribute_uvRec; \n\tgl_Position = outPosition; \n    \n}",
hud_H_fs: "varying vec2 varying_uv0;\nuniform sampler2D diffuseTexture;\nvoid main(void) {\n\tvec2 uv = vec2(varying_uv0.x ,1.0-varying_uv0.y);\n\tvec4 color = texture2D(diffuseTexture, uv);\n\tgl_FragColor  = color;\n}\n",
hud_V_fs: "varying vec2 varying_uv0;\nuniform sampler2D diffuseTexture;\nvoid main(void) {\n\tvec4 color = texture2D(diffuseTexture, varying_uv0);\n\tgl_FragColor  = color;\n}\n",
hud_cull_fs: "varying vec2 varying_uv0;\nuniform sampler2D diffuseTexture;\nuniform vec2 uv_scale;\nvoid main(void) {\n\tvec2 uv_0 = varying_uv0;\n\tuv_0 *= uv_scale;\n\tvec4 color = texture2D(diffuseTexture, varying_uv0);\n\tfloat mask = 1.0;\n\tfloat f = uv_scale.y - varying_uv0.y;\n\tif (varying_uv0.y < uv_scale.y){\n\t\tif(f < 0.03 && f > 0.0){\n\t\t\tmask =1.0 - (f / 0.03 * 0.9 + 0.1);\n\t\t}\n\t\telse{\n\t\t\tmask = 0.1;\n\t\t}\n\t}\n\tcolor.xyz *= mask;\n\tgl_FragColor  = color;\n}\n",
hud_vs: "attribute vec3 attribute_position;\nattribute vec2 attribute_uv0;\nvarying  vec2 varying_uv0;                      \nuniform  mat4 uniform_ViewProjectionMatrix;\nvoid main(void) {\n    vec4 pos = vec4(attribute_position, 1.0);\n    gl_Position = uniform_ViewProjectionMatrix * pos;\n    varying_uv0 = attribute_uv0;\n}",
lightMapSpecularPower_fs: "uniform sampler2D lightTexture ;\nvarying vec2 varying_uv1 ;\nvec4 decode_hdr( vec4 data ){ \n    data.w = data.w * 255.0 - 128.0 ; \n    data.w = pow( 2.0 ,data.w); \n    data.xyz *= data.w ; \n    return data ; \n}\nvoid main(void){\n\tvec4 lightmap = texture2D( lightTexture , varying_uv1 );\n    lightmap.xyz = decode_hdr(lightmap).xyz ;\n\toutColor.xyz *= lightmap.xyz ;\n}\n ",
lightMap_fs: "uniform sampler2D lightTexture ;\nvarying vec2 varying_uv1 ;\nvec4 decode_hdr( vec4 data ){ \n    data.w = data.w * 255.0 - 128.0 ; \n    data.w = pow( 2.0 ,data.w); \n    data.xyz *= data.w ; \n    return data ; \n}\nvoid main(void){\n\tvec4 lightmap = texture2D( lightTexture , varying_uv1 );\n\tlightmap.xyz = decode_hdr(lightmap).xyz  ;\n    outColor.xyz *= lightmap.xyz ; \n}\n",
lightingBase_fs: "vec4 LightingBlinnPhong(vec3 lightDir, vec3 lightColor , vec3 lightAmbient , vec3 normal , vec3 viewDir, float atten){ \n\tvec3 h = normalize(lightDir + normalize(viewDir)); \n\tfloat diff = max(dot(normal, lightDir),0.0); \n\tfloat nh = max(dot(normal,h),0.0); \n\tfloat spec = pow(nh, materialSource.shininess ) * materialSource.specularScale ; \n\tvec4 c ; \n\tc.rgb = (s.Albedo * lightColor * diff + lightColor * materialSource.specular.rgb * s.Specular.rgb * spec) * (atten * 2.0); \n\tc.a = s.Alpha + spec * atten; \n\treturn c; \n}\nvoid main(void) {\n}\n",
lineFog: " \nstruct Fog{\n   vec3 fogColor  ;\n   float globalDensity ;\n   float fogStartDistance ;\n   float fogFarDistance ;\n   float fogAlpha ;\n};\nuniform float uniform_globalFog[7];\nvarying vec4 varying_mvPose;\nvoid main(void){\n    Fog fog; \n    fog.fogColor = vec3(uniform_globalFog[0],uniform_globalFog[1],uniform_globalFog[2]); \n    fog.globalDensity = uniform_globalFog[3]; \n    fog.fogStartDistance = uniform_globalFog[4] ;\n    fog.fogFarDistance = uniform_globalFog[5] ;\n    fog.fogAlpha = uniform_globalFog[6] ;\n    \n\tfog.fogColor *= outColor.w;\n\tfloat d = varying_mvPose.z ; \n\tfloat distFog = max( 0.0 , d -  fog.fogStartDistance ) ; \n\toutColor.xyz = mix( outColor.xyz,fog.fogColor, clamp(distFog/fog.fogFarDistance,0.0,1.0) * fog.fogAlpha ) ; \n}\n",
matCapPass_vs: "varying vec2 capCoord ;\nvoid main(void){\n        capCoord.x = dot(normalMatrix[0].xyz,normal);\n        capCoord.y = dot(normalMatrix[1].xyz,normal);\n        capCoord = capCoord * 0.5 + 0.5;\n        ambientColor.xyz +=  + capCoord.xyz * 2.0 - 1.0 ;\n}",
matCap_TextureAdd_fs: "uniform sampler2D matcapTexture;\nvoid main() {\n  \tvec4 capCoord ; \n\tcapCoord.x = -normal.x; \n\tcapCoord.y = normal.y; \n\tcapCoord.xy = capCoord.xy * 0.5 + 0.5; \n\tcapCoord = texture2D(matcapTexture , capCoord.xy ) * 2.0 - 1.0 ; \n\tambientColor.xyz += capCoord.xyz ; \n}\n",
matCap_TextureMult_fs: "uniform sampler2D matcapTexture;\nvoid main() {\n  \tvec4 capCoord ; \n\tcapCoord.x = -normal.x; \n\tcapCoord.y = normal.y; \n\tcapCoord.xy = capCoord.xy * 0.5 + 0.5; \n\tcapCoord = texture2D(matcapTexture , capCoord.xy ) ; \n\tdiffuseColor.xyz *= capCoord.xyz * 2.0 ; \n}\n",
materialSource_fs: "struct MaterialSource{\n    vec3 diffuse;\n    vec3 ambient;\n    vec3 specular;\n    float alpha;\n    float cutAlpha;\n    float shininess;\n    float normalDir;\n    vec4 uvRectangle;\n    float gamma;\n    float specularScale;\n    float refraction;\n    float refractionintensity;\n}; \nuniform float uniform_materialSource[20] ;\nMaterialSource materialSource ;\nvec2 uv_0 ;\nvoid main(){\n\tmaterialSource.diffuse.x = uniform_materialSource[0];\n\tmaterialSource.diffuse.y = uniform_materialSource[1];\n\tmaterialSource.diffuse.z = uniform_materialSource[2];\n\t\n\tmaterialSource.ambient.x = uniform_materialSource[3];\n\tmaterialSource.ambient.y = uniform_materialSource[4];\n\tmaterialSource.ambient.z = uniform_materialSource[5];\n\t\n\tmaterialSource.specular.x = uniform_materialSource[6];\n\tmaterialSource.specular.y = uniform_materialSource[7];\n\tmaterialSource.specular.z = uniform_materialSource[8];\n\t\n\tmaterialSource.alpha = uniform_materialSource[9];\n\tmaterialSource.cutAlpha = uniform_materialSource[10];\n\tmaterialSource.shininess = uniform_materialSource[11];\n\tmaterialSource.specularScale = uniform_materialSource[12];\n\tmaterialSource.normalDir = 1.0 ;    \n\tmaterialSource.uvRectangle.x = uniform_materialSource[13];\n\tmaterialSource.uvRectangle.y = uniform_materialSource[14];\n\tmaterialSource.uvRectangle.z = uniform_materialSource[15];\n\tmaterialSource.uvRectangle.w = uniform_materialSource[16];\n\tmaterialSource.gamma = uniform_materialSource[17];\n\tmaterialSource.refraction = uniform_materialSource[18];\n\tmaterialSource.refractionintensity = uniform_materialSource[19];\n\tuv_0 = varying_uv0.xy * materialSource.uvRectangle.zw + materialSource.uvRectangle.xy ;\n}",
mulUvRoll_fs: "uniform float mulUvRoll[4] ;\nuniform sampler2D diffuseTexture;\nuniform sampler2D diffuseTexture1;\nvec4 diffuseColor ;\nvec2 uv_1;\nvoid main() {\n\tuv_1 = varying_uv0;\n    uv_0.xy += vec2(mulUvRoll[0],mulUvRoll[1]);\n\tuv_1.xy += vec2(mulUvRoll[2],mulUvRoll[3]);\n\tdiffuseColor = texture2D(diffuseTexture , uv_0 ) * texture2D(diffuseTexture1 , uv_1 );\n\tdiffuseColor.xyz = clamp(diffuseColor.xyz / diffuseColor.w,0.0,1.0);\n}",
normalMap_fragment: "uniform sampler2D normalTexture;\nvarying vec2 varying_uv0        ;\nvarying vec4 varying_mvPose        ;\nmat3 TBN ;\nmat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) {\n  vec3 dp1 = dFdx(p);\n  vec3 dp2 = dFdy(p);\n  vec2 duv1 = dFdx(uv);\n  vec2 duv2 = dFdy(uv);\n  vec3 dp2perp = cross(dp2, N);\n  vec3 dp1perp = cross(N, dp1);\n  vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n  vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n  float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));\n  return mat3(T * invmax, B * invmax, N);\n}\nvec3 tbn(vec3 map, vec3 N, vec3 V, vec2 texcoord) {\n  mat3 TBN = cotangentFrame(N, -V, texcoord);\n  return normalize(TBN * map);\n}\nvoid main(){\n   s.Normal = texture2D(normalTexture,uv_0).xyz *2.0 - 1.0; \n   s.Normal = tbn( s.Normal.xyz , normal.xyz , varying_mvPose.xyz , uv_0 ) ; \n}\n",
normalPassEnd_fs: "void main() {\n    outColor = vec4(normal,1.0);\n}\n",
outLine_fs: "uniform float uniform_ouline[5] ;\nvoid main(){\n     diffuseColor = vec4(uniform_ouline[1],\n                    uniform_ouline[2],\n                    uniform_ouline[3],\n                    uniform_ouline[4]) ;\n    outColor = diffuseColor; \n}",
outLine_vs: "attribute vec3 attribute_normal;\nattribute vec4 attribute_color;\nvarying vec4 varying_mvPose; \nuniform float uniform_ouline[5] ;\nvoid main(void){\n    outPosition.xy -= normalize(varying_eyeNormal.xyz).xy * uniform_ouline[0]; \n}",
out_fs: "void main(){\n    gl_FragColor = outColor;\n}",
out_vs: "void main(){\n     gl_Position = outPosition ;\n}",
particle_bezier: "float calcBezierArea(float bzData[35], float tCurrent, float tTotal){\n\tfloat res = 0.0;\n\tfloat v0;\n\tfloat v1;\n\tfloat t0;\n\tfloat t1;\n\tfloat deltaTime = 0.0;\n\tfloat a_deltaTime;\n\tfor(int i = 0; i < 16; i ++)\n\t{\n\t\tt0 = bzData[i * 2 + 0] * tTotal;\n\t\tv0 = bzData[i * 2 + 1];\n\t\tt1 = bzData[i * 2 + 2] * tTotal;\n\t\tv1 = bzData[i * 2 + 3];\n\t\tdeltaTime = t1 - t0;\n\t\t\ta_deltaTime = 0.5 * (v1 - v0);\n\t\t\tif(tCurrent >= t1)\n\t\t\t{\n\t\t\t\tres += deltaTime * (v0 + a_deltaTime);\n\t\t\t}else\n\t\t\t{\n\t\t\t\tdeltaTime = tCurrent - t0;\n\t\t\t\tres += deltaTime * (v0 + a_deltaTime);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn res;\n}\nfloat calcBezierSize(float bzData[35], float tCurrent, float tTotal){\n\tfloat res = 0.0;\n\tfloat y0;\n\tfloat y1;\n\tfloat t0;\n\tfloat t1;\n\tfloat deltaTime = 0.0;\n\tfloat v;\n\tfor(int i = 0; i < 16; i ++)\n\t{\n\t\tt0 = bzData[i * 2 + 0] * tTotal;\n\t\ty0 = bzData[i * 2 + 1];\n\t\tt1 = bzData[i * 2 + 2] * tTotal;\n\t\ty1 = bzData[i * 2 + 3];\n\t\tdeltaTime = t1 - t0;\n\t\t\tif(tCurrent <= t1)\n\t\t\t{\n\t\t\t\tv = (y1 - y0) / deltaTime;\n\t\t\t\tdeltaTime = tCurrent - t0;\n\t\t\t\tres = y0 + v * deltaTime;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn res;\n}\n",
particle_bezier_low: "float calcBezierArea(float bzData[35], float tCurrent, float tTotal){\n\tfloat res = 0.0;\n\tfloat v0;\n\tfloat v1;\n\tfloat t0;\n\tfloat t1;\n\tfloat breakFlag = 1.0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tt1 = bzData[i * 4];\n\t\tv1 = bzData[i * 4 + 1];\n\t\tt0 = bzData[(i - 1) * 4];\n\t\tv0 = bzData[(i - 1) * 4 + 1];\n\t\tres += (min(tCurrent, t1) - t0) * (0.5 * (v1 + v0)) * breakFlag;\n\t\tif(t1 >= tCurrent) {\n\t\t\tbreakFlag = 0.0;\n\t\t}\n\t}\n\treturn res;\n}\nfloat calcBezierSize(float bzData[35], float tCurrent, float tTotal){\n\tfloat res = 0.0;\n\tfloat y0;\n\tfloat y1;\n\tfloat t0;\n\tfloat t1;\n\t\n\tfor (int i = 1; i < 4; i ++) {\n\t\tt1 = bzData[i * 4];\n\t\ty1 = bzData[i * 4 + 1];\n\t\tif(t1 >= tCurrent) {\n\t\t\tt0 = bzData[(i - 1) * 4];\n\t\t\ty0 = bzData[(i - 1) * 4 + 1];\n\t\t\tfloat age = (tCurrent - t0) / (t1 - t0);\n\t\t\tres = y0 + (y1 - y0) * age;\n\t\t}\n\t}\n\treturn res;\n}\n",
particle_color_fs: "//##FilterBegin## ##Particle##\r\nuniform float uniform_colorTransform[40];\r\n//ѹ��������ɫ,rg.b�ĸ�ʽ\r\nvec3 unpack_color(float rgb_data)\r\n{\r\n    vec3 res;\r\n    res.z = fract( rgb_data );\r\n    rgb_data -= res.z;\r\n    \r\n    rgb_data = rgb_data/256.0;\r\n    res.y = fract( rgb_data );\r\n    rgb_data -= res.y;\r\n    \r\n    res.x = rgb_data/256.0;\r\n    return res;\r\n}\r\n\r\nvoid main() {\r\n    float startColor ;\r\n    float startSegment ;\r\n    \r\n    float nextColor ;\r\n    float nextSegment ;\r\n\r\n    float startAlpha;\r\n\tfloat nextAlpha;\r\n\r\n    float progress = varying_particleData.x/varying_particleData.y;\r\n\tconst int maxColorCount = 20;\r\n\tconst int loopCount = 20;\r\n    for( int i = 1 ; i < loopCount ; i++ ){\r\n       if( progress >= fract(uniform_colorTransform[i+maxColorCount-1]) ){\r\n          startColor = uniform_colorTransform[i-1] ;\r\n          startSegment = fract(uniform_colorTransform[i+maxColorCount-1]) ;\r\n          nextColor = uniform_colorTransform[i];\r\n          nextSegment = fract(uniform_colorTransform[i+maxColorCount]) ;\r\n\r\n\t\t  startAlpha = uniform_colorTransform[i+maxColorCount-1] - startSegment;\r\n\t\t  nextAlpha = uniform_colorTransform[i+maxColorCount] - nextSegment;\r\n       }else{\r\n          break;\r\n       }\r\n    } \r\n    \r\n    float len = nextSegment - startSegment ;\r\n    float ws = ( progress - startSegment ) / len ;\r\n\tws = clamp(ws,0.0,1.0);\r\n    globalColor = mix(vec4(unpack_color(startColor).xyz,startAlpha / 256.0),vec4(unpack_color(nextColor).xyz, nextAlpha / 256.0),ws) ;\r\n\tglobalColor = clamp(globalColor,0.0,1.0);\r\n}\r\n//##FilterEnd##",
particle_color_fs_low: "//##FilterBegin## ##Particle##\r\nuniform float uniform_colorTransform[40];\r\n//ѹ��������ɫ,rg.b�ĸ�ʽ\r\nvec3 unpack_color(float rgb_data)\r\n{\r\n    vec3 res;\r\n    res.z = fract( rgb_data );\r\n    rgb_data -= res.z;\r\n    \r\n    rgb_data = rgb_data/256.0;\r\n    res.y = fract( rgb_data );\r\n    rgb_data -= res.y;\r\n    \r\n    res.x = rgb_data/256.0;\r\n    return res;\r\n}\r\n\r\nvoid main() {\r\n    float startColor ;\r\n    float startSegment ;\r\n    \r\n    float nextColor ;\r\n    float nextSegment ;\r\n\r\n    float startAlpha;\r\n\tfloat nextAlpha;\r\n\r\n    float progress = varying_particleData.x/varying_particleData.y;\r\n\tconst int maxColorCount = 20;\r\n\tconst int loopCount = 4;\r\n    for( int i = 1 ; i < loopCount ; i++ ){\r\n       if( progress >= fract(uniform_colorTransform[i+maxColorCount-1]) ){\r\n          startColor = uniform_colorTransform[i-1] ;\r\n          startSegment = fract(uniform_colorTransform[i+maxColorCount-1]) ;\r\n          nextColor = uniform_colorTransform[i];\r\n          nextSegment = fract(uniform_colorTransform[i+maxColorCount]) ;\r\n\r\n\t\t  startAlpha = uniform_colorTransform[i+maxColorCount-1] - startSegment;\r\n\t\t  nextAlpha = uniform_colorTransform[i+maxColorCount] - nextSegment;\r\n       }else{\r\n          break;\r\n       }\r\n    } \r\n    \r\n    float len = nextSegment - startSegment ;\r\n    float ws = ( progress - startSegment ) / len ;\r\n\tws = clamp(ws,0.0,1.0);\r\n    globalColor = mix(vec4(unpack_color(startColor).xyz,startAlpha / 256.0),vec4(unpack_color(nextColor).xyz, nextAlpha / 256.0),ws) ;\r\n\tglobalColor = clamp(globalColor,0.0,1.0);\r\n}\r\n//##FilterEnd##",
particle_color_vs: "void getNodeData(){\n\t\n}\n//##FilterEnd##",
particle_diffuse_fragment: "uniform sampler2D diffuseTexture;\nvec4 diffuseColor ;\nvec4 globalColor = vec4(1.0, 1.0, 1.0, 1.0);\nvoid calcUVCoord(){\n}\nvoid main() {\n    if( diffuseColor.w == 0.0 ){\n\t\tdiscard;\n\t}\n\tcalcUVCoord();\n\tdiffuseColor = texture2D(diffuseTexture , uv_0 );\n    \n    if( diffuseColor.w < materialSource.cutAlpha ){\n\t\tdiscard;\n\t}\n}\n",
particle_end_fs: "varying vec4 varying_particleData;\nvarying vec4 varying_mvPose;\nvoid main() {\n\tvec3 fc ;\n\tif(materialSource.refraction<2.41){ \n\t   float vl = dot(normal,-normalize(varying_mvPose.xyz)); \n\t   fc = Fresnel_Schlick(vl,vec3(materialSource.refraction)) * materialSource.refractionintensity ; \n\t   fc.xyz = max(fc,vec3(0.0)) ; \n\t} \n  \n\ts.Albedo = diffuseColor.rgb * globalColor.xyz ;\ts.Albedo.x = pow(s.Albedo.x, materialSource.gamma);\n    s.Albedo.y = pow(s.Albedo.y, materialSource.gamma);\n    s.Albedo.z = pow(s.Albedo.z, materialSource.gamma);\n\ts.Albedo = s.Albedo * varying_color.xyz;\n\ts.Alpha = diffuseColor.a * globalColor.w * materialSource.alpha * varying_color.w ; \n\toutColor.xyz = s.Albedo ; \n\toutColor.w = s.Alpha; \n\tif(varying_particleData.w > 0.5){ \n\toutColor.xyz *= outColor.w; \n\t} \n\toutColor = clamp(outColor, 0.0, 1.0) ; \n}\n",
particle_end_vs: "varying vec4 varying_pos;\nmat4 buildModelMatrix(vec4 quat, vec3 scale, vec3 position)\n{\n\tmat4 ret = mat4( \n\t\tvec4(scale.x, 0.0, 0.0, 0.0), \n\t\tvec4(0.0, scale.y, 0.0, 0.0), \n\t\tvec4(0.0, 0.0, scale.z, 0.0), \n\t\tvec4(0.0, 0.0, 0.0, 1.0) \n\t);\n\tret = buildMat4Quat(quat) * ret; \n\t \n\tret[3][0] = position.x;\n\tret[3][1] = position.y;\n\tret[3][2] = position.z;\n\treturn ret;\n}\nvec3 calcParticleMove(vec3 distanceXYZ){\n\tif(velocityLimitVec2.y > TrueOrFalse){\n\t\tvec3 temp = distanceXYZ * distanceXYZ;\n\t\tfloat distanceCurrent = sqrt(temp.x + temp.y + temp.z);\n\t\tfloat distanceLimit = velocityLimitVec2.x;\n\t\tif(distanceLimit < Tiny){\n\t\t\treturn vec3(0.0);\n\t\t}\n\t\tif(distanceCurrent > distanceLimit){\n\t\t\tfloat nowFrame = currentTime / 0.017;\n\t\t\tfloat dampen = 1.0 - particleStateData.velocityLimitDampen;\n\t\t\tfloat startDistance = (distanceCurrent - distanceLimit) / nowFrame;\n\t\t\tfloat distanceResult = 0.0;\n\t\t\tfloat tempDistance = startDistance;\n\t\t\tfor(int i = 1; i < 600; i++){\n\t\t\t\tdistanceResult += tempDistance;\n\t\t\t\ttempDistance *= dampen;\n\t\t\t\tif(float(i) > nowFrame)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdistanceXYZ *= (distanceResult + distanceLimit) / distanceCurrent;\n\t\t}\n\t}\n\treturn distanceXYZ;\n}\nbool updateStretchedBillBoard(vec3 moveVector){\n\treturn true;\t\n}\nvoid main(void) {\n\t\n\tvec3 position_emitter = attribute_offsetPosition;\n\tvec3 velocityLocalVec3 = velocityBaseVec3 * currentTime;\n\tvec3 velocityWorldVec3 = vec3(0.0,0.0,0.0);\n\tvec3 velocityMultiVec3 = vec3(0.0,0.0,0.0);\n\tif(particleStateData.velocityOverWorldSpace < TrueOrFalse){\n\t\tvelocityLocalVec3 += velocityOverVec3;\t\t\n\t}else{\n\t\tvelocityWorldVec3 += velocityOverVec3;\n\t}\n\tif(particleStateData.velocityForceWorldSpace < TrueOrFalse){\n\t\tvelocityLocalVec3 += velocityForceVec3;\n\t}else{\n\t\tvelocityWorldVec3 += velocityForceVec3;\n\t}\n\tposition_emitter *= vec3(particleStateData.scaleX, particleStateData.scaleY, particleStateData.scaleZ);\n\tif(particleStateData.worldSpace > TrueOrFalse){\n\t}else{\n\t\tfollowTargetPosition.x = particleStateData.positionX;\n\t\tfollowTargetPosition.y = particleStateData.positionY;\n\t\tfollowTargetPosition.z = particleStateData.positionZ;\n\t\tfollowTargetRotation.x = particleStateData.rotationX;\n\t\tfollowTargetRotation.y = particleStateData.rotationY;\n\t\tfollowTargetRotation.z = particleStateData.rotationZ;\n\t\tfollowTargetRotation.w = particleStateData.rotationW;\n\t}\n\tmat4 followRotQuat = buildMat4Quat(followTargetRotation);\n\tvelocityLocalVec3 = (followRotQuat * vec4(velocityLocalVec3, 1.0)).xyz;\n\tif(particleStateData.renderMode == Mesh){ \n\t\trotVertexMatrix = followRotQuat * rotVertexMatrix; \n\t}\n\tlocalPosition.xyz *= scaleSize;\n\tlocalPosition = rotVertexMatrix * localPosition; \n\ttrackPosition();\n\tmat4 modelMatrix = buildModelMatrix(followTargetRotation, followTargetScale, followTargetPosition);\n\tposition_emitter = (modelMatrix * vec4(position_emitter, 1.0)).xyz; \n\tvelocityMultiVec3 = velocityLocalVec3 + velocityWorldVec3;\n\tvelocityMultiVec3 = calcParticleMove(velocityMultiVec3);\n\tvelocityMultiVec3.y -= 4.9 * currentTime * currentTime * particleStateData.gravity;\t\t\n\tposition_emitter += velocityMultiVec3; \n\tif(particleStateData.renderMode == StretchedBillboard){\n\t\tdiscard_particle = discard_particle || updateStretchedBillBoard(velocityMultiVec3) == false; \n\t\toutPosition = localPosition;\n\t\trotVertexMatrix = rotVertexMatrix * uniform_billboardMatrix; \n\t}else{\n\t\toutPosition = uniform_billboardMatrix * localPosition;\n\t}\n\tif(discard_particle){\n\t\toutPosition = vec4(0.0,0.0,0.0,0.0); \n\t}else{\n\t\t\n\t\toutPosition.xyz += position_emitter.xyz;\n\t\toutPosition = uniform_ViewMatrix * outPosition;\n\t\te_normal.xyz = (rotVertexMatrix * vec4(e_normal, 1.0)).xyz;\n\t\te_normal = normalize(e_normal);\n\t\tmat4 mvMatrix = mat4(uniform_ViewMatrix * modelMatrix);\n\t\tvarying_mvPose = outPosition;\n    \t\n\t\tmat4 normalMatrix = inverse(mvMatrix) ;\n\t\tnormalMatrix = transpose(normalMatrix); \n\t\t\n\t\tvarying_eyeNormal = mat3(normalMatrix) * - e_normal; \n\t}\n\tvarying_pos = outPosition = uniform_ProjectionMatrix * outPosition;\n}\n\t\n//##FilterEnd##",
particle_follow_vs: "attribute vec3 attribute_followPosition ;\nattribute vec4 attribute_followRotation ;\nattribute vec3 attribute_followScale;\nvoid getNodeData(){\n\t followTargetPosition = attribute_followPosition;\n\t followTargetRotation = attribute_followRotation;\n}\n\t\n//##FilterEnd##",
particle_rotationConst: "attribute float attribute_rotationZ ;\nvoid getUnitRotate(){\n\trotResultVec3.z = currentTime * attribute_rotationZ;\n}\n",
particle_rotationOneBezier: "uniform float uniform_rotationBezier[35];\nvoid getUnitRotate(){\n\tfloat rot = calcBezierArea(uniform_rotationBezier, currentTime, curParticle.life);\n\trotResultVec3.z = rot;\n}\n",
particle_rotationTwoBezier: "attribute float attribute_rotationRandomSeed;\nuniform float uniform_rotationBezier[35];\nuniform float uniform_rotationBezier2[35];\nvoid getUnitRotate(){\n\tvec2 rotationTwoBezier = vec2(0.0);\n\trotationTwoBezier.x = calcBezierArea(uniform_rotationBezier, currentTime, curParticle.life);\n\trotationTwoBezier.y = calcBezierArea(uniform_rotationBezier2, currentTime, curParticle.life);\n\tfloat rot = mix(rotationTwoBezier.x, rotationTwoBezier.y, attribute_rotationRandomSeed);\n\trotResultVec3.z = rot;\n}\n",
particle_rotationXYZConst: "attribute vec3 attribute_rotSpeedXYZ ;\nattribute vec3 attribute_rotBirthXYZ ;\nvoid getUnitRotate(){\n\trotResultVec3 = (attribute_rotBirthXYZ + particleStateData.time * attribute_rotSpeedXYZ);\n\trotResultVec3 = mod(rotResultVec3, 360.0);\n}\n",
particle_scaleSizeBezier1: "uniform float uniform_scaleSizeBezier1[35];\nvoid main() {\n\tscaleSize *= calcBezierSize(uniform_scaleSizeBezier1, currentTime, curParticle.life);\n}\n",
particle_scaleSizeBezier2: "attribute float attribute_bezierRandomSeed;\nuniform float uniform_scaleSizeBezier1[35];\nuniform float uniform_scaleSizeBezier2[35];\nvoid main() {\n\tvec2 scaleVec2 = vec2(0.0);\n\tscaleVec2.x = calcBezierArea(uniform_scaleSizeBezier1, currentTime, curParticle.life);\n\tscaleVec2.y = calcBezierArea(uniform_scaleSizeBezier2, currentTime, curParticle.life);\n\tscaleSize * = mix(scaleVec2.x, scaleVec2.y, attribute_bezierRandomSeed);\n}\n",
particle_scaleSizeConst: "attribute float attribute_scaleSizeConst;\nvoid main() {\n\tscaleSize *= attribute_scaleSizeConst;\n}\n//##FilterEnd##",
particle_stretched_mode: "\nbool updateStretchedBillBoard(vec3 moveVector){\n\tif(currentTime < 0.016){\n\t\treturn false;\n\t}\n\tfloat speed = dot(moveVector, moveVector); \n\tspeed = sqrt(speed) / currentTime; \n\tspeed /= 100.0;\n\tif(speed < Tiny){\n\t\treturn false;\n\t}\n\tlocalPosition.y = localPosition.y * particleStateData.lengthScale + speed * particleStateData.speedScale * localPosition.y / scaleSize;\n\tvec3 dir1 = vec3(0.0, 1.0, 0.0);\n\tvec3 dir2 = normalize(moveVector);\n\tvec3 axis = normalize(cross(dir1, dir2));\n    float angle = acos(dot(dir1, dir2));\n\tvec4 quat = vec4(0.0, 0.0, 0.0, 1.0);\n    float halfAngle = angle * 0.5;\n    float sin_a = sin(halfAngle);\n    quat.w = cos(halfAngle);\n    quat.x = axis.x * sin_a;\n    quat.y = axis.y * sin_a;\n    quat.z = axis.z * sin_a;\n    quat = normalize(quat);\n\t\n\tlocalPosition = uniform_billboardMatrix * localPosition;\n\trotVertexMatrix = buildMat4Quat(quat); \n\tlocalPosition = rotVertexMatrix * localPosition;\n\treturn true;\n}\n",
particle_textureSheetConst: "\nvarying vec3 varying_textureSheetData;\nuniform float uniform_textureSheet[5];\nvec2 getSheetOffset(float frame, float tileX, float tileY)\n{\n\tframe = floor(frame);\n\tvec2 ret = vec2(0.0); \n\tret.x = (1.0 / tileX) * mod(frame, tileX); \n\tret.y = frame / tileX;\n\tret.y = floor(ret.y);\n\tret.y = (1.0 / tileY) * ret.y; \n\treturn ret;\n}\nvoid calcUVCoord() {\n\tvec2 rectUV = vec2(1.0 / uniform_textureSheet[0], 1.0 / uniform_textureSheet[1]);\n\tuv_0.xy *= rectUV;\n\t\n\tfloat frame = varying_textureSheetData.x + varying_textureSheetData.y;\n\tframe = clamp(frame, uniform_textureSheet[3], uniform_textureSheet[4]);\n\tuv_0.xy += getSheetOffset(frame, uniform_textureSheet[0], uniform_textureSheet[1]);\n}\n",
particle_textureSheetOneBezier: "\nvarying vec3 varying_textureSheetData;\nuniform float uniform_textureSheet[5];\nuniform float uniform_frameBezier[35];\nvec2 getSheetOffset(float frame, float tileX, float tileY)\n{\n\tframe = floor(frame);\n\tvec2 ret = vec2(0.0); \n\tret.x = (1.0 / tileX) * mod(frame, tileX); \n\tret.y = frame / tileX;\n\tret.y = floor(ret.y);\n\tret.y = (1.0 / tileY) * ret.y; \n\treturn ret;\n}\nvoid calcUVCoord() {\n\tvec2 rectUV = vec2(1.0 / uniform_textureSheet[0], 1.0 / uniform_textureSheet[1]);\n\tuv_0.xy *= rectUV;\n\t\n\tfloat frame = varying_textureSheetData.x + varying_textureSheetData.y;\n\tfloat currentTime = varying_particleData.x * uniform_textureSheet[2];\n\tcurrentTime = mod(currentTime, varying_particleData.y);\n\tfloat bezierFrame = calcBezierSize(uniform_frameBezier, currentTime, varying_particleData.y);\n\tbezierFrame = clamp(bezierFrame, uniform_textureSheet[3], uniform_textureSheet[4]);\n\tframe += bezierFrame;\n\tuv_0.xy += getSheetOffset(frame, uniform_textureSheet[0], uniform_textureSheet[1]);\n}\n",
particle_textureSheetTwoBezier: "\nvarying vec3 varying_textureSheetData;\nuniform float uniform_textureSheet[5];\nuniform float uniform_frameBezier1[35];\nuniform float uniform_frameBezier2[35];\nvec2 getSheetOffset(float frame, float tileX, float tileY)\n{\n\tframe = floor(frame);\n\tvec2 ret = vec2(0.0); \n\tret.x = (1.0 / tileX) * mod(frame, tileX); \n\tret.y = frame / tileX;\n\tret.y = floor(ret.y);\n\tret.y = (1.0 / tileY) * ret.y; \n\treturn ret;\n}\nvoid calcUVCoord() {\n\tvec2 rectUV = vec2(1.0 / uniform_textureSheet[0], 1.0 / uniform_textureSheet[1]);\n\tuv_0.xy *= rectUV;\n\t\n\tfloat frame = varying_textureSheetData.x + varying_textureSheetData.y;\n\tfloat currentTime = varying_particleData.x * uniform_textureSheet[2];\n\tcurrentTime = mod(currentTime, varying_particleData.y);\n\tfloat b1 = calcBezierSize(uniform_frameBezier1, currentTime2, varying_particleData.y);\n\tfloat b2 = calcBezierSize(uniform_frameBezier2, currentTime2, varying_particleData.y);\n\tfloat bezierFrame = mix(b1, b2, varying_particleData.z);\n\tbezierFrame = clamp(bezierFrame, uniform_textureSheet[3], uniform_textureSheet[4]);\n\tframe += bezierFrame;\n\tuv_0.xy += getSheetOffset(frame, uniform_textureSheet[0], uniform_textureSheet[1]);\n}\n",
particle_textureSheet_vs: "attribute vec3 attribute_textureSheetData;\nvarying vec3 varying_textureSheetData;\nvoid getNodeData(){\n\tvarying_textureSheetData = attribute_textureSheetData;\n}\n\t\n",
particle_trackPosition: "\nattribute vec3 attribute_trackPosition;\nvoid calcCubicPos(float time, float totalTime, vec3 fromPos, vec3 endPos){ \n \n\tvec3 distanceVec3 = endPos - fromPos; \n\tfloat distanceFloat = dot(distanceVec3, distanceVec3); \n\tdistanceFloat = sqrt(distanceFloat); \n\tfloat t = time / totalTime; \n\tt = easeInOut(t); \n\tvec3 centerPos = distanceVec3 * 0.5 + fromPos; \n\tvec3 zeroPos = vec3(0.0, distanceFloat * 0.05, 0.0); \n\tzeroPos = mix(centerPos, zeroPos, 0.6); \n\tvec3 bezier1 = mix(fromPos, zeroPos, t); \n\tvec3 bezier2 = mix(zeroPos, endPos, t); \n\tvec3 bezier3 = mix(bezier1, bezier2, t); \n\tcubicPos = bezier3 - fromPos; \n\tt = clamp(time / totalTime, 0.0, 1.0); \n\tif(t > 0.8){ \n\tt = (1.0 - t) * 5.0; \n\t}else if(t > 0.2){ \n\tt = 1.0; \n\t}else{ \n\tt *= 5.0; \n\t} \n\tt = 0.5 * (1.0 - cos(t * PI)); \n\tvec4 nrmVec4 = rotVertexMatrix * vec4(attribute_normal, 1.0); \n\tvec3 nrmPos = normalize(nrmVec4.xyz); \n\tnrmPos = nrmPos * t * distanceFloat * 0.04; \n\tt = clamp(time / totalTime, 0.0, 1.0); \n\tfloat heightOffset = 0.0; \n\theightOffset = sin(t * 3.0 * PI) * distanceFloat * 0.2 * sqrt(t * (1.0 - t)); \n\tcubicPos += nrmPos; \n\tcubicPos.y += heightOffset; \n}\nvoid trackPosition(){ \n \n\tcalcCubicPos(currentTime - 0.017, curParticle.life, attribute_offsetPosition, attribute_trackPosition); \n\tvec3 lastOffset = cubicPos; \n\tcalcCubicPos(currentTime, curParticle.life, attribute_offsetPosition, attribute_trackPosition); \n\tvec3 curOffset = cubicPos; \n\tvec3 trackVec3 = curOffset - lastOffset; \n\ttrackVec3 = normalize(trackVec3); \n\tfloat ratio = dot(localPosition.xyz, trackVec3); \n\tfloat t = clamp(currentTime / curParticle.life, 0.0, 1.0); \n\tt = 0.5 * (1.0 - cos(t * PI * 2.0)); \n\tt = sqrt(t); \n\tfloat speed = sqrt(dot(curOffset - lastOffset, curOffset - lastOffset)); \n\ttrackVec3 *= speed * 2.0 * t; \n\tlocalPosition.xyz += ratio * trackVec3; \n\tlocalPosition.xyz += curOffset; \n}\n",
particle_uv_roll_fs: "\nuniform float uniform_particleUVRoll[2];\nvoid calcUVCoord() {\n\tuv_0.xy += vec2(varying_particleData.x * uniform_particleUVRoll[0], varying_particleData.x * uniform_particleUVRoll[1]);\n}\n",
particle_velocity: "\nattribute vec3 attribute_velocity;\nvoid getNodeData(){\n\tvelocityBaseVec3 = attribute_velocity;\n}\n",
particle_velocityForceConst: "attribute vec3 attribute_velocityForceConst ;\nvoid getNodeData(){\n\tvelocityForceVec3 = 0.5 * attribute_velocityForceConst * currentTime * currentTime;\n}\n",
particle_velocityForceOneBezier: "\nvec3 velocityForceOneBezier = vec3(0.0);\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n}\nvoid main() {\n\tvelocityForceVec3.xyz = velocityForceOneBezier.xyz;\n\tcalcVelocityForceBezier(currentTime, curParticle.life);\n}\n",
particle_velocityForceOneBezierX: "\nuniform float uniform_velocityForceX[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceOneBezier.x = calcBezierArea(uniform_velocityForceX, curTime, totalTime);\n}\n",
particle_velocityForceOneBezierY: "\nuniform float uniform_velocityForceY[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceOneBezier.y = calcBezierArea(uniform_velocityForceY, curTime, totalTime);\n}\n",
particle_velocityForceOneBezierZ: "\nuniform float uniform_velocityForceZ[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceOneBezier.z = calcBezierArea(uniform_velocityForceZ, curTime, totalTime);\n}\n",
particle_velocityForceTwoBezier: "\nattribute float attribute_velocityForceRandomSeed;\nvec3 velocityForceTwoBezier1 = vec3(0.0);\nvec3 velocityForceTwoBezier2 = vec3(0.0);\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n}\nvoid main() {\n\tcalcVelocityForceBezier(currentTime, curParticle.life);\n\tvelocityForceVec3.x = mix(velocityForceTwoBezier1.x, velocityForceTwoBezier2.x, attribute_velocityForceRandomSeed);\n\tvelocityForceVec3.y = mix(velocityForceTwoBezier1.y, velocityForceTwoBezier2.y, attribute_velocityForceRandomSeed);\n\tvelocityForceVec3.z = mix(velocityForceTwoBezier1.z, velocityForceTwoBezier2.z, attribute_velocityForceRandomSeed);\n}\n",
particle_velocityForceTwoBezierX1: "\nuniform float uniform_velocityForceX1[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceTwoBezier1.x = calcBezierArea(uniform_velocityForceX1, curTime, totalTime);\n}\n",
particle_velocityForceTwoBezierX2: "\nuniform float uniform_velocityForceX2[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceTwoBezier2.x = calcBezierArea(uniform_velocityForceX2, curTime, totalTime);\n}\n",
particle_velocityForceTwoBezierY1: "\nuniform float uniform_velocityForceY1[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceTwoBezier1.y = calcBezierArea(uniform_velocityForceY1, curTime, totalTime);\n}\n",
particle_velocityForceTwoBezierY2: "\nuniform float uniform_velocityForceY2[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceTwoBezier2.y = calcBezierArea(uniform_velocityForceY2, curTime, totalTime);\n}\n",
particle_velocityForceTwoBezierZ1: "\nuniform float uniform_velocityForceZ1[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceTwoBezier1.z = calcBezierArea(uniform_velocityForceZ1, curTime, totalTime);\n}\n",
particle_velocityForceTwoBezierZ2: "\nuniform float uniform_velocityForceZ2[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceTwoBezier2.z = calcBezierArea(uniform_velocityForceZ2, curTime, totalTime);\n}\n",
particle_velocityLimitConst: "\nattribute float attribute_velocityLimit;\nvoid getNodeData(){\n\tvelocityLimitVec2.x = attribute_velocityLimit * currentTime;\n\tif(velocityLimitVec2.x < 0.0){\n\t\tvelocityLimitVec2.x = 0.0;\n\t}\n\tvelocityLimitVec2.y = 1.0;\n}\n",
particle_velocityLimitOneBezier: "\nuniform float uniform_velocityLimit[35];\nvoid main() {\n\tvelocityLimitVec2.x = calcBezierArea(uniform_velocityLimit, currentTime, curParticle.life);\n\tvelocityLimitVec2.y = 1.0;\n}\n",
particle_velocityLimitTwoBezier: "\nuniform float uniform_velocityLimit[35];\nuniform float uniform_velocityLimit2[35];\nattribute float attribute_velocityLimitRandomSeed;\nvoid main() {\n\tfloat velocity2Limit1 = calcBezierArea(uniform_velocityLimit, currentTime, curParticle.life);\n\tfloat velocity2Limit2 = calcBezierArea(uniform_velocityLimit2, currentTime, curParticle.life);\n\tvelocityLimitVec2.x = mix(velocity2Limit1, velocity2Limit1, attribute_velocityLimitRandomSeed);\n\tif(velocityLimitVec2.x < 0.0){\n\t\tvelocityLimitVec2.x = 0.0;\n\t}\n\tvelocityLimitVec2.y = 1.0;\n}\n",
particle_velocityOverConst: "\nattribute vec3 attribute_velocityOverConst;\nvoid getNodeData(){\n\tvelocityOverVec3 = attribute_velocityOverConst * currentTime;\n}\n",
particle_velocityOverOneBezier: "\nvec3 velocityTwoBezier = vec3(0.0);\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n}\nvoid main() {\n\tcalcVelocityOverBezier(currentTime, curParticle.life);\n\tvelocityOverVec3.xyz = velocityTwoBezier.xyz;\n}\n",
particle_velocityOverOneBezierX: "\nuniform float uniform_velocityOverX[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityTwoBezier.x = calcBezierArea(uniform_velocityOverX, curTime, totalTime);\n}\n",
particle_velocityOverOneBezierY: "\nuniform float uniform_velocityOverY[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityTwoBezier.y = calcBezierArea(uniform_velocityOverY, curTime, totalTime);\n}\n",
particle_velocityOverOneBezierZ: "\nuniform float uniform_velocityOverZ[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityTwoBezier.z = calcBezierArea(uniform_velocityOverZ, curTime, totalTime);\n}\n",
particle_velocityOverTwoBezier: "\nattribute float attribute_velocityOverRandomSeed;\nvec3 velocityOverTwoBezier1 = vec3(0.0);\nvec3 velocityOverTwoBezier2 = vec3(0.0);\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n}\nvoid main() {\n\tcalcVelocityOverBezier(currentTime, curParticle.life);\n\tvelocityOverVec3.x = mix(velocityOverTwoBezier1.x, velocityOverTwoBezier2.x, attribute_velocityOverRandomSeed);\n\tvelocityOverVec3.y = mix(velocityOverTwoBezier1.y, velocityOverTwoBezier2.y, attribute_velocityOverRandomSeed);\n\tvelocityOverVec3.z = mix(velocityOverTwoBezier1.z, velocityOverTwoBezier2.z, attribute_velocityOverRandomSeed);\n}\n",
particle_velocityOverTwoBezierX1: "\nuniform float uniform_velocityOverX1[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityOverTwoBezier1.x = calcBezierArea(uniform_velocityOverX1, curTime, totalTime);\n}\n",
particle_velocityOverTwoBezierX2: "\nuniform float uniform_velocityOverX2[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityOverTwoBezier2.x = calcBezierArea(uniform_velocityOverX2, curTime, totalTime);\n}\n",
particle_velocityOverTwoBezierY1: "\nuniform float uniform_velocityOverY1[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityOverTwoBezier1.y = calcBezierArea(uniform_velocityOverY1, curTime, totalTime);\n}\n",
particle_velocityOverTwoBezierY2: "\nuniform float uniform_velocityOverY2[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityOverTwoBezier2.y = calcBezierArea(uniform_velocityOverY2, curTime, totalTime);\n}\n",
particle_velocityOverTwoBezierZ1: "\nuniform float uniform_velocityOverZ1[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityOverTwoBezier1.z = calcBezierArea(uniform_velocityOverZ1, curTime, totalTime);\n}\n",
particle_velocityOverTwoBezierZ2: "\nuniform float uniform_velocityOverZ2[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityOverTwoBezier2.z = calcBezierArea(uniform_velocityOverZ2, curTime, totalTime);\n}\n",
particle_vs: "float currentTime = 0.0;\nfloat totalTime = 0.0;\nbool discard_particle = true;\nconst float PI = 3.1415926;\nconst float TrueOrFalse = 0.5;\nconst float Tiny = 0.0001;\nvarying vec4 varying_particleData;\nvarying vec4 varying_mvPose;\nattribute vec3 attribute_time;attribute vec4 attribute_color;\nattribute vec3 attribute_offsetPosition;\nattribute float attribute_rotationBirth;\nuniform mat4 uniform_cameraMatrix;\nuniform mat4 uniform_billboardMatrix;\nuniform mat4 uniform_ViewMatrix;\nuniform float uniform_particleState[27];\nvec3 cubicPos = vec3(1.0,1.0,1.0);\nvec3 rotResultVec3 = vec3(0.0);\nvec4 localPosition = vec4(0.0,0.0,0.0,1.0);\nvec3 velocityBaseVec3 = vec3(0.0,0.0,0.0);\nvec3 velocityOverVec3 = vec3(0.0,0.0,0.0);\nvec3 velocityForceVec3 = vec3(0.0,0.0,0.0);\nvec2 velocityBezierWeightVec2 = vec2(1.0, 1.0);\nvec2 velocityLimitVec2 = vec2(0.0,0.0);\nvec3 followTargetPosition = vec3(0.0,0.0,0.0);\nvec3 followTargetScale = vec3(1.0,1.0,1.0);\nvec4 followTargetRotation = vec4(0.0,0.0,0.0,0.0);\nfloat scaleSize = 1.0;\nconst float Billboard\t\t\t\t= 0.0;\nconst float StretchedBillboard\t\t= 1.0;\nconst float HorizontalBillboard\t\t= 2.0;\nconst float VerticalBillboard\t\t= 3.0;\nconst float Mesh\t\t\t\t\t= 4.0;\nstruct ParticleData{\n\tfloat bornTime;\tfloat life;\tfloat index;};                   \nParticleData curParticle;\nstruct ParticleStateData{\n\tfloat time;\t\t\t\t\t\t\n\tfloat loop;\t\t\t\t\t\t\n\tfloat worldSpace;\t\t\t\t\n\tfloat scaleX;\t\t\t\t\t\n\tfloat scaleY;\t\t\t\t\t\n\tfloat scaleZ;\t\t\t\t\t\n\tfloat rotationX;\t\t\t\t\n\tfloat rotationY;\t\t\t\t\n\tfloat rotationZ;\t\t\t\t\n\tfloat rotationW;\n\tfloat positionX;\t\t\t\t\n\tfloat positionY;\t\t\t\t\n\tfloat positionZ;\t\t\t\t\n\tfloat loopTime;\t\t\t\t\t\n\tfloat delay;\t\t\t\t\t\n\tfloat duration;\t\t\t\t\t\n\tfloat gravity;\t\t\t\t\t\n\tfloat velocityOverWorldSpace;\t\n\tfloat velocityForceWorldSpace;\t\n\tfloat velocityLimitDampen;\n\tfloat cameraScale;\n\tfloat speedScale;\n\tfloat lengthScale;\n\tfloat renderMode;\n\tfloat stayAtEnd;\n\tfloat blendMode;\n\tfloat shapeType;\n};\nParticleStateData particleStateData;\nmat4 buildRotMat4(vec3 rot)\n{\n\tfloat s;\n\tfloat c;\n\ts = sin(rot.x);\n\tc = cos(rot.x);\n\t\n\tmat4 ret = mat4(\n\tvec4(1.0, 0.0, 0.0, 0.0),\n\tvec4(0.0, c, s, 0.0),\n\tvec4(0.0, -s, c, 0.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n\t);\n\t\n\ts = sin(rot.y);\n\tc = cos(rot.y);\n\t\n\tret = mat4(\n\tvec4(c, 0.0, -s, 0.0),\n\tvec4(0.0, 1.0, 0.0, 0.0),\n\tvec4(s, 0.0, c, 0.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n\t) * ret;\n\ts = sin(rot.z);\n\tc = cos(rot.z);\n\tret = mat4(\n\tvec4(c, s, 0.0, 0.0),\n\tvec4(-s, c, 0.0, 0.0),\n\tvec4(0.0, 0.0, 1.0, 0.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n\t) * ret;\n\treturn ret;\n}\nmat4 buildMat4Quat(vec4 quat)\n{\n\tfloat xx = quat.x * quat.x;\n\tfloat xy = quat.x * quat.y;\n\tfloat xz = quat.x * quat.z;\n\tfloat xw = quat.x * quat.w;\n\tfloat yy = quat.y * quat.y;\n\tfloat yz = quat.y * quat.z;\n\tfloat yw = quat.y * quat.w;\n\tfloat zz = quat.z * quat.z;\n\tfloat zw = quat.z * quat.w;\n\treturn mat4(\n\t\t1.0 - 2.0 * (yy + zz),\t\t2.0 * (xy + zw),\t\t2.0 * (xz - yw),\t\t0,\n\t\t2.0 * (xy - zw),\t\t\t\t1.0 - 2.0 * (xx + zz),\t2.0 * (yz + xw),\t\t0,\n\t\t2.0 * (xz + yw),\t\t\t\t2.0 * (yz - xw),\t\t1.0 - 2.0 * (xx + yy),\t0,\n\t\t0.0,\t\t\t\t\t\t\t0.0,\t\t\t\t\t0.0,\t\t\t\t\t1\n\t);\n}\nfloat easeInOut(float t)\n{\n\tt = clamp(t, 0.0, 1.0);\n\tfloat p0;\n\tfloat p1;\n\tfloat p2;\n\tif(t <= 0.5){ \n\t\tp0 = 0.0; \n\t\tp1 = 0.0; \n\t\tp2 = 0.5; \n\t}else{ \n\t\tp0 = 0.5; \n\t\tp1 = 1.0; \n\t\tp2 = 1.0; \n\t\tt -= 0.5;\n\t}\n\tt *= 2.0;\n\t\n\tp0 = mix(p0, p1, t);\n\tp1 = mix(p1, p2, t);\n\t\n\tp0 = mix(p0, p1, t);\n\treturn p0;\n}\nvoid calcParticleTime()\n{\n\tdiscard_particle = true;\n\tcurParticle.bornTime = attribute_time.x; \n\tcurParticle.life = attribute_time.y; \n\tcurParticle.index = attribute_time.z; \n\tfloat time = particleStateData.time - particleStateData.delay;\n\tcurrentTime = time - curParticle.bornTime;\n\tif(currentTime <= 0.0){\n\t\treturn;\n\t}\n\tif(particleStateData.stayAtEnd > TrueOrFalse){\n\t\tif(currentTime >= curParticle.life){\n\t\t\tcurrentTime = curParticle.life * 0.99999;\n\t\t}\n\t}\n\tif(particleStateData.loop < TrueOrFalse){\n\t\tif(curParticle.bornTime >= particleStateData.duration){\n\t\t\treturn;\n\t\t}\n\t\tif(currentTime >= curParticle.life){\n\t\t\treturn;\n\t\t}\n\t\t\n\t}\n\tcurrentTime = mod(currentTime, particleStateData.loopTime);\n\tif(currentTime > curParticle.life || currentTime <= 0.0){\n\t\treturn;\n\t}\n\tdiscard_particle = false;\n}\nvoid calcCubicPos(float time, float totalTime, vec3 fromPos, vec3 endPos)\n{\n}\nvoid trackPosition()\n{\n}\nvoid getUnitRotate(){\n}\nvoid getNodeData(){\n}\nvoid rotateParticleUnit()\n{\n\trotResultVec3.z += attribute_rotationBirth; \n\trotResultVec3 *= PI / 180.0; \n\tif(particleStateData.renderMode == Mesh){\n\t\tif(particleStateData.shapeType > 0.5){ \n\t\t\trotResultVec3 = vec3(0.0, rotResultVec3.z, 0.0); \n\t\t\trotVertexMatrix = buildRotMat4(rotResultVec3); \n\t  }else{ \n\t\t  rotResultVec3 = vec3(0.0, 0.0, rotResultVec3.z); \n\t\t  rotVertexMatrix = buildRotMat4(rotResultVec3); \n\t  } \n\t}else if(particleStateData.renderMode == HorizontalBillboard){ \n\t\trotVertexMatrix = buildRotMat4(vec3(0.5 * PI, 0.0, 0.0)); \n\t\trotResultVec3 = vec3(0.0, rotResultVec3.z, 0.0); \n\t\trotVertexMatrix = buildRotMat4(rotResultVec3) * rotVertexMatrix; \n\t}else if(particleStateData.renderMode == StretchedBillboard){\n\t\trotResultVec3 = vec3(0.0, 0.0, -0.5 * PI); \n\t\trotVertexMatrix = buildRotMat4(rotResultVec3);\n\t}else{\n\t\trotVertexMatrix = buildRotMat4(rotResultVec3); \n\t} \n\t\n}\nvoid main(void) \n{\n\tlocalPosition = vec4(e_position, 1.0);\n\tparticleStateData.time\t\t\t\t\t\t\t= uniform_particleState[0];\n\tparticleStateData.loop\t\t\t\t\t\t\t= uniform_particleState[1];\n\tparticleStateData.worldSpace\t\t\t\t\t= uniform_particleState[2];\n\tparticleStateData.scaleX\t\t\t\t\t\t= uniform_particleState[3];\n\tparticleStateData.scaleY\t\t\t\t\t\t= uniform_particleState[4];\n\tparticleStateData.scaleZ\t\t\t\t\t\t= uniform_particleState[5];\n\tparticleStateData.rotationX\t\t\t\t\t\t= uniform_particleState[6];\n\tparticleStateData.rotationY\t\t\t\t\t\t= uniform_particleState[7];\n\tparticleStateData.rotationZ\t\t\t\t\t\t= uniform_particleState[8];\n\tparticleStateData.rotationW\t\t\t\t\t\t= uniform_particleState[9];\n\tparticleStateData.positionX\t\t\t\t\t\t= uniform_particleState[10];\n\tparticleStateData.positionY\t\t\t\t\t\t= uniform_particleState[11];\n\tparticleStateData.positionZ\t\t\t\t\t\t= uniform_particleState[12];\n\tparticleStateData.loopTime\t\t\t\t\t\t= uniform_particleState[13];\n\tparticleStateData.delay\t\t\t\t\t\t\t= uniform_particleState[14];\n\tparticleStateData.duration\t\t\t\t\t\t= uniform_particleState[15];\n\tparticleStateData.gravity\t\t\t\t\t\t= uniform_particleState[16];\n\tparticleStateData.velocityOverWorldSpace\t\t= uniform_particleState[17];\n\tparticleStateData.velocityForceWorldSpace\t\t= uniform_particleState[18];\n\tparticleStateData.velocityLimitDampen\t\t\t= uniform_particleState[19];\n\tparticleStateData.cameraScale\t\t\t\t\t= uniform_particleState[20];\n\tparticleStateData.speedScale\t\t\t\t\t= uniform_particleState[21];\n\tparticleStateData.lengthScale\t\t\t\t\t= uniform_particleState[22];\n\tparticleStateData.renderMode\t\t\t\t\t= uniform_particleState[23];\n\tparticleStateData.stayAtEnd\t\t\t\t\t\t= uniform_particleState[24];\n\tparticleStateData.blendMode\t\t\t\t\t\t= uniform_particleState[25];\n\tparticleStateData.shapeType\t\t\t\t\t\t= uniform_particleState[26];\n\t\n\tcalcParticleTime();\n\tvarying_particleData.x = currentTime;\n\tvarying_particleData.y = curParticle.life;\n\tvarying_particleData.z = curParticle.index;\n\tvarying_particleData.w = particleStateData.blendMode;\n\tif(discard_particle){\n\t\tvarying_particleData.x = currentTime = 0.0;\n\t\tgl_Position = varying_pos = vec4(0.0, 0.0, 0.0, 1.0);\n\t\treturn;\n\t}\n\tgetNodeData();\n\tgetUnitRotate();\n\trotateParticleUnit();\n}\n",
pointLight_fragment: "const int max_pointLight = 0 ;\nuniform float uniform_pointLightSource[12*max_pointLight] ;\nvarying vec4 varying_mvPose; \nstruct PointLight{\n        vec3 position ;\n        vec3 diffuse ;\n        vec3 ambient ;\n        float intensity;\n        float radius;\n        float cutoff;\n};\nvoid calculatePointLight(MaterialSource materialSource){\n    vec3 N = normal; \n\tvec3 viewDir = normalize(varying_mvPose.xyz/varying_mvPose.w); \n\tfor(int i = 0 ; i < max_pointLight ; i++){\n\t\tPointLight pointLight;\n\t\tpointLight.position = vec3(uniform_pointLightSource[i*12],uniform_pointLightSource[i*12+1],uniform_pointLightSource[i*12+2]);\n\t\tpointLight.diffuse = vec3(uniform_pointLightSource[i*12+3],uniform_pointLightSource[i*12+4],uniform_pointLightSource[i*12+5]);\n\t\tpointLight.ambient = vec3(uniform_pointLightSource[i*12+6],uniform_pointLightSource[i*12+7],uniform_pointLightSource[i*12+8]);\n\t    pointLight.intensity = uniform_pointLightSource[i*12+9];\n\t    pointLight.radius = uniform_pointLightSource[i*12+10];\n\t    pointLight.cutoff = uniform_pointLightSource[i*12+11];\n\t\t\n\t\tvec3 lightCentre = (mat4(uniform_ViewMatrix) * vec4(pointLight.position.xyz,1.0) ).xyz ; \n\t\tfloat r = pointLight.radius * 0.5 ;\n\t\tvec3 ldir = varying_mvPose.xyz - lightCentre ;\n\t\tfloat distance = length(ldir);\n\t\tfloat d = max(distance - r, 0.0);\n\t\tvec3 L = ldir / distance;\n\t\t\n\t\tfloat denom = d/r + 1.0;\n\t\tfloat attenuation = 1.0 / (denom*denom);\n\t\t\n\t\tfloat cutoff = pointLight.cutoff ;\n\t\tattenuation = (attenuation - cutoff) / (1.0 - cutoff);\n\t\tattenuation = max(attenuation*pointLight.intensity, 0.0);\n\t\tLightingBlinnPhong(normalize(ldir),pointLight.diffuse,pointLight.ambient,N,(viewDir),attenuation); \n\t};\n}\nvoid main() {\n   calculatePointLight(materialSource);\n}\n",
positionEndPass_fs: "varying vec4 varying_position ;\nvoid main(){\n     outColor = vec4(varying_position.xyz,1.0);\n}",
positionEndPass_vs: "varying vec4 varying_position ;\nvoid main(){\n\t\toutPosition = uniform_ProjectionMatrix * outPosition ; \n\t\tvarying_position = outPosition.xyzw; \n}",
rimlight_fs: "uniform float uniform_rimData[6] ;\nvoid main(){\n    float rim = 1.0 - clamp(dot (vec3(0.0,0.0,1.0), normal ) ,0.0,1.0);  \n    vec3 emission = vec3(uniform_rimData[0],uniform_rimData[1],uniform_rimData[2]) * pow(rim, uniform_rimData[4]);  \n    outColor.xyz += emission * uniform_rimData[3] * uniform_rimData[5] ;\n}",
secondaryUV_vs: "attribute vec2 attribute_uv1;\nvarying vec2 varying_uv1 ;\nvoid main(void){\n\tvarying_uv1 = attribute_uv1 ; \n}",
shadowMapping_fs: "uniform sampler2D shadowMapTexture;\nuniform vec4 uniform_ShadowColor;\nvarying vec4 varying_ShadowCoord;\nfloat unpackDepth(vec4 rgbaDepth){\n    vec4 bitShift = vec4( 1.0 , 1.0/256.0 , 1.0/(256.0*256.0) , 1.0/(256.0*256.0*256.0) );\n    float depth = dot(rgbaDepth,bitShift);\n    return depth ;\n}\nvoid main() {\n\tvec3 shadowColor = vec3(1.0,1.0,1.0); \n\tfloat offset = uniform_ShadowColor.w; \n\tvec2 sample = varying_ShadowCoord.xy / varying_ShadowCoord.w * 0.5 + 0.5; \n\tif (sample.x >=0.0 && sample.x <= 1.0 && sample.y >=0.0 && sample.y <= 1.0) {\n\t\tvec4 sampleDepth = texture2D(shadowMapTexture, sample).xyzw; \n\t\tfloat depth = varying_ShadowCoord.z;\n\t\n\t\tif (sampleDepth.z != 0.0) {\n\t\t\tif( sampleDepth.z < depth - offset) { \n\t\t\t\tshadowColor = uniform_ShadowColor.xyz; \n\t\t\t}\n\t\t}\n\t}\n\toutColor.xyz = outColor.xyz * shadowColor; \n}\n",
shadowMapping_vs: "uniform mat4 uniform_ShadowMatrix;\nuniform mat4 uniform_ModelMatrix;\nvarying vec4 varying_ShadowCoord;\nvoid main() {\n\tvarying_ShadowCoord = uniform_ShadowMatrix * uniform_ModelMatrix * vec4(e_position, 1.0);\n}",
shadowPass_fs: "uniform sampler2D diffuseTexture;\nvec4 diffuseColor ;\nvarying vec2 varying_uv0;\nvarying vec4 varying_color;\nvarying vec4 varying_pos;\nfloat unpackDepth(vec4 rgbaDepth){\n    vec4 bitShift = vec4( 1.0 , 1.0/256.0 , 1.0/(256.0*256.0) , 1.0/(256.0*256.0*256.0) );\n    float depth = dot(rgbaDepth,bitShift);\n    return depth ;\n}\nvoid main() {\n\tdiffuseColor = varying_color ;\n    if( diffuseColor.w == 0.0 ){\n\t\tdiscard;\n\t}\n\tdiffuseColor = texture2D(diffuseTexture , varying_uv0 );\n    if( diffuseColor.w <= 0.3 ){\n\t\t\tdiscard;\n\t}\n    gl_FragColor = vec4(varying_pos.zzz, 1.0);\n}\n",
shadowPass_skeleton_vs: "attribute vec3 attribute_position;\nattribute vec3 attribute_normal;\nattribute vec4 attribute_color;\nattribute vec2 attribute_uv0;\nattribute vec4 attribute_boneIndex;\nattribute vec4 attribute_boneWeight;\nuniform mat4 uniform_ModelMatrix ;\nuniform mat4 uniform_ViewMatrix ;\nuniform mat4 uniform_ProjectionMatrix ;\nvec3 e_position = vec3(0.0, 0.0, 0.0);\nvec4 e_boneIndex = vec4(0.0, 0.0, 0.0, 0.0);\nvec4 e_boneWeight = vec4(0.0, 0.0, 0.0, 0.0);\nvec4 outPosition = vec4(0.0, 0.0, 0.0, 0.0);\nconst int bonesNumber = 0;\nuniform vec4 uniform_PoseMatrix[bonesNumber];\nvarying vec2 varying_uv0;\nvarying vec4 varying_color;\nvarying vec4 varying_pos;\nmat4 buildMat4(int index){\n  vec4 quat = uniform_PoseMatrix[index * 2 + 0];\n  vec4 translation = uniform_PoseMatrix[index * 2 + 1];\n  float xy2 = 2.0 * quat.x * quat.y;\n  float xz2 = 2.0 * quat.x * quat.z;\n  float xw2 = 2.0 * quat.x * quat.w;\n  float yz2 = 2.0 * quat.y * quat.z;\n  float yw2 = 2.0 * quat.y * quat.w;\n  float zw2 = 2.0 * quat.z * quat.w;\n  float xx = quat.x * quat.x;\n  float yy = quat.y * quat.y;\n  float zz = quat.z * quat.z;\n  float ww = quat.w * quat.w;\n  mat4 matrix = mat4(\n\t   xx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0,\n\t   xy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0,\n\t   xz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0,\n\t   translation.x, translation.y, translation.z, 1\n   );\n   return matrix;\n}\nvoid main(void){\n\te_boneIndex = attribute_boneIndex;\n\te_boneWeight = attribute_boneWeight;\n\tvec4 temp_position = vec4(attribute_position, 1.0) ;\n\tmat4 m0 = buildMat4(int(e_boneIndex.x));\n\tmat4 m1 = buildMat4(int(e_boneIndex.y));\n\tmat4 m2 = buildMat4(int(e_boneIndex.z));\n\tmat4 m3 = buildMat4(int(e_boneIndex.w));\n\toutPosition = m0 * temp_position * e_boneWeight.x;\n\toutPosition += m1 * temp_position * e_boneWeight.y;\n\toutPosition += m2 * temp_position * e_boneWeight.z;\n\toutPosition += m3 * temp_position * e_boneWeight.w;\n\te_position = outPosition.xyz;\n\t\n    mat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n    \n\tvarying_color = attribute_color; \n\tvarying_uv0 = attribute_uv0 ;\n\tvarying_pos = uniform_ProjectionMatrix * uniform_ViewMatrix * uniform_ModelMatrix * vec4(e_position, 1.0);\n\tgl_Position = varying_pos;\n}",
shadowPass_vs: "attribute vec3 attribute_position;\nattribute vec4 attribute_color;\nattribute vec2 attribute_uv0;\nuniform mat4 uniform_ModelMatrix ;\nuniform mat4 uniform_ViewMatrix ;\nuniform mat4 uniform_ProjectionMatrix ;\nvarying vec2 varying_uv0;\nvarying vec4 varying_color;\nvarying vec4 varying_pos;\nvoid main(void){\n\tmat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n\tvarying_color = attribute_color; \n\tvarying_uv0 = attribute_uv0 ;\n\tvarying_pos = uniform_ProjectionMatrix * uniform_ViewMatrix * uniform_ModelMatrix * vec4(attribute_position, 1.0);\n\tgl_Position = varying_pos;\n}",
skeletonShadowPass_vs: "attribute vec4 attribute_boneIndex;\nattribute vec4 attribute_boneWeight;\nattribute vec4 attribute_color;\nvec4 e_boneIndex = vec4(0.0, 0.0, 0.0, 0.0);\nvec4 e_boneWeight = vec4(0.0, 0.0, 0.0, 0.0);\nconst int bonesNumber = 0;\nuniform vec4 uniform_PoseMatrix[bonesNumber];\nmat4 buildMat4(int index){\n  vec4 quat = uniform_PoseMatrix[index * 2 + 0];\n  vec4 translation = uniform_PoseMatrix[index * 2 + 1];\n  float xx = quat.x * quat.x;\n  float xy = quat.x * quat.y;\n  float xz = quat.x * quat.z;\n  float xw = quat.x * quat.w;\n  float yy = quat.y * quat.y;\n  float yz = quat.y * quat.z;\n  float yw = quat.y * quat.w;\n  float zz = quat.z * quat.z;\n  float zw = quat.z * quat.w;\n   return mat4(\n\t   1.0 - 2.0 * (yy + zz),\t\t2.0 * (xy + zw),\t\t2.0 * (xz - yw),\t\t0,\n\t   2.0 * (xy - zw),\t\t\t\t1.0 - 2.0 * (xx + zz),\t2.0 * (yz + xw),\t\t0,\n\t   2.0 * (xz + yw),\t\t\t\t2.0 * (yz - xw),\t\t1.0 - 2.0 * (xx + yy),\t0,\n\t   translation.x,\t\t\t\ttranslation.y,\t\t\ttranslation.z,\t\t\t1\n   );\n}\nvoid main(void){\n\tvarying_color = attribute_color; \n\te_boneIndex = attribute_boneIndex;\n\te_boneWeight = attribute_boneWeight;\n\tvec4 temp_position = vec4(attribute_position, 1.0) ;\n\tmat4 m0 = buildMat4(int(e_boneIndex.x));\n\tmat4 m1 = buildMat4(int(e_boneIndex.y));\n\tmat4 m2 = buildMat4(int(e_boneIndex.z));\n\tmat4 m3 = buildMat4(int(e_boneIndex.w));\n\toutPosition = m0 * temp_position * e_boneWeight.x;\n\toutPosition += m1 * temp_position * e_boneWeight.y;\n\toutPosition += m2 * temp_position * e_boneWeight.z;\n\toutPosition += m3 * temp_position * e_boneWeight.w;\n\t\n\te_position = outPosition.xyz;\n\toutPosition = uniform_ModelMatrix * uniform_ViewMatrix *  outPosition; \n    \n}",
skeleton_vs: "attribute vec4 attribute_boneIndex;\nattribute vec4 attribute_boneWeight;\nattribute vec3 attribute_normal;\nattribute vec4 attribute_color;\nvec4 e_boneIndex = vec4(0.0, 0.0, 0.0, 0.0);\nvec4 e_boneWeight = vec4(0.0, 0.0, 0.0, 0.0);\nconst int bonesNumber = 0;\nuniform vec4 uniform_PoseMatrix[bonesNumber];\nvarying vec4 varying_mvPose  ;\nmat4 buildMat4(int index){\n  vec4 quat = uniform_PoseMatrix[index * 2 + 0];\n  vec4 translation = uniform_PoseMatrix[index * 2 + 1];\n  float xy2 = 2.0 * quat.x * quat.y;\n  float xz2 = 2.0 * quat.x * quat.z;\n  float xw2 = 2.0 * quat.x * quat.w;\n  float yz2 = 2.0 * quat.y * quat.z;\n  float yw2 = 2.0 * quat.y * quat.w;\n  float zw2 = 2.0 * quat.z * quat.w;\n  float xx = quat.x * quat.x;\n  float yy = quat.y * quat.y;\n  float zz = quat.z * quat.z;\n  float ww = quat.w * quat.w;\n  mat4 matrix = mat4(\n\t   xx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0,\n\t   xy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0,\n\t   xz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0,\n\t   translation.x, translation.y, translation.z, 1\n   );\n   return matrix;\n}\nvoid main(void){\n\te_boneIndex = attribute_boneIndex;\n\te_boneWeight = attribute_boneWeight;\n\tvec4 temp_position = vec4(attribute_position, 1.0) ;\n\tvec4 temp_normal = vec4(attribute_normal, 0.0) ;\n\tmat4 m0 = buildMat4(int(e_boneIndex.x));\n\tmat4 m1 = buildMat4(int(e_boneIndex.y));\n\tmat4 m2 = buildMat4(int(e_boneIndex.z));\n\tmat4 m3 = buildMat4(int(e_boneIndex.w));\n\toutPosition = m0 * temp_position * e_boneWeight.x;\n\toutPosition += m1 * temp_position * e_boneWeight.y;\n\toutPosition += m2 * temp_position * e_boneWeight.z;\n\toutPosition += m3 * temp_position * e_boneWeight.w;\n\te_position = outPosition.xyz;\n\tvec4 temp_n ;\n\ttemp_n  = m0 * temp_normal * e_boneWeight.x;\n\ttemp_n += m1 * temp_normal * e_boneWeight.y;\n\ttemp_n += m2 * temp_normal * e_boneWeight.z;\n\ttemp_n += m3 * temp_normal * e_boneWeight.w;\n\t\n    mat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n    varying_mvPose = mvMatrix * vec4( e_position , 1.0 ) ; \n    \n    mat4 normalMatrix = inverse(mvMatrix) ;\n    normalMatrix = transpose(normalMatrix); \n    \n    varying_eyeNormal = mat3(normalMatrix) * -temp_n.xyz ; \n    \n    outPosition.xyzw = varying_mvPose.xyzw ; \n    varying_color = attribute_color; \n}",
specularMap_fragment: "uniform sampler2D specularTexture;\nvoid main(void){\n   \ts.Specular = texture2D(specularTexture, uv_0).xyzx ;\n}\n",
sportLight: "lightingInfo computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec3 diffuseColor, vec3 specularColor, float range, float roughness, float NdotV) {\n    lightingInfo result;\n    vec3 direction = lightData.xyz - vPositionW;\n    vec3 lightVectorW = normalize(direction);\n    float attenuation = max(0., 1.0 - length(direction) / range);\n    float cosAngle = max(0.0000001, dot(-lightDirection.xyz, lightVectorW));\n    float spotAtten = 0.0;\n    if (cosAngle >= lightDirection.w)\n    {\n        cosAngle = max(0., pow(cosAngle, lightData.w));\n        spotAtten = clamp((cosAngle - lightDirection.w) / (1. - cosAngle), 0.0, 1.0);\n        vec3 H = normalize(viewDirectionW - lightDirection.xyz);\n        float NdotL = max(0.00000000001, dot(vNormal, -lightDirection.xyz));\n        float VdotH = clamp(dot(viewDirectionW, H), 0.00000000001, 1.0);\n        float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\n        result.diffuse = diffuseTerm * diffuseColor * attenuation * spotAtten;\n#ifdef SPECULARTERM\n        float NdotH = max(0.00000000001, dot(vNormal, H));\n        vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor);\n        result.specular = specTerm  * attenuation * spotAtten;\n#endif\n        return result;\n    }\n    result.diffuse = vec3(0.);\n#ifdef SPECULARTERM\n    result.specular = vec3(0.);\n#endif\n    return result;\n}",
tangent_vs: "attribute vec3 attribute_tangent;\nvoid main(void){\n} ",
terrainRGBA_fragment: "uniform sampler2D blendMaskTexture ;\nuniform sampler2D splat_0Tex ;\nuniform sampler2D splat_1Tex ;\nuniform sampler2D splat_2Tex ;\nuniform sampler2D splat_3Tex ;\nuniform float uvs[8];\nvoid main() {\n\tmaterialSource.refraction = 3.0 ;\n\tvec4 splat_control = texture2D ( blendMaskTexture , varying_uv0 );\n\tvec4 cc = vec4(0.0,0.0,0.0,1.0);\n\tvec2 uv = varying_uv0 ;\n\tcc.xyz = splat_control.x * texture2D (splat_0Tex, uv * vec2(uvs[0],uvs[1])).xyz ;\n\tcc.xyz += splat_control.y * texture2D (splat_1Tex, uv * vec2(uvs[2],uvs[3]) ).xyz;\n\tcc.xyz += splat_control.z * vec4(texture2D (splat_2Tex, uv* vec2(uvs[4],uvs[5]))).xyz;\n\tcc.xyz += (1.0-splat_control.w) * vec4(texture2D (splat_3Tex, uv* vec2(uvs[6],uvs[7]))).xyz; \n\ts.Albedo.xyz = cc.xyz ; \n\toutColor.xyz = s.Albedo.xyz;\n\toutColor.w = 1.0;\n}\n",
uvRoll_fs: "uniform float uvRoll[2] ;\nuniform sampler2D diffuseTexture;\nvec4 diffuseColor ;\nvoid main() {\n    uv_0.xy += vec2(uvRoll[0],uvRoll[1]);\n\tdiffuseColor = texture2D(diffuseTexture , uv_0 );\n}",
uvSpriteSheet_fs: "uniform float uvSpriteSheet[4] ;\nuniform sampler2D diffuseTexture;\nvec4 diffuseColor ;\nvoid main() {\n    uv_0.xy *= vec2(uvSpriteSheet[2],uvSpriteSheet[3]);\n    uv_0.xy += vec2(uvSpriteSheet[0],uvSpriteSheet[1]);\n\tdiffuseColor = texture2D(diffuseTexture , uv_0 );\n}",
uvStreamerRoll_fs: "uniform float uvRoll[3] ;\nuniform sampler2D diffuseTexture;\nuniform sampler2D streamerTexture;\nvec4 diffuseColor ;\nvoid main() {\n    \n\tdiffuseColor = texture2D(diffuseTexture , varying_uv0 );\n    \n    vec2 rollUV = varying_uv0 + vec2(uvRoll[0],uvRoll[1]) + vec2(normal.xz) * 0.5 ;\n\tdiffuseColor.xyz += texture2D(streamerTexture , rollUV ).xyz * uvRoll[2] ;\n    \n}",
varyingViewDir_vs: "varying vec3 varying_ViewDir; \nuniform vec3 uniform_eyepos; \nvoid main(void){ \n    varying_ViewDir = (uniform_eyepos.xyz - e_position) ; \n}",
vertexPos_vs: "uniform mat4 uniform_ModelMatrix;\nuniform mat4 uniform_ViewMatrix;\nvarying vec4 varying_mvPose;\nvoid main() {\n       varying_mvPose = uniform_ViewMatrix * uniform_ModelMatrix * vec4(e_position, 1.0) ; \n}\n                      ",
waterBump_fs: "uniform vec2 waterNormalData[4];\nuniform vec4 horizonColor;\nuniform float time ;\nuniform sampler2D bumpTexture;\nuniform sampler2D colorControlTexture;\nvarying vec2 varying_uv0        ;\nvarying vec2 varying_uv0        ;\nvec4 UnpackNormal( vec4 nT ){\n    vec4 t ;\n    t.xyzw = nT.xyzw * 2.0 - 1.0 ;\n    return t ;\n}\nmat3 TBN ;\nmat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) {\n    vec3 dp1 = dFdx(p);\n    vec3 dp2 = dFdy(p);\n    vec2 duv1 = dFdx(uv);\n    vec2 duv2 = dFdy(uv);\n    vec3 dp2perp = cross(dp2, N);\n    vec3 dp1perp = cross(N, dp1);\n    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n    float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));\n    return mat3(T * invmax, B * invmax, N);\n}\nvoid main(void){\n    float tempTime = mod(time,10000000.0); \n    vec2 uvA = uv_0 * waterNormalData[3].x + waterNormalData[0] * tempTime ; \n    vec2 uvB = uv_0 * waterNormalData[3].y + waterNormalData[1] * tempTime  ; \n    TBN = cotangentFrame(normal,varying_mvPose.xyz, varying_uv0) ;\n    vec3 viewDir = normalize(varying_mvPose.xyz/varying_mvPose.w) ;\n    vec3 bump1 = UnpackNormal(texture2D( bumpTexture, uvA )).rgb;\n\tvec3 bump2 = UnpackNormal(texture2D( bumpTexture, uvB )).rgb;\n\tvec3 bump = (bump1 + bump2) * 0.5;\n    normal = TBN * bump ;\n\t\n\tfloat fresnel = dot( viewDir, bump );\n\tvec4 water = texture2D( colorControlTexture, vec2(fresnel,fresnel) );\n\t\n\tvec4 col;\n\tdiffuseColor.rgb = mix( water.rgb, horizonColor.rgb, water.a );\n\tdiffuseColor.a = horizonColor.a;\n}",
waterDiffuse_fs: "uniform sampler2D diffuseTexture;\nvec4 diffuseColor ;\nvoid main() {\n\t\t\tdiffuseColor.xyz *= diffuseColor.w ;\n}\n",
waterNormal_fs: "uniform vec2 waterNormalData[4];\nuniform float time ;\nuniform sampler2D normalTextureA;\nuniform sampler2D normalTextureB;\nvarying vec4 varying_mvPose;\nvarying vec2 varying_uv0;\nmat3 TBN ;\nmat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) {\n    vec3 dp1 = dFdx(p);\n    vec3 dp2 = dFdy(p);\n    vec2 duv1 = dFdx(uv);\n    vec2 duv2 = dFdy(uv);\n    vec3 dp2perp = cross(dp2, N);\n    vec3 dp1perp = cross(N, dp1);\n    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n    float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));\n    return mat3(T * invmax, B * invmax, N);\n}\nvec3 tbn(vec3 map, vec3 N, vec3 V, vec2 texcoord) {\n    mat3 TBN = cotangentFrame(N, -V, texcoord);\n    return normalize(TBN * map);\n}\nvoid main(void){\n    TBN = cotangentFrame(normal,varying_mvPose.xyz, varying_uv0) ;\n    float tempTime = mod(time,100000.0); \n    vec2 uvA = uv_0 * waterNormalData[3].x + waterNormalData[0] * tempTime ; \n    vec2 uvB = uv_0 * waterNormalData[3].y + waterNormalData[1] * tempTime  ; \n    vec3 bump1 = texture2D( normalTextureA, uvA ).rgb * 2.0-1.0 ; \n    bump1.y *= -1.0;\n    bump1.xyz = TBN * bump1 ; \n    normal.xyz = bump1.xyz ;\n    \n    vec3 bump2 = texture2D( normalTextureB, uvB ).rgb * 2.0-1.0 ; \n    bump2.y *= -1.0;\n    bump2.xyz = TBN * bump2 ; \n    normal.xyz = (normal.xyz + bump2.xyz)*0.5 ;\n    \n} ",
wave_fs: "uniform sampler2D diffuseTexture;\nuniform vec3 uniform_eyepos; \nuniform vec4 waveFSData[2]; \nvarying vec4 varying_mvPose;\nvec4 diffuseColor ;\nvoid main(void){\n    vec3 viewDir = normalize(varying_mvPose.xyz/varying_mvPose.w); \n    diffuseColor.xyz = vec3(1.0,1.0,1.0) ; \n    vec3 shallowWaterColor = waveFSData[0].xyz * waveFSData[0].w ;\n    vec3 deepWaterColor = waveFSData[1].xyz * waveFSData[1].w;\n    float facing = clamp(dot( -normalize(viewDir),normal),0.0,1.0);\n    vec3 waterColor = mix(shallowWaterColor,deepWaterColor,facing);\n    diffuseColor.xyz *= waterColor ;\n} ",
wave_vs: "#define VERTEX_TEXTURES\nattribute vec3 attribute_normal;\nattribute vec4 attribute_color;\nuniform mat4 uniform_ModelMatrix;\nuniform mat4 uniform_ViewMatrix;\nvarying vec4 varying_mvPose;\nuniform vec3 waveVSData[4];\nuniform float time ;\nstruct wave{\n    vec3 wave_xyz_intensity_0 ;\n    vec3 wave_xyz_intensity_1 ;\n    vec3 wave_xyz_speed_0 ;\n    vec3 wave_xyz_speed_1 ;\n};\nconst float pi = 3.14 ;\nvec3 calcWave2( float t , vec3 x, float amplitude, float waveLength ,float angularVelocity ,  vec3 waveDir ){\n  \n   angularVelocity = angularVelocity * 0.1;\n   vec3 waveVector = waveDir ;\n   float waveNumber = pi / waveLength;\n   waveVector *= waveNumber ;\n  \n  vec3 temp ; \n   float kDotX0SubWt = dot(waveVector , x ) - angularVelocity * t  * 0.001;\n   float A = amplitude * sin(kDotX0SubWt) ;\n   temp.xz = waveDir.xz * A ;\n   temp.y += amplitude * cos(kDotX0SubWt);\n   temp = x - temp ;\n   return temp ;\n}\nvoid main(void){\n   wave wa ; \n    wa.wave_xyz_intensity_0 = vec3(waveVSData[0]) ; \n    wa.wave_xyz_intensity_1 = vec3(waveVSData[1]) ; \n    wa.wave_xyz_speed_0 = vec3(waveVSData[2]) ; \n    wa.wave_xyz_speed_1 = vec3(waveVSData[3]) ; \n    \n    float tempTime = mod( time , 1000000.0 ); \n\tvec3 newPose1 = calcWave2(tempTime,e_position,40.0, 20.0, 10.0,vec3(1.0,0.0,1.0)); \n\tnewPose1 += calcWave2(tempTime,e_position,20.0, 10.0, 10.0,vec3(1.0,0.0,-0.5)); \n\tnewPose1 += calcWave2(tempTime,e_position,1.0, 1.0, 10.0,vec3(1.0,0.0,-1.5)); \n    e_position = newPose1 ; \n    \n    mat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n    \n    varying_mvPose = mvMatrix * vec4( e_position , 1.0 )  ; \n    \n    mat4 normalMatrix = inverse(mvMatrix) ;\n    normalMatrix = transpose(normalMatrix); \n    \n    varying_eyeNormal = mat3(normalMatrix) * -attribute_normal ; \n    \n    outPosition = varying_mvPose ; \n    varying_color = attribute_color; \n} ",
};}}
