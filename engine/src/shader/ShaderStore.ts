module egret3d {/*** @private*/export class ShaderStore {static lib: { [key:string]: string } = {
anaglyph_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D leftSampler;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 leftFrag = texture2D(leftSampler, vUV);\r\n    leftFrag = vec4(1.0, leftFrag.g, leftFrag.b, 1.0);\r\n\r\n\tvec4 rightFrag = texture2D(textureSampler, vUV);\r\n    rightFrag = vec4(rightFrag.r, 1.0, 1.0, 1.0);\r\n\r\n    gl_FragColor = vec4(rightFrag.rgb * leftFrag.rgb, 1.0);\r\n}",
blackAndWhite_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\nvoid main(void) \r\n{\r\n\tfloat luminance = dot(texture2D(textureSampler, vUV).rgb, vec3(0.3, 0.59, 0.11));\r\n\tgl_FragColor = vec4(luminance, luminance, luminance, 1.0);\r\n}",
blur_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\n// Parameters\r\nuniform vec2 screenSize;\r\nuniform vec2 direction;\r\nuniform float blurWidth;\r\n\r\nvoid main(void)\r\n{\r\n\tfloat weights[7];\r\n\tweights[0] = 0.05;\r\n\tweights[1] = 0.1;\r\n\tweights[2] = 0.2;\r\n\tweights[3] = 0.3;\r\n\tweights[4] = 0.2;\r\n\tweights[5] = 0.1;\r\n\tweights[6] = 0.05;\r\n\r\n\tvec2 texelSize = vec2(1.0 / screenSize.x, 1.0 / screenSize.y);\r\n\tvec2 texelStep = texelSize * direction * blurWidth;\r\n\tvec2 start = vUV - 3.0 * texelStep;\r\n\r\n\tvec4 baseColor = vec4(0., 0., 0., 0.);\r\n\tvec2 texelOffset = vec2(0., 0.);\r\n\r\n\tfor (int i = 0; i < 7; i++)\r\n\t{\r\n\t\tbaseColor += texture2D(textureSampler, start + texelOffset) * weights[i];\r\n\t\ttexelOffset += texelStep;\r\n\t}\r\n\r\n\tgl_FragColor = baseColor;\r\n}",
chromaticAberration_fragment: "// samplers\r\nuniform sampler2D textureSampler;\t// original color\r\n\r\n// uniforms\r\nuniform float chromatic_aberration;\r\nuniform float screen_width;\r\nuniform float screen_height;\r\n\r\n// varyings\r\nvarying vec2 vUV;\r\n\r\nvoid main(void)\r\n{\r\n\tvec2 centered_screen_pos = vec2(vUV.x - 0.5, vUV.y - 0.5);\r\n\tfloat radius2 = centered_screen_pos.x*centered_screen_pos.x\r\n\t\t+ centered_screen_pos.y*centered_screen_pos.y;\r\n\tfloat radius = sqrt(radius2);\r\n\r\n\tvec4 original = texture2D(textureSampler, vUV);\r\n\r\n\tif (chromatic_aberration > 0.0) {\r\n\t\t//index of refraction of each color channel, causing chromatic dispersion\r\n\t\tvec3 ref_indices = vec3(-0.3, 0.0, 0.3);\r\n\t\tfloat ref_shiftX = chromatic_aberration * radius * 17.0 / screen_width;\r\n\t\tfloat ref_shiftY = chromatic_aberration * radius * 17.0 / screen_height;\r\n\r\n\t\t// shifts for red, green & blue\r\n\t\tvec2 ref_coords_r = vec2(vUV.x + ref_indices.r*ref_shiftX, vUV.y + ref_indices.r*ref_shiftY*0.5);\r\n\t\tvec2 ref_coords_g = vec2(vUV.x + ref_indices.g*ref_shiftX, vUV.y + ref_indices.g*ref_shiftY*0.5);\r\n\t\tvec2 ref_coords_b = vec2(vUV.x + ref_indices.b*ref_shiftX, vUV.y + ref_indices.b*ref_shiftY*0.5);\r\n\r\n\t\toriginal.r = texture2D(textureSampler, ref_coords_r).r;\r\n\t\toriginal.g = texture2D(textureSampler, ref_coords_g).g;\r\n\t\toriginal.b = texture2D(textureSampler, ref_coords_b).b;\r\n\t}\r\n\r\n\tgl_FragColor = original;\r\n}",
colorCorrection_fragment: "﻿// samplers\r\nuniform sampler2D textureSampler;\t// screen render\r\nuniform sampler2D colorTable;\t\t// color table with modified colors\r\n\r\n// varyings\r\nvarying vec2 vUV;\r\n\r\n// constants\r\nconst float SLICE_COUNT = 16.0;\t\t// how many slices in the color cube; 1 slice = 1 pixel\r\n// it means the image is 256x16 pixels\r\n\r\nvec4 sampleAs3DTexture(sampler2D texture, vec3 uv, float width) {\r\n\tfloat sliceSize = 1.0 / width;              // space of 1 slice\r\n\tfloat slicePixelSize = sliceSize / width;           // space of 1 pixel\r\n\tfloat sliceInnerSize = slicePixelSize * (width - 1.0);  // space of width pixels\r\n\tfloat zSlice0 = min(floor(uv.z * width), width - 1.0);\r\n\tfloat zSlice1 = min(zSlice0 + 1.0, width - 1.0);\r\n\tfloat xOffset = slicePixelSize * 0.5 + uv.x * sliceInnerSize;\r\n\tfloat s0 = xOffset + (zSlice0 * sliceSize);\r\n\tfloat s1 = xOffset + (zSlice1 * sliceSize);\r\n\tvec4 slice0Color = texture2D(texture, vec2(s0, uv.y));\r\n\tvec4 slice1Color = texture2D(texture, vec2(s1, uv.y));\r\n\tfloat zOffset = mod(uv.z * width, 1.0);\r\n\tvec4 result = mix(slice0Color, slice1Color, zOffset);\r\n\treturn result;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\tvec4 screen_color = texture2D(textureSampler, vUV);\r\n\tgl_FragColor = sampleAs3DTexture(colorTable, screen_color.rgb, SLICE_COUNT);\r\n\r\n}",
color_fragment: "﻿uniform vec4 color;\r\n\r\nvoid main(void) {\r\n\tgl_FragColor = color;\r\n}",
color_vertex: "﻿// Attributes\r\nattribute vec3 position;\r\n\r\n// Uniforms\r\nuniform mat4 worldViewProjection;\r\n\r\nvoid main(void) {\r\n\tgl_Position = worldViewProjection * vec4(position, 1.0);\r\n}",
convolution_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\nuniform vec2 screenSize;\r\nuniform float kernel[9];\r\n\r\nvoid main(void)\r\n{\r\n\tvec2 onePixel = vec2(1.0, 1.0) / screenSize;\r\n\tvec4 colorSum =\r\n\t\ttexture2D(textureSampler, vUV + onePixel * vec2(-1, -1)) * kernel[0] +\r\n\t\ttexture2D(textureSampler, vUV + onePixel * vec2(0, -1)) * kernel[1] +\r\n\t\ttexture2D(textureSampler, vUV + onePixel * vec2(1, -1)) * kernel[2] +\r\n\t\ttexture2D(textureSampler, vUV + onePixel * vec2(-1, 0)) * kernel[3] +\r\n\t\ttexture2D(textureSampler, vUV + onePixel * vec2(0, 0)) * kernel[4] +\r\n\t\ttexture2D(textureSampler, vUV + onePixel * vec2(1, 0)) * kernel[5] +\r\n\t\ttexture2D(textureSampler, vUV + onePixel * vec2(-1, 1)) * kernel[6] +\r\n\t\ttexture2D(textureSampler, vUV + onePixel * vec2(0, 1)) * kernel[7] +\r\n\t\ttexture2D(textureSampler, vUV + onePixel * vec2(1, 1)) * kernel[8];\r\n\r\n\tfloat kernelWeight =\r\n\t\tkernel[0] +\r\n\t\tkernel[1] +\r\n\t\tkernel[2] +\r\n\t\tkernel[3] +\r\n\t\tkernel[4] +\r\n\t\tkernel[5] +\r\n\t\tkernel[6] +\r\n\t\tkernel[7] +\r\n\t\tkernel[8];\r\n\r\n\tif (kernelWeight <= 0.0) {\r\n\t\tkernelWeight = 1.0;\r\n\t}\r\n\r\n\tgl_FragColor = vec4((colorSum / kernelWeight).rgb, 1);\r\n}",
default_fragment: "﻿#ifdef BUMP\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\n#ifdef LOGARITHMICDEPTH\r\n#extension GL_EXT_frag_depth : enable\r\n#endif\r\n\r\n// Constants\r\n#define RECIPROCAL_PI2 0.15915494\r\n\r\nuniform vec3 vEyePosition;\r\nuniform vec3 vAmbientColor;\r\nuniform vec4 vDiffuseColor;\r\n#ifdef SPECULARTERM\r\nuniform vec4 vSpecularColor;\r\n#endif\r\nuniform vec3 vEmissiveColor;\r\n\r\n// Input\r\nvarying vec3 vPositionW;\r\n\r\n#ifdef NORMAL\r\nvarying vec3 vNormalW;\r\n#endif\r\n\r\n#ifdef VERTEXCOLOR\r\nvarying vec4 vColor;\r\n#endif\r\n\r\n// Helper functions\r\n#include<helperFunctions>\r\n\r\n// Lights\r\n#include<lightFragmentDeclaration>[0..maxSimultaneousLights]\r\n\r\n#include<lightsFragmentFunctions>\r\n#include<shadowsFragmentFunctions>\r\n\r\n// Samplers\r\n#ifdef DIFFUSE\r\nvarying vec2 vDiffuseUV;\r\nuniform sampler2D diffuseSampler;\r\nuniform vec2 vDiffuseInfos;\r\n#endif\r\n\r\n#ifdef AMBIENT\r\nvarying vec2 vAmbientUV;\r\nuniform sampler2D ambientSampler;\r\nuniform vec2 vAmbientInfos;\r\n#endif\r\n\r\n#ifdef OPACITY\t\r\nvarying vec2 vOpacityUV;\r\nuniform sampler2D opacitySampler;\r\nuniform vec2 vOpacityInfos;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nvarying vec2 vEmissiveUV;\r\nuniform vec2 vEmissiveInfos;\r\nuniform sampler2D emissiveSampler;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\nvarying vec2 vLightmapUV;\r\nuniform vec2 vLightmapInfos;\r\nuniform sampler2D lightmapSampler;\r\n#endif\r\n\r\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\r\nuniform mat4 view;\r\n#endif\r\n\r\n#ifdef REFRACTION\r\nuniform vec4 vRefractionInfos;\r\n\r\n#ifdef REFRACTIONMAP_3D\r\nuniform samplerCube refractionCubeSampler;\r\n#else\r\nuniform sampler2D refraction2DSampler;\r\nuniform mat4 refractionMatrix;\r\n#endif\r\n\r\n#ifdef REFRACTIONFRESNEL\r\nuniform vec4 refractionLeftColor;\r\nuniform vec4 refractionRightColor;\r\n#endif\r\n#endif\r\n\r\n#if defined(SPECULAR) && defined(SPECULARTERM)\r\nvarying vec2 vSpecularUV;\r\nuniform vec2 vSpecularInfos;\r\nuniform sampler2D specularSampler;\r\n#endif\r\n\r\n// Fresnel\r\n#include<fresnelFunction>\r\n\r\n#ifdef DIFFUSEFRESNEL\r\nuniform vec4 diffuseLeftColor;\r\nuniform vec4 diffuseRightColor;\r\n#endif\r\n\r\n#ifdef OPACITYFRESNEL\r\nuniform vec4 opacityParts;\r\n#endif\r\n\r\n#ifdef EMISSIVEFRESNEL\r\nuniform vec4 emissiveLeftColor;\r\nuniform vec4 emissiveRightColor;\r\n#endif\r\n\r\n// Reflection\r\n#ifdef REFLECTION\r\nuniform vec2 vReflectionInfos;\r\n\r\n#ifdef REFLECTIONMAP_3D\r\nuniform samplerCube reflectionCubeSampler;\r\n#else\r\nuniform sampler2D reflection2DSampler;\r\n#endif\r\n\r\n#ifdef REFLECTIONMAP_SKYBOX\r\nvarying vec3 vPositionUVW;\r\n#else\r\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\r\nvarying vec3 vDirectionW;\r\n#endif\r\n\r\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION)\r\nuniform mat4 reflectionMatrix;\r\n#endif\r\n#endif\r\n\r\n#include<reflectionFunction>\r\n\r\n#ifdef REFLECTIONFRESNEL\r\nuniform vec4 reflectionLeftColor;\r\nuniform vec4 reflectionRightColor;\r\n#endif\r\n\r\n#endif\r\n\r\n#ifdef CAMERACOLORGRADING\r\n\t#include<colorGradingDefinition>\t\r\n\t#include<colorGrading>\r\n#endif\r\n\r\n#ifdef CAMERACOLORCURVES\r\n\t#include<colorCurvesDefinition>\r\n\t#include<colorCurves>\r\n#endif\r\n\r\n#include<bumpFragmentFunctions>\r\n#include<clipPlaneFragmentDeclaration>\r\n#include<logDepthDeclaration>\r\n#include<fogFragmentDeclaration>\r\n\r\nvoid main(void) {\r\n#include<clipPlaneFragment>\r\n\r\n\tvec3 viewDirectionW = normalize(vEyePosition - vPositionW);\r\n\r\n\t// Base color\r\n\tvec4 baseColor = vec4(1., 1., 1., 1.);\r\n\tvec3 diffuseColor = vDiffuseColor.rgb;\r\n\r\n\t// Alpha\r\n\tfloat alpha = vDiffuseColor.a;\r\n\r\n\t// Bump\r\n#ifdef NORMAL\r\n\tvec3 normalW = normalize(vNormalW);\r\n#else\r\n\tvec3 normalW = vec3(1.0, 1.0, 1.0);\r\n#endif\r\n\r\n#include<bumpFragment>\r\n\r\n#ifdef DIFFUSE\r\n\tbaseColor = texture2D(diffuseSampler, vDiffuseUV + uvOffset);\r\n\r\n#ifdef ALPHATEST\r\n\tif (baseColor.a < 0.4)\r\n\t\tdiscard;\r\n#endif\r\n\r\n#ifdef ALPHAFROMDIFFUSE\r\n\talpha *= baseColor.a;\r\n#endif\r\n\r\n\tbaseColor.rgb *= vDiffuseInfos.y;\r\n#endif\r\n\r\n#ifdef VERTEXCOLOR\r\n\tbaseColor.rgb *= vColor.rgb;\r\n#endif\r\n\r\n\t// Ambient color\r\n\tvec3 baseAmbientColor = vec3(1., 1., 1.);\r\n\r\n#ifdef AMBIENT\r\n\tbaseAmbientColor = texture2D(ambientSampler, vAmbientUV + uvOffset).rgb * vAmbientInfos.y;\r\n#endif\r\n\r\n\t// Specular map\r\n#ifdef SPECULARTERM\r\n\tfloat glossiness = vSpecularColor.a;\r\n\tvec3 specularColor = vSpecularColor.rgb;\r\n\r\n#ifdef SPECULAR\r\n\tvec4 specularMapColor = texture2D(specularSampler, vSpecularUV + uvOffset);\r\n\tspecularColor = specularMapColor.rgb;\r\n#ifdef GLOSSINESS\r\n\tglossiness = glossiness * specularMapColor.a;\r\n#endif\r\n#endif\r\n#else\r\n\tfloat glossiness = 0.;\r\n#endif\r\n\r\n\t// Lighting\r\n\tvec3 diffuseBase = vec3(0., 0., 0.);\r\n\tlightingInfo info;\r\n#ifdef SPECULARTERM\r\n\tvec3 specularBase = vec3(0., 0., 0.);\r\n#endif\r\n\tfloat shadow = 1.;\r\n\r\n#ifdef LIGHTMAP\r\n\tvec3 lightmapColor = texture2D(lightmapSampler, vLightmapUV + uvOffset).rgb * vLightmapInfos.y;\r\n#endif\r\n\r\n#include<lightFragment>[0..maxSimultaneousLights]\r\n\r\n\t// Refraction\r\n\tvec3 refractionColor = vec3(0., 0., 0.);\r\n\r\n#ifdef REFRACTION\r\n\tvec3 refractionVector = normalize(refract(-viewDirectionW, normalW, vRefractionInfos.y));\r\n#ifdef REFRACTIONMAP_3D\r\n\r\n\trefractionVector.y = refractionVector.y * vRefractionInfos.w;\r\n\r\n\tif (dot(refractionVector, viewDirectionW) < 1.0)\r\n\t{\r\n\t\trefractionColor = textureCube(refractionCubeSampler, refractionVector).rgb * vRefractionInfos.x;\r\n\t}\r\n#else\r\n\tvec3 vRefractionUVW = vec3(refractionMatrix * (view * vec4(vPositionW + refractionVector * vRefractionInfos.z, 1.0)));\r\n\r\n\tvec2 refractionCoords = vRefractionUVW.xy / vRefractionUVW.z;\r\n\r\n\trefractionCoords.y = 1.0 - refractionCoords.y;\r\n\r\n\trefractionColor = texture2D(refraction2DSampler, refractionCoords).rgb * vRefractionInfos.x;\r\n#endif\r\n#endif\r\n\r\n\t// Reflection\r\n\tvec3 reflectionColor = vec3(0., 0., 0.);\r\n\r\n#ifdef REFLECTION\r\n\tvec3 vReflectionUVW = computeReflectionCoords(vec4(vPositionW, 1.0), normalW);\r\n\r\n#ifdef REFLECTIONMAP_3D\r\n#ifdef ROUGHNESS\r\n\tfloat bias = vReflectionInfos.y;\r\n\r\n#ifdef SPECULARTERM\r\n\t#ifdef SPECULAR\r\n\t\t#ifdef GLOSSINESS\r\n\t\t\tbias *= (1.0 - specularMapColor.a);\r\n\t\t#endif\r\n\t#endif\r\n#endif\r\n\r\n\treflectionColor = textureCube(reflectionCubeSampler, vReflectionUVW, bias).rgb * vReflectionInfos.x;\r\n#else\r\n\treflectionColor = textureCube(reflectionCubeSampler, vReflectionUVW).rgb * vReflectionInfos.x;\r\n#endif\r\n\r\n#else\r\n\tvec2 coords = vReflectionUVW.xy;\r\n\r\n#ifdef REFLECTIONMAP_PROJECTION\r\n\tcoords /= vReflectionUVW.z;\r\n#endif\r\n\r\n\tcoords.y = 1.0 - coords.y;\r\n\r\n\treflectionColor = texture2D(reflection2DSampler, coords).rgb * vReflectionInfos.x;\r\n#endif\r\n\r\n#ifdef REFLECTIONFRESNEL\r\n\tfloat reflectionFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, reflectionRightColor.a, reflectionLeftColor.a);\r\n\r\n#ifdef REFLECTIONFRESNELFROMSPECULAR\r\n#ifdef SPECULARTERM\r\n\treflectionColor *= specularColor.rgb * (1.0 - reflectionFresnelTerm) + reflectionFresnelTerm * reflectionRightColor.rgb;\r\n#else\r\n\treflectionColor *= reflectionLeftColor.rgb * (1.0 - reflectionFresnelTerm) + reflectionFresnelTerm * reflectionRightColor.rgb;\r\n#endif\r\n#else\r\n\treflectionColor *= reflectionLeftColor.rgb * (1.0 - reflectionFresnelTerm) + reflectionFresnelTerm * reflectionRightColor.rgb;\r\n#endif\r\n#endif\r\n#endif\r\n\r\n#ifdef REFRACTIONFRESNEL\r\n\tfloat refractionFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, refractionRightColor.a, refractionLeftColor.a);\r\n\r\n\trefractionColor *= refractionLeftColor.rgb * (1.0 - refractionFresnelTerm) + refractionFresnelTerm * refractionRightColor.rgb;\r\n#endif\r\n\r\n#ifdef OPACITY\r\n\tvec4 opacityMap = texture2D(opacitySampler, vOpacityUV + uvOffset);\r\n\r\n#ifdef OPACITYRGB\r\n\topacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11);\r\n\talpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\r\n#else\r\n\talpha *= opacityMap.a * vOpacityInfos.y;\r\n#endif\r\n\r\n#endif\r\n\r\n#ifdef VERTEXALPHA\r\n\talpha *= vColor.a;\r\n#endif\r\n\r\n#ifdef OPACITYFRESNEL\r\n\tfloat opacityFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, opacityParts.z, opacityParts.w);\r\n\r\n\talpha += opacityParts.x * (1.0 - opacityFresnelTerm) + opacityFresnelTerm * opacityParts.y;\r\n#endif\r\n\r\n\t// Emissive\r\n\tvec3 emissiveColor = vEmissiveColor;\r\n#ifdef EMISSIVE\r\n\temissiveColor += texture2D(emissiveSampler, vEmissiveUV + uvOffset).rgb * vEmissiveInfos.y;\r\n#endif\r\n\r\n#ifdef EMISSIVEFRESNEL\r\n\tfloat emissiveFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, emissiveRightColor.a, emissiveLeftColor.a);\r\n\r\n\temissiveColor *= emissiveLeftColor.rgb * (1.0 - emissiveFresnelTerm) + emissiveFresnelTerm * emissiveRightColor.rgb;\r\n#endif\r\n\r\n\t// Fresnel\r\n#ifdef DIFFUSEFRESNEL\r\n\tfloat diffuseFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, diffuseRightColor.a, diffuseLeftColor.a);\r\n\r\n\tdiffuseBase *= diffuseLeftColor.rgb * (1.0 - diffuseFresnelTerm) + diffuseFresnelTerm * diffuseRightColor.rgb;\r\n#endif\r\n\r\n\t// Composition\r\n#ifdef EMISSIVEASILLUMINATION\r\n\tvec3 finalDiffuse = clamp(diffuseBase * diffuseColor + vAmbientColor, 0.0, 1.0) * baseColor.rgb;\r\n#else\r\n#ifdef LINKEMISSIVEWITHDIFFUSE\r\n\tvec3 finalDiffuse = clamp((diffuseBase + emissiveColor) * diffuseColor + vAmbientColor, 0.0, 1.0) * baseColor.rgb;\r\n#else\r\n\tvec3 finalDiffuse = clamp(diffuseBase * diffuseColor + emissiveColor + vAmbientColor, 0.0, 1.0) * baseColor.rgb;\r\n#endif\r\n#endif\r\n\r\n#ifdef SPECULARTERM\r\n\tvec3 finalSpecular = specularBase * specularColor;\r\n#else\r\n\tvec3 finalSpecular = vec3(0.0);\r\n#endif\r\n\r\n#ifdef SPECULAROVERALPHA\r\n\talpha = clamp(alpha + dot(finalSpecular, vec3(0.3, 0.59, 0.11)), 0., 1.);\r\n#endif\r\n\r\n#ifdef REFLECTIONOVERALPHA\r\n\talpha = clamp(alpha + dot(reflectionColor, vec3(0.3, 0.59, 0.11)), 0., 1.);\r\n#endif\r\n\r\n\t// Composition\r\n#ifdef EMISSIVEASILLUMINATION\r\n\tvec4 color = vec4(clamp(finalDiffuse * baseAmbientColor + finalSpecular + reflectionColor + emissiveColor + refractionColor, 0.0, 1.0), alpha);\r\n#else\r\n\tvec4 color = vec4(finalDiffuse * baseAmbientColor + finalSpecular + reflectionColor + refractionColor, alpha);\r\n#endif\r\n\r\n//Old lightmap calculation method\r\n#ifdef LIGHTMAP\r\n    #ifndef LIGHTMAPEXCLUDED\r\n        #ifdef USELIGHTMAPASSHADOWMAP\r\n            color.rgb *= lightmapColor;\r\n        #else\r\n            color.rgb += lightmapColor;\r\n        #endif\r\n    #endif\r\n#endif\r\n\r\n#include<logDepthFragment>\r\n#include<fogFragment>\r\n\r\n#ifdef CAMERACOLORGRADING\r\n\tcolor = colorGrades(color);\r\n#endif\r\n\r\n#ifdef CAMERACOLORCURVES\r\n\tcolor.rgb = applyColorCurves(color.rgb);\r\n#endif\r\n\r\n\tgl_FragColor = color;\r\n}",
default_vertex: "﻿// Attributes\r\nattribute vec3 position;\r\n#ifdef NORMAL\r\nattribute vec3 normal;\r\n#endif\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n#ifdef VERTEXCOLOR\r\nattribute vec4 color;\r\n#endif\r\n\r\n#include<bonesDeclaration>\r\n\r\n// Uniforms\r\n#include<instancesDeclaration>\r\n\r\nuniform mat4 view;\r\nuniform mat4 viewProjection;\r\n\r\n#ifdef DIFFUSE\r\nvarying vec2 vDiffuseUV;\r\nuniform mat4 diffuseMatrix;\r\nuniform vec2 vDiffuseInfos;\r\n#endif\r\n\r\n#ifdef AMBIENT\r\nvarying vec2 vAmbientUV;\r\nuniform mat4 ambientMatrix;\r\nuniform vec2 vAmbientInfos;\r\n#endif\r\n\r\n#ifdef OPACITY\r\nvarying vec2 vOpacityUV;\r\nuniform mat4 opacityMatrix;\r\nuniform vec2 vOpacityInfos;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nvarying vec2 vEmissiveUV;\r\nuniform vec2 vEmissiveInfos;\r\nuniform mat4 emissiveMatrix;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\nvarying vec2 vLightmapUV;\r\nuniform vec2 vLightmapInfos;\r\nuniform mat4 lightmapMatrix;\r\n#endif\r\n\r\n#if defined(SPECULAR) && defined(SPECULARTERM)\r\nvarying vec2 vSpecularUV;\r\nuniform vec2 vSpecularInfos;\r\nuniform mat4 specularMatrix;\r\n#endif\r\n\r\n#ifdef BUMP\r\nvarying vec2 vBumpUV;\r\nuniform vec3 vBumpInfos;\r\nuniform mat4 bumpMatrix;\r\n#endif\r\n\r\n#include<Vector2CloudVertexDeclaration>\r\n\r\n// Output\r\nvarying vec3 vPositionW;\r\n#ifdef NORMAL\r\nvarying vec3 vNormalW;\r\n#endif\r\n\r\n#ifdef VERTEXCOLOR\r\nvarying vec4 vColor;\r\n#endif\r\n\r\n#include<clipPlaneVertexDeclaration>\r\n\r\n#include<fogVertexDeclaration>\r\n#include<shadowsVertexDeclaration>[0..maxSimultaneousLights]\r\n\r\n#ifdef REFLECTIONMAP_SKYBOX\r\nvarying vec3 vPositionUVW;\r\n#endif\r\n\r\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\r\nvarying vec3 vDirectionW;\r\n#endif\r\n\r\n#include<logDepthDeclaration>\r\n\r\nvoid main(void) {\r\n#ifdef REFLECTIONMAP_SKYBOX\r\n\tvPositionUVW = position;\r\n#endif \r\n\r\n#include<instancesVertex>\r\n#include<bonesVertex>\r\n\r\n\tgl_Position = viewProjection * finalWorld * vec4(position, 1.0);\r\n\r\n\tvec4 worldPos = finalWorld * vec4(position, 1.0);\r\n\tvPositionW = vec3(worldPos);\r\n\r\n#ifdef NORMAL\r\n\tvNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\r\n#endif\r\n\r\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\r\n\tvDirectionW = normalize(vec3(finalWorld * vec4(position, 0.0)));\r\n#endif\r\n\r\n\t// Texture coordinates\r\n#ifndef UV1\r\n\tvec2 uv = vec2(0., 0.);\r\n#endif\r\n#ifndef UV2\r\n\tvec2 uv2 = vec2(0., 0.);\r\n#endif\r\n\r\n#ifdef DIFFUSE\r\n\tif (vDiffuseInfos.x == 0.)\r\n\t{\r\n\t\tvDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\r\n\t}\r\n#endif\r\n\r\n#ifdef AMBIENT\r\n\tif (vAmbientInfos.x == 0.)\r\n\t{\r\n\t\tvAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\r\n\t}\r\n#endif\r\n\r\n#ifdef OPACITY\r\n\tif (vOpacityInfos.x == 0.)\r\n\t{\r\n\t\tvOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\r\n\t}\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\n\tif (vEmissiveInfos.x == 0.)\r\n\t{\r\n\t\tvEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\r\n\t}\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tif (vLightmapInfos.x == 0.)\r\n\t{\r\n\t\tvLightmapUV = vec2(lightmapMatrix * vec4(uv, 1.0, 0.0));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvLightmapUV = vec2(lightmapMatrix * vec4(uv2, 1.0, 0.0));\r\n\t}\r\n#endif\r\n\r\n#if defined(SPECULAR) && defined(SPECULARTERM)\r\n\tif (vSpecularInfos.x == 0.)\r\n\t{\r\n\t\tvSpecularUV = vec2(specularMatrix * vec4(uv, 1.0, 0.0));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvSpecularUV = vec2(specularMatrix * vec4(uv2, 1.0, 0.0));\r\n\t}\r\n#endif\r\n\r\n#ifdef BUMP\r\n\tif (vBumpInfos.x == 0.)\r\n\t{\r\n\t\tvBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\r\n\t}\r\n#endif\r\n\r\n#include<clipPlaneVertex>\r\n#include<fogVertex>\r\n#include<shadowsVertex>[0..maxSimultaneousLights]\r\n\r\n\t// Vertex color\r\n#ifdef VERTEXCOLOR\r\n\tvColor = color;\r\n#endif\r\n\r\n#include<Vector2CloudVertex>\r\n#include<logDepthVertex>\r\n\r\n}",
depthBoxBlur_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\n// Parameters\r\nuniform vec2 screenSize;\r\n\r\nvoid main(void)\r\n{\r\n\tvec4 colorDepth = vec4(0.0);\r\n\r\n\tfor (int x = -OFFSET; x <= OFFSET; x++)\r\n\t\tfor (int y = -OFFSET; y <= OFFSET; y++)\r\n\t\t\tcolorDepth += texture2D(textureSampler, vUV + vec2(x, y) / screenSize);\r\n\r\n\tgl_FragColor = (colorDepth / float((OFFSET * 2 + 1) * (OFFSET * 2 + 1)));\r\n}",
depthOfField_fragment: "// BABYLON.JS Depth-of-field GLSL Shader\r\n// Author: Olivier Guyot\r\n// Does depth-of-field blur, edge blur\r\n// Inspired by Francois Tarlier & Martins Upitis\r\n\r\n// samplers\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D highlightsSampler;\r\nuniform sampler2D depthSampler;\r\nuniform sampler2D grainSampler;\r\n\r\n// uniforms\r\nuniform float grain_amount;\r\nuniform bool blur_noise;\r\nuniform float screen_width;\r\nuniform float screen_height;\r\nuniform float distortion;\r\nuniform bool dof_enabled;\r\n//uniform float focus_distance;\t\t// not needed; already used to compute screen distance\r\nuniform float screen_distance;\t\t// precomputed screen distance from lens center; based on focal length & desired focus distance\r\nuniform float aperture;\r\nuniform float darken;\r\nuniform float edge_blur;\r\nuniform bool highlights;\r\n\r\n// preconputed uniforms (not effect parameters)\r\nuniform float near;\r\nuniform float far;\r\n\r\n// varyings\r\nvarying vec2 vUV;\r\n\r\n// constants\r\n#define PI \t\t3.14159265\r\n#define TWOPI \t6.28318530\r\n#define inverse_focal_length 0.1\t// a property of the lens used\r\n\r\n// common calculations\r\nvec2 centered_screen_pos;\r\nvec2 distorted_coords;\r\nfloat radius2;\r\nfloat radius;\r\n\r\n\r\n// on-the-fly constant noise\r\nvec2 rand(vec2 co)\r\n{\r\n\tfloat noise1 = (fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453));\r\n\tfloat noise2 = (fract(sin(dot(co, vec2(12.9898, 78.233)*2.0)) * 43758.5453));\r\n\treturn clamp(vec2(noise1, noise2), 0.0, 1.0);\r\n}\r\n\r\n// applies edge distortion on texture coords\r\nvec2 getDistortedCoords(vec2 coords) {\r\n\r\n\tif (distortion == 0.0) { return coords; }\r\n\r\n\tvec2 direction = 1.0 * normalize(centered_screen_pos);\r\n\tvec2 dist_coords = vec2(0.5, 0.5);\r\n\tdist_coords.x = 0.5 + direction.x * radius2 * 1.0;\r\n\tdist_coords.y = 0.5 + direction.y * radius2 * 1.0;\r\n\tfloat dist_amount = clamp(distortion*0.23, 0.0, 1.0);\r\n\r\n\tdist_coords = mix(coords, dist_coords, dist_amount);\r\n\r\n\treturn dist_coords;\r\n}\r\n\r\n// sample screen with an offset (randomize offset angle for better smothness), returns partial sample weight\r\nfloat sampleScreen(inout vec4 color, const in vec2 offset, const in float weight) {\r\n\r\n\t// compute coords with offset (a random angle is added)\r\n\tvec2 coords = distorted_coords;\r\n\tfloat angle = rand(coords * 100.0).x * TWOPI;\r\n\tcoords += vec2(offset.x * cos(angle) - offset.y * sin(angle), offset.x * sin(angle) + offset.y * cos(angle));\r\n\r\n\tcolor += texture2D(textureSampler, coords)*weight;\r\n\r\n\treturn weight;\r\n}\r\n\r\n// returns blur level according to blur size required\r\nfloat getBlurLevel(float size) {\r\n\treturn min(3.0, ceil(size / 1.0));\r\n}\r\n\r\n// returns original screen color after blur\r\nvec4 getBlurColor(float size) {\r\n\r\n\tvec4 col = texture2D(textureSampler, distorted_coords);\r\n\tif (size == 0.0) { return col; }\r\n\r\n\t// there are max. 30 samples; the number of samples chosen is dependant on the blur size\r\n\t// there can be 10, 20 or 30 samples chosen; levels of blur are then 1, 2 or 3\r\n\tfloat blur_level = getBlurLevel(size);\r\n\r\n\tfloat w = (size / screen_width);\r\n\tfloat h = (size / screen_height);\r\n\tfloat total_weight = 1.0;\r\n\tvec2 sample_coords;\r\n\r\n\ttotal_weight += sampleScreen(col, vec2(-0.50*w, 0.24*h), 0.93);\r\n\ttotal_weight += sampleScreen(col, vec2(0.30*w, -0.75*h), 0.90);\r\n\ttotal_weight += sampleScreen(col, vec2(0.36*w, 0.96*h), 0.87);\r\n\ttotal_weight += sampleScreen(col, vec2(-1.08*w, -0.55*h), 0.85);\r\n\ttotal_weight += sampleScreen(col, vec2(1.33*w, -0.37*h), 0.83);\r\n\ttotal_weight += sampleScreen(col, vec2(-0.82*w, 1.31*h), 0.80);\r\n\ttotal_weight += sampleScreen(col, vec2(-0.31*w, -1.67*h), 0.78);\r\n\ttotal_weight += sampleScreen(col, vec2(1.47*w, 1.11*h), 0.76);\r\n\ttotal_weight += sampleScreen(col, vec2(-1.97*w, 0.19*h), 0.74);\r\n\ttotal_weight += sampleScreen(col, vec2(1.42*w, -1.57*h), 0.72);\r\n\r\n\tif (blur_level > 1.0) {\r\n\t\ttotal_weight += sampleScreen(col, vec2(0.01*w, 2.25*h), 0.70);\r\n\t\ttotal_weight += sampleScreen(col, vec2(-1.62*w, -1.74*h), 0.67);\r\n\t\ttotal_weight += sampleScreen(col, vec2(2.49*w, 0.20*h), 0.65);\r\n\t\ttotal_weight += sampleScreen(col, vec2(-2.07*w, 1.61*h), 0.63);\r\n\t\ttotal_weight += sampleScreen(col, vec2(0.46*w, -2.70*h), 0.61);\r\n\t\ttotal_weight += sampleScreen(col, vec2(1.55*w, 2.40*h), 0.59);\r\n\t\ttotal_weight += sampleScreen(col, vec2(-2.88*w, -0.75*h), 0.56);\r\n\t\ttotal_weight += sampleScreen(col, vec2(2.73*w, -1.44*h), 0.54);\r\n\t\ttotal_weight += sampleScreen(col, vec2(-1.08*w, 3.02*h), 0.52);\r\n\t\ttotal_weight += sampleScreen(col, vec2(-1.28*w, -3.05*h), 0.49);\r\n\t}\r\n\r\n\tif (blur_level > 2.0) {\r\n\t\ttotal_weight += sampleScreen(col, vec2(3.11*w, 1.43*h), 0.46);\r\n\t\ttotal_weight += sampleScreen(col, vec2(-3.36*w, 1.08*h), 0.44);\r\n\t\ttotal_weight += sampleScreen(col, vec2(1.80*w, -3.16*h), 0.41);\r\n\t\ttotal_weight += sampleScreen(col, vec2(0.83*w, 3.65*h), 0.38);\r\n\t\ttotal_weight += sampleScreen(col, vec2(-3.16*w, -2.19*h), 0.34);\r\n\t\ttotal_weight += sampleScreen(col, vec2(3.92*w, -0.53*h), 0.31);\r\n\t\ttotal_weight += sampleScreen(col, vec2(-2.59*w, 3.12*h), 0.26);\r\n\t\ttotal_weight += sampleScreen(col, vec2(-0.20*w, -4.15*h), 0.22);\r\n\t\ttotal_weight += sampleScreen(col, vec2(3.02*w, 3.00*h), 0.15);\r\n\t}\r\n\r\n\tcol /= total_weight;\t\t// scales color according to weights\r\n\r\n\t\t\t\t\t\t\t\t// darken if out of focus\r\n\tif (darken > 0.0) {\r\n\t\tcol.rgb *= clamp(0.3, 1.0, 1.05 - size*0.5*darken);\r\n\t}\r\n\r\n\t// blur levels debug\r\n\t// if(blur_level == 1.0) { col.b *= 0.5; }\r\n\t// if(blur_level == 2.0) { col.r *= 0.5; }\r\n\t// if(blur_level == 3.0) { col.g *= 0.5; }\r\n\r\n\treturn col;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\r\n\t// Common calc: position relative to screen center, screen radius, distorted coords, position in texel space\r\n\tcentered_screen_pos = vec2(vUV.x - 0.5, vUV.y - 0.5);\r\n\tradius2 = centered_screen_pos.x*centered_screen_pos.x + centered_screen_pos.y*centered_screen_pos.y;\r\n\tradius = sqrt(radius2);\r\n\tdistorted_coords = getDistortedCoords(vUV);\t\t// we distort the screen coordinates (lens \"magnifying\" effect)\r\n\tvec2 texels_coords = vec2(vUV.x * screen_width, vUV.y * screen_height);\t// varies from 0 to SCREEN_WIDTH or _HEIGHT\r\n\r\n\tfloat depth = texture2D(depthSampler, distorted_coords).r;\t// depth value from DepthRenderer: 0 to 1\r\n\tfloat distance = near + (far - near)*depth;\t\t// actual distance from the lens\r\n\tvec4 color = texture2D(textureSampler, vUV);\t// original raster\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// compute the circle of confusion size (CoC), i.e. blur radius depending on depth\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// screen_distance is precomputed in code\r\n\tfloat coc = abs(aperture * (screen_distance * (inverse_focal_length - 1.0 / distance) - 1.0));\r\n\r\n\t// disable blur\r\n\tif (dof_enabled == false || coc < 0.07) { coc = 0.0; }\r\n\r\n\t// blur from edge blur effect\r\n\tfloat edge_blur_amount = 0.0;\r\n\tif (edge_blur > 0.0) {\r\n\t\tedge_blur_amount = clamp((radius*2.0 - 1.0 + 0.15*edge_blur) * 1.5, 0.0, 1.0) * 1.3;\r\n\t}\r\n\r\n\t// total blur amount\r\n\tfloat blur_amount = max(edge_blur_amount, coc);\r\n\r\n\t// apply blur if necessary\r\n\tif (blur_amount == 0.0) {\r\n\t\tgl_FragColor = texture2D(textureSampler, distorted_coords);\r\n\t}\r\n\telse {\r\n\r\n\t\t// add blurred color\r\n\t\tgl_FragColor = getBlurColor(blur_amount * 1.7);\r\n\r\n\t\t// if we have computed highlights: enhance highlights\r\n\t\tif (highlights) {\r\n\t\t\tgl_FragColor.rgb += clamp(coc, 0.0, 1.0)*texture2D(highlightsSampler, distorted_coords).rgb;\r\n\t\t}\r\n\r\n\t\tif (blur_noise) {\r\n\t\t\t// we put a slight amount of noise in the blurred color\r\n\t\t\tvec2 noise = rand(distorted_coords) * 0.01 * blur_amount;\r\n\t\t\tvec2 blurred_coord = vec2(distorted_coords.x + noise.x, distorted_coords.y + noise.y);\r\n\t\t\tgl_FragColor = 0.04 * texture2D(textureSampler, blurred_coord) + 0.96 * gl_FragColor;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// apply grain\r\n\tif (grain_amount > 0.0) {\r\n\t\tvec4 grain_color = texture2D(grainSampler, texels_coords*0.003);\r\n\t\tgl_FragColor.rgb += (-0.5 + grain_color.rgb) * 0.30 * grain_amount;\r\n\t}\r\n\r\n}\r\n",
depth_fragment: "﻿#ifdef ALPHATEST\r\nvarying vec2 vUV;\r\nuniform sampler2D diffuseSampler;\r\n#endif\r\n\r\nuniform float far;\r\n\r\nvoid main(void)\r\n{\r\n#ifdef ALPHATEST\r\n\tif (texture2D(diffuseSampler, vUV).a < 0.4)\r\n\t\tdiscard;\r\n#endif\r\n\r\n\tfloat depth = (gl_FragCoord.z / gl_FragCoord.w) / far;\r\n\tgl_FragColor = vec4(depth, depth * depth, 0.0, 1.0);\r\n}",
depth_vertex: "﻿// Attribute\r\nattribute vec3 position;\r\n#include<bonesDeclaration>\r\n\r\n// Uniform\r\n#include<instancesDeclaration>\r\n\r\nuniform mat4 viewProjection;\r\n\r\n#if defined(ALPHATEST) || defined(NEED_UV)\r\nvarying vec2 vUV;\r\nuniform mat4 diffuseMatrix;\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n#endif\r\n\r\nvoid main(void)\r\n{\r\n#include<instancesVertex>\r\n\r\n#include<bonesVertex>\r\n\r\n\tgl_Position = viewProjection * finalWorld * vec4(position, 1.0);\r\n\r\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\r\n#ifdef UV1\r\n\tvUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\r\n#endif\r\n#ifdef UV2\r\n\tvUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\r\n#endif\r\n#endif\r\n}",
displayPass_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D passSampler;\r\n\r\nvoid main(void)\r\n{\r\n    gl_FragColor = texture2D(passSampler, vUV);\r\n}",
filter_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\nuniform mat4 kernelMatrix;\r\n\r\nvoid main(void)\r\n{\r\n\tvec3 baseColor = texture2D(textureSampler, vUV).rgb;\r\n\tvec3 updatedColor = (kernelMatrix * vec4(baseColor, 1.0)).rgb;\r\n\r\n\tgl_FragColor = vec4(updatedColor, 1.0);\r\n}",
fxaa_fragment: "﻿#define FXAA_REDUCE_MIN   (1.0/128.0)\r\n#define FXAA_REDUCE_MUL   (1.0/8.0)\r\n#define FXAA_SPAN_MAX     8.0\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\nuniform vec2 texelSize;\r\n\r\nvoid main(){\r\n\tvec2 localTexelSize = texelSize;\r\n\tvec4 rgbNW = texture2D(textureSampler, (vUV + vec2(-1.0, -1.0) * localTexelSize));\r\n\tvec4 rgbNE = texture2D(textureSampler, (vUV + vec2(1.0, -1.0) * localTexelSize));\r\n\tvec4 rgbSW = texture2D(textureSampler, (vUV + vec2(-1.0, 1.0) * localTexelSize));\r\n\tvec4 rgbSE = texture2D(textureSampler, (vUV + vec2(1.0, 1.0) * localTexelSize));\r\n\tvec4 rgbM = texture2D(textureSampler, vUV);\r\n\tvec4 luma = vec4(0.299, 0.587, 0.114, 1.0);\r\n\tfloat lumaNW = dot(rgbNW, luma);\r\n\tfloat lumaNE = dot(rgbNE, luma);\r\n\tfloat lumaSW = dot(rgbSW, luma);\r\n\tfloat lumaSE = dot(rgbSE, luma);\r\n\tfloat lumaM = dot(rgbM, luma);\r\n\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\r\n\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\r\n\r\n\tvec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\r\n\r\n\tfloat dirReduce = max(\r\n\t\t(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\r\n\t\tFXAA_REDUCE_MIN);\r\n\r\n\tfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\r\n\tdir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\r\n\t\tmax(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\r\n\t\tdir * rcpDirMin)) * localTexelSize;\r\n\r\n\tvec4 rgbA = 0.5 * (\r\n\t\ttexture2D(textureSampler, vUV + dir * (1.0 / 3.0 - 0.5)) +\r\n\t\ttexture2D(textureSampler, vUV + dir * (2.0 / 3.0 - 0.5)));\r\n\r\n\tvec4 rgbB = rgbA * 0.5 + 0.25 * (\r\n\t\ttexture2D(textureSampler, vUV + dir *  -0.5) +\r\n\t\ttexture2D(textureSampler, vUV + dir * 0.5));\r\n\tfloat lumaB = dot(rgbB, luma);\r\n\tif ((lumaB < lumaMin) || (lumaB > lumaMax)) {\r\n\t\tgl_FragColor = rgbA;\r\n\t}\r\n\telse {\r\n\t\tgl_FragColor = rgbB;\r\n\t}\r\n}",
glowBlurPostProcess_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\n// Parameters\r\nuniform vec2 screenSize;\r\nuniform vec2 direction;\r\nuniform float blurWidth;\r\n\r\n// Transform color to luminance.\r\nfloat getLuminance(vec3 color)\r\n{\r\n    return dot(color, vec3(0.2126, 0.7152, 0.0722));\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\tfloat weights[7];\r\n\tweights[0] = 0.05;\r\n\tweights[1] = 0.1;\r\n\tweights[2] = 0.2;\r\n\tweights[3] = 0.3;\r\n\tweights[4] = 0.2;\r\n\tweights[5] = 0.1;\r\n\tweights[6] = 0.05;\r\n\r\n\tvec2 texelSize = vec2(1.0 / screenSize.x, 1.0 / screenSize.y);\r\n\tvec2 texelStep = texelSize * direction * blurWidth;\r\n\tvec2 start = vUV - 3.0 * texelStep;\r\n\r\n\tvec4 baseColor = vec4(0., 0., 0., 0.);\r\n\tvec2 texelOffset = vec2(0., 0.);\r\n\r\n\tfor (int i = 0; i < 7; i++)\r\n\t{\r\n\t\t// alpha blur.\r\n\t\tvec4 texel = texture2D(textureSampler, start + texelOffset);\r\n\t\tbaseColor.a += texel.a * weights[i];\r\n\r\n\t\t// Highest Luma for outline.\r\n\t\tfloat luminance = getLuminance(baseColor.rgb);\r\n\t\tfloat luminanceTexel = getLuminance(texel.rgb);\r\n\t\tfloat choice = step(luminanceTexel, luminance);\r\n\t\tbaseColor.rgb = choice * baseColor.rgb + (1.0 - choice) * texel.rgb;\r\n\r\n\t\ttexelOffset += texelStep;\r\n\t}\r\n\r\n\tgl_FragColor = baseColor;\r\n}",
glowMapGeneration_fragment: "﻿#ifdef ALPHATEST\r\nvarying vec2 vUVDiffuse;\r\nuniform sampler2D diffuseSampler;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nvarying vec2 vUVEmissive;\r\nuniform sampler2D emissiveSampler;\r\n#endif\r\n\r\nuniform vec4 color;\r\n\r\nvoid main(void)\r\n{\r\n#ifdef ALPHATEST\r\n\tif (texture2D(diffuseSampler, vUVDiffuse).a < 0.4)\r\n\t\tdiscard;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\n\tgl_FragColor = texture2D(emissiveSampler, vUVEmissive);\r\n#else\r\n\tgl_FragColor = color;\r\n#endif\r\n}",
glowMapGeneration_vertex: "﻿// Attribute\r\nattribute vec3 position;\r\n\r\n#include<bonesDeclaration>\r\n\r\n// Uniforms\r\n#include<instancesDeclaration>\r\n\r\nuniform mat4 viewProjection;\r\n\r\nvarying vec4 vPosition;\r\n\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n\tvarying vec2 vUVDiffuse;\r\n\tuniform mat4 diffuseMatrix;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\n\tvarying vec2 vUVEmissive;\r\n\tuniform mat4 emissiveMatrix;\r\n#endif\r\n\r\nvoid main(void)\r\n{\r\n#include<instancesVertex>\r\n#include<bonesVertex>\r\n\r\n#ifdef CUBEMAP\r\n\tvPosition = finalWorld * vec4(position, 1.0);\r\n\tgl_Position = viewProjection * finalWorld * vec4(position, 1.0);\r\n#else\r\n\tvPosition = viewProjection * finalWorld * vec4(position, 1.0);\r\n\tgl_Position = vPosition;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n\t#ifdef DIFFUSEUV1\r\n\t\tvUVDiffuse = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\r\n\t#endif\r\n\t#ifdef DIFFUSEUV2\r\n\t\tvUVDiffuse = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\r\n\t#endif\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\n\t#ifdef EMISSIVEUV1\r\n\t\tvUVEmissive = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\r\n\t#endif\r\n\t#ifdef EMISSIVEUV2\r\n\t\tvUVEmissive = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\r\n\t#endif\r\n#endif\r\n}",
glowMapMerge_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\n// Offset\r\nuniform float offset;\r\n\r\nvoid main(void) {\r\n\tvec4 baseColor = texture2D(textureSampler, vUV);\r\n\r\n\tbaseColor.a = abs(offset - baseColor.a);\r\n\r\n\tgl_FragColor = baseColor;\r\n}",
glowMapMerge_vertex: "﻿// Attributes\r\nattribute vec2 position;\r\n\r\n// Output\r\nvarying vec2 vUV;\r\n\r\nconst vec2 madd = vec2(0.5, 0.5);\r\n\r\nvoid main(void) {\r\n\tvUV = position * madd + madd;\r\n\tgl_Position = vec4(position, 0.0, 1.0);\r\n}",
hdr_fragment: "﻿uniform sampler2D textureSampler;\r\nvarying vec2 vUV;\r\n\r\n#if defined(GAUSSIAN_BLUR_H) || defined(GAUSSIAN_BLUR_V)\r\nuniform float blurOffsets[9];\r\nuniform float blurWeights[9];\r\nuniform float multiplier;\r\n\r\nvoid main(void) {\r\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\r\n\r\n\tfor (int i = 0; i < 9; i++) {\r\n\t\t#ifdef GAUSSIAN_BLUR_H\r\n\t\tcolor += (texture2D(textureSampler, vUV + vec2(blurOffsets[i] * multiplier, 0.0)) * blurWeights[i]);\r\n\t\t#else\r\n\t\tcolor += (texture2D(textureSampler, vUV + vec2(0.0, blurOffsets[i] * multiplier)) * blurWeights[i]);\r\n\t\t#endif\r\n\t}\r\n\r\n\tcolor.a = 1.0;\r\n\tgl_FragColor = color;\r\n}\r\n#endif\r\n\r\n#if defined(TEXTURE_ADDER)\r\nuniform sampler2D otherSampler;\r\n\r\nvoid main() {\r\n\tvec4 sum = texture2D(textureSampler, vUV) + texture2D(otherSampler, vUV);\r\n\tsum.a = clamp(sum.a, 0.0, 1.0);\r\n\r\n\tgl_FragColor = sum;\r\n}\r\n#endif\r\n\r\n#if defined(LUMINANCE_GENERATOR)\r\nuniform vec2 lumOffsets[4];\r\n\r\nvoid main() {\r\n\tfloat average = 0.0;\r\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\r\n\tfloat maximum = -1e20;\r\n\r\n\tfor (int i = 0; i < 4; i++) {\r\n\t\tcolor = texture2D(textureSampler, vUV + lumOffsets[i]);\r\n\r\n\t\tfloat GreyValue = length(color.rgb);\r\n\r\n\t\tmaximum = max(maximum, GreyValue);\r\n\t\taverage += (0.25 * log(1e-5 + GreyValue));\r\n\t}\r\n\r\n\taverage = exp(average);\r\n\r\n\tgl_FragColor = vec4(average, maximum, 0.0, 1.0);\r\n\r\n}\r\n#endif\r\n\r\n#if defined(DOWN_SAMPLE)\r\nuniform vec2 dsOffsets[9];\r\nuniform float halfDestPixelSize;\r\n\r\n#ifdef FINAL_DOWN_SAMPLE\r\nvec4 pack(float value) {\r\n\tconst vec4 bit_shift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\r\n\tconst vec4 bit_mask = vec4(0.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\r\n\r\n\tvec4 res = fract(value * bit_shift);\r\n\tres -= res.xxyz * bit_mask;\r\n\r\n\treturn res;\r\n}\r\n#endif\r\n\r\nvoid main() {\r\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\r\n\tfloat average = 0.0;\r\n\r\n\tfor (int i = 0; i < 9; i++) {\r\n\t\tcolor = texture2D(textureSampler, vUV + vec2(halfDestPixelSize, halfDestPixelSize) + dsOffsets[i]);\r\n\t\taverage += color.r;\r\n\t}\r\n\r\n\taverage /= 9.0;\r\n\r\n\t#ifndef FINAL_DOWN_SAMPLE\r\n\tgl_FragColor = vec4(average, average, 0.0, 1.0);\r\n\t#else\r\n\tgl_FragColor = pack(average);\r\n\t#endif\r\n}\r\n#endif\r\n\r\n#if defined(BRIGHT_PASS)\r\nuniform vec2 dsOffsets[4];\r\nuniform float brightThreshold;\r\n\r\nvoid main() {\r\n\tvec4 average = vec4(0.0, 0.0, 0.0, 0.0);\r\n\r\n\taverage = texture2D(textureSampler, vUV + vec2(dsOffsets[0].x, dsOffsets[0].y));\r\n\taverage += texture2D(textureSampler, vUV + vec2(dsOffsets[1].x, dsOffsets[1].y));\r\n\taverage += texture2D(textureSampler, vUV + vec2(dsOffsets[2].x, dsOffsets[2].y));\r\n\taverage += texture2D(textureSampler, vUV + vec2(dsOffsets[3].x, dsOffsets[3].y));\r\n\r\n\taverage *= 0.25;\r\n\r\n\tfloat luminance = length(average.rgb);\r\n\r\n\tif (luminance < brightThreshold) {\r\n\t\taverage = vec4(0.0, 0.0, 0.0, 1.0);\r\n\t}\r\n\r\n\tgl_FragColor = average;\r\n}\r\n#endif\r\n\r\n#if defined(DOWN_SAMPLE_X4)\r\nuniform vec2 dsOffsets[16];\r\n\r\nvoid main() {\r\n\tvec4 average = vec4(0.0, 0.0, 0.0, 0.0);\r\n\r\n\taverage = texture2D(textureSampler, vUV + dsOffsets[0]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[1]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[2]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[3]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[4]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[5]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[6]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[7]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[8]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[9]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[10]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[11]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[12]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[13]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[14]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[15]);\r\n\r\n\taverage /= 16.0;\r\n\r\n\tgl_FragColor = average;\r\n}\r\n#endif\r\n\r\n#if defined(HDR)\r\nuniform sampler2D otherSampler;\r\n\r\nuniform float exposure;\r\nuniform float avgLuminance;\r\n\r\nvoid main() {\r\n\tvec4 color = texture2D(textureSampler, vUV) + texture2D(otherSampler, vUV);\r\n\tvec4 adjustedColor = color / avgLuminance * exposure;\r\n\r\n\tcolor = adjustedColor;\r\n\tcolor.a = 1.0;\r\n\r\n\tgl_FragColor = color;\r\n}\r\n#endif\r\n",
layer_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\n// Color\r\nuniform vec4 color;\r\n\r\nvoid main(void) {\r\n\tvec4 baseColor = texture2D(textureSampler, vUV);\r\n\r\n#ifdef ALPHATEST\r\n\tif (baseColor.a < 0.4)\r\n\t\tdiscard;\r\n#endif\r\n\r\n\tgl_FragColor = baseColor * color;\r\n}",
layer_vertex: "﻿// Attributes\r\nattribute vec2 position;\r\n\r\n// Uniforms\r\nuniform vec2 scale;\r\nuniform vec2 offset;\r\nuniform mat4 textureMatrix;\r\n\r\n// Output\r\nvarying vec2 vUV;\r\n\r\nconst vec2 madd = vec2(0.5, 0.5);\r\n\r\nvoid main(void) {\t\r\n\tvec2 shiftedPosition = position * scale + offset;\r\n\tvUV = vec2(textureMatrix * vec4(shiftedPosition * madd + madd, 1.0, 0.0));\r\n\tgl_Position = vec4(shiftedPosition, 0.0, 1.0);\r\n}",
lensFlare_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\n// Color\r\nuniform vec4 color;\r\n\r\nvoid main(void) {\r\n\tvec4 baseColor = texture2D(textureSampler, vUV);\r\n\r\n\tgl_FragColor = baseColor * color;\r\n}",
lensFlare_vertex: "﻿// Attributes\r\nattribute vec2 position;\r\n\r\n// Uniforms\r\nuniform mat4 viewportMatrix;\r\n\r\n// Output\r\nvarying vec2 vUV;\r\n\r\nconst vec2 madd = vec2(0.5, 0.5);\r\n\r\nvoid main(void) {\t\r\n\r\n\tvUV = position * madd + madd;\r\n\tgl_Position = viewportMatrix * vec4(position, 0.0, 1.0);\r\n}",
lensHighlights_fragment: "// samplers\r\nuniform sampler2D textureSampler;\t// original color\r\n\r\n// uniforms\r\nuniform float gain;\r\nuniform float threshold;\r\nuniform float screen_width;\r\nuniform float screen_height;\r\n\r\n// varyings\r\nvarying vec2 vUV;\r\n\r\n// apply luminance filter\r\nvec4 highlightColor(vec4 color) {\r\n\tvec4 highlight = color;\r\n\tfloat luminance = dot(highlight.rgb, vec3(0.2125, 0.7154, 0.0721));\r\n\tfloat lum_threshold;\r\n\tif (threshold > 1.0) { lum_threshold = 0.94 + 0.01 * threshold; }\r\n\telse { lum_threshold = 0.5 + 0.44 * threshold; }\r\n\r\n\tluminance = clamp((luminance - lum_threshold) * (1.0 / (1.0 - lum_threshold)), 0.0, 1.0);\r\n\r\n\thighlight *= luminance * gain;\r\n\thighlight.a = 1.0;\r\n\r\n\treturn highlight;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\tvec4 original = texture2D(textureSampler, vUV);\r\n\r\n\t// quick exit if no highlight computing\r\n\tif (gain == -1.0) {\r\n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n\t\treturn;\r\n\t}\r\n\r\n\tfloat w = 2.0 / screen_width;\r\n\tfloat h = 2.0 / screen_height;\r\n\r\n\tfloat weight = 1.0;\r\n\r\n\t// compute blurred color\r\n\tvec4 blurred = vec4(0.0, 0.0, 0.0, 0.0);\r\n\r\n#ifdef PENTAGON\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.84*w, 0.43*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.48*w, -1.29*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.61*w, 1.51*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.55*w, -0.74*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.71*w, -0.52*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.94*w, 1.59*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.40*w, -1.87*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.62*w, 1.16*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.09*w, 0.25*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.46*w, -1.71*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.08*w, 2.42*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.85*w, -1.89*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.89*w, 0.16*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.29*w, 1.88*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.40*w, -2.81*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.54*w, 2.26*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.60*w, -0.61*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.31*w, -1.30*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.83*w, 2.53*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.12*w, -2.48*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.60*w, 1.11*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.82*w, 0.99*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.50*w, -2.81*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.85*w, 3.33*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.94*w, -1.92*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(3.27*w, -0.53*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.95*w, 2.48*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.23*w, -3.04*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.17*w, 2.05*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.97*w, -0.04*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.25*w, -2.00*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.31*w, 3.08*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.94*w, -2.59*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(3.37*w, 0.64*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-3.13*w, 1.93*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.03*w, -3.65*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.60*w, 3.17*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-3.14*w, -1.19*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(3.00*w, -1.19*h)));\r\n#else\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.85*w, 0.36*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.52*w, -1.14*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.46*w, 1.42*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.46*w, -0.83*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.79*w, -0.42*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.11*w, 1.62*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.29*w, -2.07*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.69*w, 1.39*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.28*w, 0.12*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.65*w, -1.69*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.08*w, 2.44*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.63*w, -1.90*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.55*w, 0.31*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.13*w, 1.52*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.56*w, -2.61*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.38*w, 2.34*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.64*w, -0.81*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.53*w, -1.21*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.06*w, 2.63*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.00*w, -2.69*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.59*w, 1.32*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.82*w, 0.78*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.57*w, -2.50*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(0.54*w, 2.93*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.39*w, -1.81*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(3.01*w, -0.28*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.04*w, 2.25*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.02*w, -3.05*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.09*w, 2.25*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-3.07*w, -0.25*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.44*w, -1.90*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-0.52*w, 3.05*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-1.68*w, -2.61*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(3.01*w, 0.79*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.76*w, 1.46*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.05*w, -2.94*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(1.21*w, 2.88*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(-2.84*w, -1.30*h)));\r\n\t\tblurred += highlightColor(texture2D(textureSampler, vUV + vec2(2.98*w, -0.96*h)));\r\n#endif\r\n\r\n\tblurred /= 39.0;\r\n\r\n\tgl_FragColor = blurred;\r\n\r\n\t//if(vUV.x > 0.5) { gl_FragColor.rgb *= 0.0; }\r\n}",
line_fragment: "﻿uniform vec4 color;\r\n\r\nvoid main(void) {\r\n\tgl_FragColor = color;\r\n}",
line_vertex: "﻿// Attributes\r\nattribute vec3 position;\r\nattribute vec4 normal;\r\n\r\n// Uniforms\r\nuniform mat4 worldViewProjection;\r\n\r\nuniform float width;\r\nuniform float aspectRatio;\r\n\r\nvoid main(void) {\r\n\tvec4 viewPosition = worldViewProjection * vec4(position, 1.0);\r\n\tvec4 viewPositionNext = worldViewProjection * vec4(normal.xyz, 1.0);\r\n\r\n\tvec2 currentScreen = viewPosition.xy / viewPosition.w;\r\n\tvec2 nextScreen = viewPositionNext.xy / viewPositionNext.w;\r\n\r\n\tcurrentScreen.x *= aspectRatio;\r\n\tnextScreen.x *= aspectRatio;\r\n\r\n\tvec2 dir = normalize(nextScreen - currentScreen);\r\n\tvec2 normalDir = vec2(-dir.y, dir.x);\r\n\r\n\tnormalDir *= width / 2.0;\r\n\tnormalDir.x /= aspectRatio;\r\n\r\n\tvec4 offset = vec4(normalDir * normal.w, 0.0, 0.0);\r\n\tgl_Position = viewPosition + offset;\r\n}",
outline_fragment: "﻿uniform vec4 color;\r\n\r\n#ifdef ALPHATEST\r\nvarying vec2 vUV;\r\nuniform sampler2D diffuseSampler;\r\n#endif\r\n\r\nvoid main(void) {\r\n#ifdef ALPHATEST\r\n\tif (texture2D(diffuseSampler, vUV).a < 0.4)\r\n\t\tdiscard;\r\n#endif\r\n\r\n\tgl_FragColor = color;\r\n}",
outline_vertex: "﻿// Attribute\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\n\r\n#include<bonesDeclaration>\r\n\r\n// Uniform\r\nuniform float offset;\r\n\r\n#include<instancesDeclaration>\r\n\r\nuniform mat4 viewProjection;\r\n\r\n#ifdef ALPHATEST\r\nvarying vec2 vUV;\r\nuniform mat4 diffuseMatrix;\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n#endif\r\n\r\nvoid main(void)\r\n{\r\n\tvec3 offsetPosition = position + normal * offset;\r\n\r\n#include<instancesVertex>\r\n#include<bonesVertex>\r\n\r\n\tgl_Position = viewProjection * finalWorld * vec4(offsetPosition, 1.0);\r\n\r\n#ifdef ALPHATEST\r\n#ifdef UV1\r\n\tvUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\r\n#endif\r\n#ifdef UV2\r\n\tvUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\r\n#endif\r\n#endif\r\n}\r\n",
particles_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nvarying vec4 vColor;\r\nuniform vec4 textureMask;\r\nuniform sampler2D diffuseSampler;\r\n\r\n#ifdef CLIPPLANE\r\nvarying float fClipDistance;\r\n#endif\r\n\r\nvoid main(void) {\r\n#ifdef CLIPPLANE\r\n\tif (fClipDistance > 0.0)\r\n\t\tdiscard;\r\n#endif\r\n\tvec4 baseColor = texture2D(diffuseSampler, vUV);\r\n\r\n\tgl_FragColor = (baseColor * textureMask + (vec4(1., 1., 1., 1.) - textureMask)) * vColor;\r\n}",
particles_vertex: "﻿// Attributes\r\nattribute vec3 position;\r\nattribute vec4 color;\r\nattribute vec4 options;\r\n\r\n// Uniforms\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\n// Output\r\nvarying vec2 vUV;\r\nvarying vec4 vColor;\r\n\r\n#ifdef CLIPPLANE\r\nuniform vec4 vClipPlane;\r\nuniform mat4 invView;\r\nvarying float fClipDistance;\r\n#endif\r\n\r\nvoid main(void) {\t\r\n\tvec3 viewPos = (view * vec4(position, 1.0)).xyz; \r\n\tvec3 cornerPos;\r\n\tfloat size = options.y;\r\n\tfloat angle = options.x;\r\n\tvec2 offset = options.zw;\r\n\r\n\tcornerPos = vec3(offset.x - 0.5, offset.y  - 0.5, 0.) * size;\r\n\r\n\t// Rotate\r\n\tvec3 rotatedCorner;\r\n\trotatedCorner.x = cornerPos.x * cos(angle) - cornerPos.y * sin(angle);\r\n\trotatedCorner.y = cornerPos.x * sin(angle) + cornerPos.y * cos(angle);\r\n\trotatedCorner.z = 0.;\r\n\r\n\t// Position\r\n\tviewPos += rotatedCorner;\r\n\tgl_Position = projection * vec4(viewPos, 1.0);   \r\n\t\r\n\tvColor = color;\r\n\tvUV = offset;\r\n\r\n\t// Clip plane\r\n#ifdef CLIPPLANE\r\n\tvec4 worldPos = invView * vec4(viewPos, 1.0);\r\n\tfClipDistance = dot(worldPos, vClipPlane);\r\n#endif\r\n}",
pass_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\nvoid main(void) \r\n{\r\n\tgl_FragColor = texture2D(textureSampler, vUV);\r\n}",
pbr_fragment: "﻿#ifdef BUMP\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\n#ifdef LODBASEDMICROSFURACE\r\n#extension GL_EXT_shader_texture_lod : enable\r\n#endif\r\n\r\n#ifdef LOGARITHMICDEPTH\r\n#extension GL_EXT_frag_depth : enable\r\n#endif\r\n\r\nprecision highp float;\r\n\r\nuniform vec3 vEyePosition;\r\nuniform vec3 vAmbientColor;\r\nuniform vec3 vReflectionColor;\r\nuniform vec4 vAlbedoColor;\r\n\r\n// CUSTOM CONTROLS\r\nuniform vec4 vLightingIntensity;\r\nuniform vec4 vCameraInfos;\r\n\r\n#ifdef OVERLOADEDVALUES\r\nuniform vec4 vOverloadedIntensity;\r\nuniform vec3 vOverloadedAmbient;\r\nuniform vec3 vOverloadedAlbedo;\r\nuniform vec3 vOverloadedReflectivity;\r\nuniform vec3 vOverloadedEmissive;\r\nuniform vec3 vOverloadedReflection;\r\nuniform vec3 vOverloadedMicroSurface;\r\n#endif\r\n\r\n#ifdef OVERLOADEDSHADOWVALUES\r\nuniform vec4 vOverloadedShadowIntensity;\r\n#endif\r\n\r\n#if defined(REFLECTION) || defined(REFRACTION)\r\nuniform vec2 vMicrosurfaceTextureLods;\r\n#endif\r\n\r\nuniform vec4 vReflectivityColor;\r\nuniform vec3 vEmissiveColor;\r\n\r\n// Input\r\nvarying vec3 vPositionW;\r\n\r\n#ifdef NORMAL\r\nvarying vec3 vNormalW;\r\n#endif\r\n\r\n#ifdef VERTEXCOLOR\r\nvarying vec4 vColor;\r\n#endif\r\n\r\n// Lights\r\n#include<lightFragmentDeclaration>[0..maxSimultaneousLights]\r\n\r\n// Samplers\r\n#ifdef ALBEDO\r\nvarying vec2 vAlbedoUV;\r\nuniform sampler2D albedoSampler;\r\nuniform vec2 vAlbedoInfos;\r\n#endif\r\n\r\n#ifdef AMBIENT\r\nvarying vec2 vAmbientUV;\r\nuniform sampler2D ambientSampler;\r\nuniform vec3 vAmbientInfos;\r\n#endif\r\n\r\n#ifdef OPACITY\t\r\nvarying vec2 vOpacityUV;\r\nuniform sampler2D opacitySampler;\r\nuniform vec2 vOpacityInfos;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nvarying vec2 vEmissiveUV;\r\nuniform vec2 vEmissiveInfos;\r\nuniform sampler2D emissiveSampler;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\nvarying vec2 vLightmapUV;\r\nuniform vec2 vLightmapInfos;\r\nuniform sampler2D lightmapSampler;\r\n#endif\r\n\r\n#if defined(REFLECTIVITY) || defined(METALLICWORKFLOW) \r\nvarying vec2 vReflectivityUV;\r\nuniform vec2 vReflectivityInfos;\r\nuniform sampler2D reflectivitySampler;\r\n#endif\r\n\r\n// Fresnel\r\n#include<fresnelFunction>\r\n\r\n#ifdef OPACITYFRESNEL\r\nuniform vec4 opacityParts;\r\n#endif\r\n\r\n#ifdef EMISSIVEFRESNEL\r\nuniform vec4 emissiveLeftColor;\r\nuniform vec4 emissiveRightColor;\r\n#endif\r\n\r\n// Refraction Reflection\r\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\r\nuniform mat4 view;\r\n#endif\r\n\r\n// Refraction\r\n#ifdef REFRACTION\r\nuniform vec4 vRefractionInfos;\r\n\r\n#ifdef REFRACTIONMAP_3D\r\nuniform samplerCube refractionCubeSampler;\r\n#else\r\nuniform sampler2D refraction2DSampler;\r\nuniform mat4 refractionMatrix;\r\n#endif\r\n#endif\r\n\r\n// Reflection\r\n#ifdef REFLECTION\r\nuniform vec2 vReflectionInfos;\r\n\r\n#ifdef REFLECTIONMAP_3D\r\nuniform samplerCube reflectionCubeSampler;\r\n#else\r\nuniform sampler2D reflection2DSampler;\r\n#endif\r\n\r\n#ifdef REFLECTIONMAP_SKYBOX\r\nvarying vec3 vPositionUVW;\r\n#else\r\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\r\nvarying vec3 vDirectionW;\r\n#endif\r\n\r\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION)\r\nuniform mat4 reflectionMatrix;\r\n#endif\r\n#endif\r\n\r\n#include<reflectionFunction>\r\n\r\n#endif\r\n\r\n#ifdef CAMERACOLORGRADING\r\n\t#include<colorGradingDefinition>\r\n#endif\r\n\r\n#ifdef CAMERACOLORCURVES\r\n\t#include<colorCurvesDefinition>\r\n#endif\r\n\r\n// PBR\r\n#include<pbrShadowFunctions>\r\n#include<pbrFunctions>\r\n\r\n#ifdef CAMERACOLORGRADING\r\n\t#include<colorGrading>\r\n#endif\r\n\r\n#ifdef CAMERACOLORCURVES\r\n\t#include<colorCurves>\r\n#endif\r\n\r\n#include<harmonicsFunctions>\r\n#include<pbrLightFunctions>\r\n\r\n#include<helperFunctions>\r\n#include<bumpFragmentFunctions>\r\n#include<clipPlaneFragmentDeclaration>\r\n#include<logDepthDeclaration>\r\n\r\n// Fog\r\n#include<fogFragmentDeclaration>\r\n\r\nvoid main(void) {\r\n#include<clipPlaneFragment>\r\n\r\n\tvec3 viewDirectionW = normalize(vEyePosition - vPositionW);\r\n\r\n\t// Bump\r\n\t#ifdef NORMAL\r\n\t\tvec3 normalW = normalize(vNormalW);\r\n\t#else\r\n\t\tvec3 normalW = vec3(1.0, 1.0, 1.0);\r\n\t#endif\r\n\r\n\t#include<bumpFragment>\r\n\r\n\t// Albedo\r\n\tvec4 surfaceAlbedo = vec4(1., 1., 1., 1.);\r\n\tvec3 surfaceAlbedoContribution = vAlbedoColor.rgb;\r\n\r\n\t// Alpha\r\n\tfloat alpha = vAlbedoColor.a;\r\n\r\n#ifdef ALBEDO\r\n\tsurfaceAlbedo = texture2D(albedoSampler, vAlbedoUV + uvOffset);\r\n\tsurfaceAlbedo = vec4(toLinearSpace(surfaceAlbedo.rgb), surfaceAlbedo.a);\r\n\r\n#ifndef LINKREFRACTIONTOTRANSPARENCY\r\n#ifdef ALPHATEST\r\n\tif (surfaceAlbedo.a < 0.4)\r\n\t\tdiscard;\r\n#endif\r\n#endif\r\n\r\n#ifdef ALPHAFROMALBEDO\r\n\talpha *= surfaceAlbedo.a;\r\n#endif\r\n\r\n\tsurfaceAlbedo.rgb *= vAlbedoInfos.y;\r\n#else\r\n\t// No Albedo texture.\r\n\tsurfaceAlbedo.rgb = surfaceAlbedoContribution;\r\n\tsurfaceAlbedoContribution = vec3(1., 1., 1.);\r\n#endif\r\n\r\n#ifdef VERTEXCOLOR\r\n\tsurfaceAlbedo.rgb *= vColor.rgb;\r\n#endif\r\n\r\n#ifdef OVERLOADEDVALUES\r\n\tsurfaceAlbedo.rgb = mix(surfaceAlbedo.rgb, vOverloadedAlbedo, vOverloadedIntensity.y);\r\n#endif\r\n\r\n\t// Ambient color\r\n\tvec3 ambientColor = vec3(1., 1., 1.);\r\n\r\n#ifdef AMBIENT\r\n\tambientColor = texture2D(ambientSampler, vAmbientUV + uvOffset).rgb * vAmbientInfos.y;\r\n\tambientColor = vec3(1., 1., 1.) - ((vec3(1., 1., 1.) - ambientColor) * vAmbientInfos.z);\r\n\r\n#ifdef OVERLOADEDVALUES\r\n\tambientColor.rgb = mix(ambientColor.rgb, vOverloadedAmbient, vOverloadedIntensity.x);\r\n#endif\r\n#endif\r\n\r\n\t// Reflectivity map\r\n\tfloat microSurface = vReflectivityColor.a;\r\n\tvec3 surfaceReflectivityColor = vReflectivityColor.rgb;\r\n\r\n#ifdef OVERLOADEDVALUES\r\n\tsurfaceReflectivityColor.rgb = mix(surfaceReflectivityColor.rgb, vOverloadedReflectivity, vOverloadedIntensity.z);\r\n#endif\r\n\r\n#ifdef REFLECTIVITY\r\n\tvec4 surfaceReflectivityColorMap = texture2D(reflectivitySampler, vReflectivityUV + uvOffset);\r\n\tsurfaceReflectivityColor = surfaceReflectivityColorMap.rgb;\r\n\tsurfaceReflectivityColor = toLinearSpace(surfaceReflectivityColor);\r\n\r\n\t#ifdef OVERLOADEDVALUES\r\n\t\tsurfaceReflectivityColor = mix(surfaceReflectivityColor, vOverloadedReflectivity, vOverloadedIntensity.z);\r\n\t#endif\r\n\r\n\t#ifdef MICROSURFACEFROMREFLECTIVITYMAP\r\n\t\tmicroSurface = surfaceReflectivityColorMap.a;\r\n\t#else\r\n\t\t#ifdef MICROSURFACEAUTOMATIC\r\n\t\t\tmicroSurface = computeDefaultMicroSurface(microSurface, surfaceReflectivityColor);\r\n\t\t#endif\r\n\t#endif\r\n#endif\r\n\r\n#ifdef METALLICWORKFLOW\r\n\tvec4 surfaceMetallicColorMap = texture2D(reflectivitySampler, vReflectivityUV + uvOffset);\r\n\r\n\t// No gamma space fro the metallic map in metallic workflow.\r\n\tfloat metallic = surfaceMetallicColorMap.r; // Unity like base channel for metallness.\r\n\r\n\t// Diffuse is used as the base of the reflectivity.\r\n\tvec3 baseColor = surfaceAlbedo.rgb;\r\n\r\n\t// Drop the surface diffuse by the 1.0 - metalness.\r\n\tsurfaceAlbedo.rgb *= (1.0 - metallic);\r\n\t\r\n\t// Default specular reflectance at normal incidence.\r\n\t// 4% corresponds to index of refraction (IOR) of 1.50, approximately equal to glass.    \r\n\tconst vec3 DefaultSpecularReflectanceDielectric = vec3(0.04, 0.04, 0.04);\r\n\r\n\t// Compute the converted reflectivity.\r\n\tsurfaceReflectivityColor = mix(DefaultSpecularReflectanceDielectric, baseColor, metallic);\r\n\r\n\t#ifdef OVERLOADEDVALUES\r\n\t\tsurfaceReflectivityColor = mix(surfaceReflectivityColor, vOverloadedReflectivity, vOverloadedIntensity.z);\r\n\t#endif\r\n\r\n\t#ifdef METALLICROUGHNESSGSTOREINALPHA\r\n\t\tmicroSurface = 1.0 - surfaceMetallicColorMap.a;\r\n\t#else\r\n\t\t#ifdef METALLICROUGHNESSGSTOREINGREEN\r\n\t\t\tmicroSurface = 1.0 - surfaceMetallicColorMap.g;\r\n\t\t#endif\r\n\t#endif\r\n#endif\r\n\r\n#ifdef OVERLOADEDVALUES\r\n\tmicroSurface = mix(microSurface, vOverloadedMicroSurface.x, vOverloadedMicroSurface.y);\r\n#endif\r\n\r\n\t// Compute N dot V.\r\n\tfloat NdotV = max(0.00000000001, dot(normalW, viewDirectionW));\r\n\r\n\t// Adapt microSurface.\r\n\tmicroSurface = clamp(microSurface, 0., 1.) * 0.98;\r\n\r\n\t// Compute roughness.\r\n\tfloat roughness = clamp(1. - microSurface, 0.000001, 1.0);\r\n\r\n\t// Lighting\r\n\tvec3 lightDiffuseContribution = vec3(0., 0., 0.);\r\n\r\n#ifdef OVERLOADEDSHADOWVALUES\r\n\tvec3 shadowedOnlyLightDiffuseContribution = vec3(1., 1., 1.);\r\n#endif\r\n\r\n#ifdef SPECULARTERM\r\n\tvec3 lightSpecularContribution = vec3(0., 0., 0.);\r\n#endif\r\n\t\r\n\tfloat notShadowLevel = 1.; // 1 - shadowLevel\r\n\r\n\t#ifdef LIGHTMAP\r\n  \t\tvec3 lightmapColor = texture2D(lightmapSampler, vLightmapUV + uvOffset).rgb * vLightmapInfos.y;\r\n  \t#endif\r\n\r\n\tfloat NdotL = -1.;\r\n\tlightingInfo info;\r\n\r\n\t// Compute reflectance.\r\n\tfloat reflectance = max(max(surfaceReflectivityColor.r, surfaceReflectivityColor.g), surfaceReflectivityColor.b);\r\n\r\n\t// For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.\r\n    // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.\r\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\r\n\tvec3 specularEnvironmentR0 = surfaceReflectivityColor.rgb;\r\n\tvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\r\n\r\n#include<pbrLightFunctionsCall>[0..maxSimultaneousLights]\r\n\r\n#ifdef SPECULARTERM\r\n\tlightSpecularContribution *= vLightingIntensity.w;\r\n#endif\r\n\r\n#ifdef OPACITY\r\n\tvec4 opacityMap = texture2D(opacitySampler, vOpacityUV + uvOffset);\r\n\r\n#ifdef OPACITYRGB\r\n\topacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11);\r\n\talpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\r\n#else\r\n\talpha *= opacityMap.a * vOpacityInfos.y;\r\n#endif\r\n\r\n#endif\r\n\r\n#ifdef VERTEXALPHA\r\n\talpha *= vColor.a;\r\n#endif\r\n\r\n#ifdef OPACITYFRESNEL\r\n\tfloat opacityFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, opacityParts.z, opacityParts.w);\r\n\r\n\talpha += opacityParts.x * (1.0 - opacityFresnelTerm) + opacityFresnelTerm * opacityParts.y;\r\n#endif\r\n\r\n\t// Refraction\r\n\tvec3 surfaceRefractionColor = vec3(0., 0., 0.);\r\n\r\n\t// Go mat -> blurry reflexion according to microSurface\r\n#ifdef LODBASEDMICROSFURACE\r\n\tfloat alphaG = convertRoughnessToAverageSlope(roughness);\r\n#endif\r\n\r\n#ifdef REFRACTION\r\n\tvec3 refractionVector = refract(-viewDirectionW, normalW, vRefractionInfos.y);\r\n\r\n#ifdef LODBASEDMICROSFURACE\r\n#ifdef USEPMREMREFRACTION\r\n\tfloat lodRefraction = getMipMapIndexFromAverageSlopeWithPMREM(vMicrosurfaceTextureLods.y, alphaG);\r\n#else\r\n\tfloat lodRefraction = getMipMapIndexFromAverageSlope(vMicrosurfaceTextureLods.y, alphaG);\r\n#endif\r\n#else\r\n\tfloat biasRefraction = (vMicrosurfaceTextureLods.y + 2.) * (1.0 - microSurface);\r\n#endif\r\n\r\n#ifdef REFRACTIONMAP_3D\r\n\trefractionVector.y = refractionVector.y * vRefractionInfos.w;\r\n\r\n\tif (dot(refractionVector, viewDirectionW) < 1.0)\r\n\t{\r\n#ifdef LODBASEDMICROSFURACE\r\n#ifdef USEPMREMREFRACTION\r\n\t\t// Empiric Threshold\r\n\t\tif ((vMicrosurfaceTextureLods.y - lodRefraction) > 4.0)\r\n\t\t{\r\n\t\t\t// Bend to not reach edges.\r\n\t\t\tfloat scaleRefraction = 1. - exp2(lodRefraction) / exp2(vMicrosurfaceTextureLods.y); // CubemapSize is the size of the base mipmap\r\n\t\t\tfloat maxRefraction = max(max(abs(refractionVector.x), abs(refractionVector.y)), abs(refractionVector.z));\r\n\t\t\tif (abs(refractionVector.x) != maxRefraction) refractionVector.x *= scaleRefraction;\r\n\t\t\tif (abs(refractionVector.y) != maxRefraction) refractionVector.y *= scaleRefraction;\r\n\t\t\tif (abs(refractionVector.z) != maxRefraction) refractionVector.z *= scaleRefraction;\r\n\t\t}\r\n#endif\r\n\r\n\t\tsurfaceRefractionColor = textureCubeLodEXT(refractionCubeSampler, refractionVector, lodRefraction).rgb * vRefractionInfos.x;\r\n#else\r\n\t\tsurfaceRefractionColor = textureCube(refractionCubeSampler, refractionVector, biasRefraction).rgb * vRefractionInfos.x;\r\n#endif\r\n\t}\r\n\r\n#ifndef REFRACTIONMAPINLINEARSPACE\r\n\tsurfaceRefractionColor = toLinearSpace(surfaceRefractionColor.rgb);\r\n#endif\r\n#else\r\n\tvec3 vRefractionUVW = vec3(refractionMatrix * (view * vec4(vPositionW + refractionVector * vRefractionInfos.z, 1.0)));\r\n\r\n\tvec2 refractionCoords = vRefractionUVW.xy / vRefractionUVW.z;\r\n\r\n\trefractionCoords.y = 1.0 - refractionCoords.y;\r\n\r\n#ifdef LODBASEDMICROSFURACE\r\n\tsurfaceRefractionColor = texture2DLodEXT(refraction2DSampler, refractionCoords, lodRefraction).rgb * vRefractionInfos.x;\r\n#else\r\n\tsurfaceRefractionColor = texture2D(refraction2DSampler, refractionCoords, biasRefraction).rgb * vRefractionInfos.x;\r\n#endif    \r\n\r\n\tsurfaceRefractionColor = toLinearSpace(surfaceRefractionColor.rgb);\r\n#endif\r\n#endif\r\n\r\n\t// Reflection\r\n\tvec3 environmentRadiance = vReflectionColor.rgb;\r\n\tvec3 environmentIrradiance = vReflectionColor.rgb;\r\n\r\n#ifdef REFLECTION\r\n\tvec3 vReflectionUVW = computeReflectionCoords(vec4(vPositionW, 1.0), normalW);\r\n\r\n#ifdef LODBASEDMICROSFURACE\r\n#ifdef USEPMREMREFLECTION\r\n\tfloat lodReflection = getMipMapIndexFromAverageSlopeWithPMREM(vMicrosurfaceTextureLods.x, alphaG);\r\n#else\r\n\tfloat lodReflection = getMipMapIndexFromAverageSlope(vMicrosurfaceTextureLods.x, alphaG);\r\n#endif\r\n#else\r\n\tfloat biasReflection = (vMicrosurfaceTextureLods.x + 2.) * (1.0 - microSurface);\r\n#endif\r\n\r\n#ifdef REFLECTIONMAP_3D\r\n\r\n#ifdef LODBASEDMICROSFURACE\r\n#ifdef USEPMREMREFLECTION\r\n\t// Empiric Threshold\r\n\tif ((vMicrosurfaceTextureLods.y - lodReflection) > 4.0)\r\n\t{\r\n\t\t// Bend to not reach edges.\r\n\t\tfloat scaleReflection = 1. - exp2(lodReflection) / exp2(vMicrosurfaceTextureLods.x); // CubemapSize is the size of the base mipmap\r\n\t\tfloat maxReflection = max(max(abs(vReflectionUVW.x), abs(vReflectionUVW.y)), abs(vReflectionUVW.z));\r\n\t\tif (abs(vReflectionUVW.x) != maxReflection) vReflectionUVW.x *= scaleReflection;\r\n\t\tif (abs(vReflectionUVW.y) != maxReflection) vReflectionUVW.y *= scaleReflection;\r\n\t\tif (abs(vReflectionUVW.z) != maxReflection) vReflectionUVW.z *= scaleReflection;\r\n\t}\r\n#endif\r\n\r\n\tenvironmentRadiance = textureCubeLodEXT(reflectionCubeSampler, vReflectionUVW, lodReflection).rgb * vReflectionInfos.x;\r\n#else\r\n\tenvironmentRadiance = textureCube(reflectionCubeSampler, vReflectionUVW, biasReflection).rgb * vReflectionInfos.x;\r\n#endif\r\n\r\n#ifdef USESPHERICALFROMREFLECTIONMAP\r\n#ifndef REFLECTIONMAP_SKYBOX\r\n\tvec3 normalEnvironmentSpace = (reflectionMatrix * vec4(normalW, 1)).xyz;\r\n\tenvironmentIrradiance = EnvironmentIrradiance(normalEnvironmentSpace);\r\n#endif\r\n#else\r\n\tenvironmentRadiance = toLinearSpace(environmentRadiance.rgb);\r\n\r\n\tenvironmentIrradiance = textureCube(reflectionCubeSampler, normalW, 20.).rgb * vReflectionInfos.x;\r\n\tenvironmentIrradiance = toLinearSpace(environmentIrradiance.rgb);\r\n\tenvironmentIrradiance *= 0.2; // Hack in case of no hdr cube map use for environment.\r\n#endif\r\n#else\r\n\tvec2 coords = vReflectionUVW.xy;\r\n\r\n#ifdef REFLECTIONMAP_PROJECTION\r\n\tcoords /= vReflectionUVW.z;\r\n#endif\r\n\r\n\tcoords.y = 1.0 - coords.y;\r\n#ifdef LODBASEDMICROSFURACE\r\n\tenvironmentRadiance = texture2DLodEXT(reflection2DSampler, coords, lodReflection).rgb * vReflectionInfos.x;\r\n#else\r\n\tenvironmentRadiance = texture2D(reflection2DSampler, coords, biasReflection).rgb * vReflectionInfos.x;\r\n#endif\r\n\r\n\tenvironmentRadiance = toLinearSpace(environmentRadiance.rgb);\r\n\r\n\tenvironmentIrradiance = texture2D(reflection2DSampler, coords, 20.).rgb * vReflectionInfos.x;\r\n\tenvironmentIrradiance = toLinearSpace(environmentIrradiance.rgb);\r\n#endif\r\n#endif\r\n\r\n#ifdef OVERLOADEDVALUES\r\n\tenvironmentIrradiance = mix(environmentIrradiance, vOverloadedReflection, vOverloadedMicroSurface.z);\r\n\tenvironmentRadiance = mix(environmentRadiance, vOverloadedReflection, vOverloadedMicroSurface.z);\r\n#endif\r\n\r\n\tenvironmentRadiance *= vLightingIntensity.z;\r\n\tenvironmentIrradiance *= vLightingIntensity.z;\r\n\r\n\t// Specular Environment Fresnel.\r\n\tvec3 specularEnvironmentReflectance = FresnelSchlickEnvironmentGGX(clamp(NdotV, 0., 1.), specularEnvironmentR0, specularEnvironmentR90, sqrt(microSurface));\r\n\r\n\t// Compute refractance\r\n\tvec3 refractance = vec3(0.0, 0.0, 0.0);\r\n\r\n#ifdef REFRACTION\r\n\tvec3 transmission = vec3(1.0, 1.0, 1.0);\r\n\t#ifdef LINKREFRACTIONTOTRANSPARENCY\r\n\t\t// Transmission based on alpha.\r\n\t\ttransmission *= (1.0 - alpha);\r\n\r\n\t\t// Tint the material with albedo.\r\n\t\t// TODO. PBR Tinting.\r\n\t\tvec3 mixedAlbedo = surfaceAlbedoContribution.rgb * surfaceAlbedo.rgb;\r\n\t\tfloat maxChannel = max(max(mixedAlbedo.r, mixedAlbedo.g), mixedAlbedo.b);\r\n\t\tvec3 tint = clamp(maxChannel * mixedAlbedo, 0.0, 1.0);\r\n\r\n\t\t// Decrease Albedo Contribution\r\n\t\tsurfaceAlbedoContribution *= alpha;\r\n\r\n\t\t// Decrease irradiance Contribution\r\n\t\tenvironmentIrradiance *= alpha;\r\n\r\n\t\t// Tint reflectance\r\n\t\tsurfaceRefractionColor *= tint;\r\n\r\n\t\t// Put alpha back to 1;\r\n\t\talpha = 1.0;\r\n\t#endif\r\n\r\n\t// Add Multiple internal bounces.\r\n\tvec3 bounceSpecularEnvironmentReflectance = (2.0 * specularEnvironmentReflectance) / (1.0 + specularEnvironmentReflectance);\r\n\tspecularEnvironmentReflectance = mix(bounceSpecularEnvironmentReflectance, specularEnvironmentReflectance, alpha);\r\n\r\n\t// In theory T = 1 - R.\r\n\ttransmission *= 1.0 - specularEnvironmentReflectance;\r\n\r\n\t// Should baked in diffuse.\r\n\trefractance = surfaceRefractionColor * transmission;\r\n#endif\r\n\r\n\t// Apply Energy Conservation taking in account the environment level only if the environment is present.\r\n\tsurfaceAlbedo.rgb = (1. - reflectance) * surfaceAlbedo.rgb;\r\n\r\n\trefractance *= vLightingIntensity.z;\r\n\tenvironmentRadiance *= specularEnvironmentReflectance;\r\n\r\n\t// Emissive\r\n\tvec3 surfaceEmissiveColor = vEmissiveColor;\r\n#ifdef EMISSIVE\r\n\tvec3 emissiveColorTex = texture2D(emissiveSampler, vEmissiveUV + uvOffset).rgb;\r\n\tsurfaceEmissiveColor = toLinearSpace(emissiveColorTex.rgb) * surfaceEmissiveColor * vEmissiveInfos.y;\r\n#endif\r\n\r\n#ifdef OVERLOADEDVALUES\r\n\tsurfaceEmissiveColor = mix(surfaceEmissiveColor, vOverloadedEmissive, vOverloadedIntensity.w);\r\n#endif\r\n\r\n#ifdef EMISSIVEFRESNEL\r\n\tfloat emissiveFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, emissiveRightColor.a, emissiveLeftColor.a);\r\n\r\n\tsurfaceEmissiveColor *= emissiveLeftColor.rgb * (1.0 - emissiveFresnelTerm) + emissiveFresnelTerm * emissiveRightColor.rgb;\r\n#endif\r\n\r\n\t// Composition\r\n#ifdef EMISSIVEASILLUMINATION\r\n\tvec3 finalDiffuse = max(lightDiffuseContribution * surfaceAlbedoContribution + vAmbientColor, 0.0) * surfaceAlbedo.rgb;\r\n\r\n#ifdef OVERLOADEDSHADOWVALUES\r\n\tshadowedOnlyLightDiffuseContribution = max(shadowedOnlyLightDiffuseContribution * surfaceAlbedoContribution + vAmbientColor, 0.0) * surfaceAlbedo.rgb;\r\n#endif\r\n#else\r\n#ifdef LINKEMISSIVEWITHALBEDO\r\n\tvec3 finalDiffuse = max((lightDiffuseContribution + surfaceEmissiveColor) * surfaceAlbedoContribution + vAmbientColor, 0.0) * surfaceAlbedo.rgb;\r\n\r\n#ifdef OVERLOADEDSHADOWVALUES\r\n\tshadowedOnlyLightDiffuseContribution = max((shadowedOnlyLightDiffuseContribution + surfaceEmissiveColor) * surfaceAlbedoContribution + vAmbientColor, 0.0) * surfaceAlbedo.rgb;\r\n#endif\r\n#else\r\n\tvec3 finalDiffuse = max(lightDiffuseContribution * surfaceAlbedoContribution + surfaceEmissiveColor + vAmbientColor, 0.0) * surfaceAlbedo.rgb;\r\n\r\n#ifdef OVERLOADEDSHADOWVALUES\r\n\tshadowedOnlyLightDiffuseContribution = max(shadowedOnlyLightDiffuseContribution * surfaceAlbedoContribution + surfaceEmissiveColor + vAmbientColor, 0.0) * surfaceAlbedo.rgb;\r\n#endif\r\n#endif\r\n#endif\r\n\r\n#ifdef OVERLOADEDSHADOWVALUES\r\n\tfinalDiffuse = mix(finalDiffuse, shadowedOnlyLightDiffuseContribution, (1.0 - vOverloadedShadowIntensity.y));\r\n#endif\r\n\r\n#ifdef SPECULARTERM\r\n\tvec3 finalSpecular = lightSpecularContribution * surfaceReflectivityColor;\r\n#else\r\n\tvec3 finalSpecular = vec3(0.0);\r\n#endif\r\n\r\n#ifdef SPECULAROVERALPHA\r\n\talpha = clamp(alpha + getLuminance(finalSpecular), 0., 1.);\r\n#endif\r\n\r\n#ifdef RADIANCEOVERALPHA\r\n\talpha = clamp(alpha + getLuminance(environmentRadiance), 0., 1.);\r\n#endif\r\n\r\n\t// Composition\r\n\t// Reflection already includes the environment intensity.\r\n#ifdef EMISSIVEASILLUMINATION\r\n\tvec4 finalColor = vec4(finalDiffuse * ambientColor * vLightingIntensity.x + surfaceAlbedo.rgb * environmentIrradiance + finalSpecular * vLightingIntensity.x + environmentRadiance + surfaceEmissiveColor * vLightingIntensity.y + refractance, alpha);\r\n#else\r\n\tvec4 finalColor = vec4(finalDiffuse * ambientColor * vLightingIntensity.x + surfaceAlbedo.rgb * environmentIrradiance + finalSpecular * vLightingIntensity.x + environmentRadiance + refractance, alpha);\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n    #ifndef LIGHTMAPEXCLUDED\r\n        #ifdef USELIGHTMAPASSHADOWMAP\r\n            finalColor.rgb *= lightmapColor;\r\n        #else\r\n            finalColor.rgb += lightmapColor;\r\n        #endif\r\n    #endif\r\n#endif\r\n\r\n\tfinalColor = max(finalColor, 0.0);\r\n\r\n#ifdef CAMERATONEMAP\r\n\tfinalColor.rgb = toneMaps(finalColor.rgb);\r\n#endif\r\n\r\n\tfinalColor.rgb = toGammaSpace(finalColor.rgb);\r\n\r\n#include<logDepthFragment>\r\n#include<fogFragment>(color, finalColor)\r\n\r\n#ifdef CAMERACONTRAST\r\n\tfinalColor = contrasts(finalColor);\r\n#endif\r\n\r\n\tfinalColor.rgb = clamp(finalColor.rgb, 0., 1.);\r\n\r\n#ifdef CAMERACOLORGRADING\r\n\tfinalColor = colorGrades(finalColor);\r\n#endif\r\n\r\n#ifdef CAMERACOLORCURVES\r\n\tfinalColor.rgb = applyColorCurves(finalColor.rgb);\r\n#endif\r\n\r\n\t// Normal Display.\r\n\t// gl_FragColor = vec4(normalW * 0.5 + 0.5, 1.0);\r\n\r\n\t// Ambient reflection color.\r\n\t// gl_FragColor = vec4(ambientReflectionColor, 1.0);\r\n\r\n\t// Reflection color.\r\n\t// gl_FragColor = vec4(reflectionColor, 1.0);\r\n\r\n\t// Base color.\r\n\t// gl_FragColor = vec4(surfaceAlbedo.rgb, 1.0);\r\n\r\n\t// Specular color.\r\n\t// gl_FragColor = vec4(surfaceReflectivityColor.rgb, 1.0);\r\n\r\n\t// MicroSurface color.\r\n\t// gl_FragColor = vec4(microSurface, microSurface, microSurface, 1.0);\r\n\r\n\t// Specular Map\r\n\t// gl_FragColor = vec4(reflectivityMapColor.rgb, 1.0);\r\n\r\n\t// Refractance\r\n\t// gl_FragColor = vec4(refractance.rgb, 1.0);\r\n\r\n\t//// Emissive Color\r\n\t//vec2 test = vEmissiveUV * 0.5 + 0.5;\r\n\t//gl_FragColor = vec4(test.x, test.y, 1.0, 1.0);\r\n\r\n\tgl_FragColor = finalColor;\r\n}",
pbr_vertex: "﻿precision highp float;\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef ALBEDO\nvarying vec2 vAlbedoUV;\nuniform mat4 albedoMatrix;\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform mat4 ambientMatrix;\nuniform vec3 vAmbientInfos;\n#endif\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nvarying vec2 vLightmapUV;\nuniform vec2 vLightmapInfos;\nuniform mat4 lightmapMatrix;\n#endif\n#if defined(REFLECTIVITY) || defined(METALLICWORKFLOW) \nvarying vec2 vReflectivityUV;\nuniform vec2 vReflectivityInfos;\nuniform mat4 reflectivityMatrix;\n#endif\n#ifdef BUMP\nvarying vec2 vBumpUV;\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n#ifdef Vector2SIZE\nuniform float Vector2Size;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<shadowsVertexDeclaration>[0..maxSimultaneousLights]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\nvoid main(void) {\n#ifdef REFLECTIONMAP_SKYBOX\n    vPositionUVW = position;\n#endif \n#include<instancesVertex>\n#include<bonesVertex>\n    gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n    vec4 worldPos = finalWorld * vec4(position, 1.0);\n    vPositionW = vec3(worldPos);\n#ifdef NORMAL\n    vNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\n    vDirectionW = normalize(vec3(finalWorld * vec4(position, 0.0)));\n#endif\n#ifndef UV1\n    vec2 uv = vec2(0., 0.);\n#endif\n#ifndef UV2\n    vec2 uv2 = vec2(0., 0.);\n#endif\n#ifdef ALBEDO\n    if (vAlbedoInfos.x == 0.)\n    {\n        vAlbedoUV = vec2(albedoMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vAlbedoUV = vec2(albedoMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n#ifdef AMBIENT\n    if (vAmbientInfos.x == 0.)\n    {\n        vAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n#ifdef OPACITY\n    if (vOpacityInfos.x == 0.)\n    {\n        vOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n#ifdef EMISSIVE\n    if (vEmissiveInfos.x == 0.)\n    {\n        vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n#ifdef LIGHTMAP\n    if (vLightmapInfos.x == 0.)\n    {\n        vLightmapUV = vec2(lightmapMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vLightmapUV = vec2(lightmapMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n#if defined(REFLECTIVITY) || defined(METALLICWORKFLOW) \n    if (vReflectivityInfos.x == 0.)\n    {\n        vReflectivityUV = vec2(reflectivityMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vReflectivityUV = vec2(reflectivityMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n#ifdef BUMP\n    if (vBumpInfos.x == 0.)\n    {\n        vBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#ifdef VERTEXCOLOR\n    vColor = color;\n#endif\n#ifdef Vector2SIZE\n    gl_PointSize = Vector2Size;\n#endif\n#include<logDepthVertex>\n}",
postprocess_vertex: "﻿// Attributes\r\nattribute vec2 position;\r\n\r\n\r\nuniform vec2 scale;\r\n// Output\r\nvarying vec2 vUV;\r\n\r\nconst vec2 madd = vec2(0.5, 0.5);\r\n\r\nvoid main(void) {\t\r\n\r\n\tvUV = (position * madd + madd) * scale;\r\n\tgl_Position = vec4(position, 0.0, 1.0);\r\n}",
procedural_vertex: "﻿// Attributes\r\nattribute vec2 position;\r\n\r\n// Output\r\nvarying vec2 vPosition;\r\nvarying vec2 vUV;\r\n\r\nconst vec2 madd = vec2(0.5, 0.5);\r\n\r\nvoid main(void) {\t\r\n\tvPosition = position;\r\n\tvUV = position * madd + madd;\r\n\tgl_Position = vec4(position, 0.0, 1.0);\r\n}",
refraction_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D refractionSampler;\r\n\r\n// Parameters\r\nuniform vec3 baseColor;\r\nuniform float depth;\r\nuniform float colorLevel;\r\n\r\nvoid main() {\r\n\tfloat ref = 1.0 - texture2D(refractionSampler, vUV).r;\r\n\r\n\tvec2 uv = vUV - vec2(0.5);\r\n\tvec2 offset = uv * depth * ref;\r\n\tvec3 sourceColor = texture2D(textureSampler, vUV - offset).rgb;\r\n\r\n\tgl_FragColor = vec4(sourceColor + sourceColor * ref * colorLevel, 1.0);\r\n}",
shadowMap_fragment: "﻿#ifndef FULLFLOAT\r\nvec4 pack(float depth)\r\n{\r\n\tconst vec4 bit_shift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\r\n\tconst vec4 bit_mask = vec4(0.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\r\n\r\n\tvec4 res = fract(depth * bit_shift);\r\n\tres -= res.xxyz * bit_mask;\r\n\r\n\treturn res;\r\n}\r\n\r\n// Thanks to http://devmaster.net/\r\nvec2 packHalf(float depth) \r\n{ \r\n\tconst vec2 bitOffset = vec2(1.0 / 255., 0.);\r\n\tvec2 color = vec2(depth, fract(depth * 255.));\r\n\r\n\treturn color - (color.yy * bitOffset);\r\n}\r\n#endif\r\n\r\nvarying vec4 vPosition;\r\n\r\n#ifdef ALPHATEST\r\nvarying vec2 vUV;\r\nuniform sampler2D diffuseSampler;\r\n#endif\r\n\r\n#ifdef CUBEMAP\r\nuniform vec3 lightPosition;\r\nuniform vec2 depthValues;\r\n#endif\r\n\r\nvoid main(void)\r\n{\r\n#ifdef ALPHATEST\r\n\tif (texture2D(diffuseSampler, vUV).a < 0.4)\r\n\t\tdiscard;\r\n#endif\r\n\r\n#ifdef CUBEMAP\r\n\tvec3 directionToLight = vPosition.xyz - lightPosition;\r\n\t\r\n\tfloat depth = length(directionToLight);\r\n\tdepth = (depth - depthValues.x) / (depthValues.y - depthValues.x);\r\n\tdepth = clamp(depth, 0., 1.0);\r\n#else\r\n\tfloat depth = vPosition.z / vPosition.w;\r\n\tdepth = depth * 0.5 + 0.5;\r\n#endif\r\n\r\n#ifdef VSM\r\n\tfloat moment1 = depth;\r\n\tfloat moment2 = moment1 * moment1;\r\n\r\n\t#ifndef FULLFLOAT\r\n\t\tgl_FragColor = vec4(packHalf(moment1), packHalf(moment2));\r\n\t#else\r\n\t\tgl_FragColor = vec4(moment1, moment2, 1.0, 1.0);\r\n\t#endif\r\n#else\r\n\t#ifndef FULLFLOAT\r\n\t\tgl_FragColor = pack(depth);\r\n\t#else\r\n\t\tgl_FragColor = vec4(depth, 1.0, 1.0, 1.0);\r\n\t#endif\r\n#endif\r\n}",
shadowMap_vertex: "﻿// Attribute\r\nattribute vec3 position;\r\n\r\n#include<bonesDeclaration>\r\n\r\n// Uniforms\r\n#include<instancesDeclaration>\r\n\r\nuniform mat4 viewProjection;\r\n\r\nvarying vec4 vPosition;\r\n\r\n#ifdef ALPHATEST\r\nvarying vec2 vUV;\r\nuniform mat4 diffuseMatrix;\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n#endif\r\n\r\nvoid main(void)\r\n{\r\n#include<instancesVertex>\r\n#include<bonesVertex>\r\n\r\n#ifdef CUBEMAP\r\n\tvPosition = finalWorld * vec4(position, 1.0);\r\n\tgl_Position = viewProjection * finalWorld * vec4(position, 1.0);\r\n#else\r\n\tvPosition = viewProjection * finalWorld * vec4(position, 1.0);\r\n\tgl_Position = vPosition;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n#ifdef UV1\r\n\tvUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\r\n#endif\r\n#ifdef UV2\r\n\tvUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\r\n#endif\r\n#endif\r\n}",
sprites_fragment: "﻿uniform bool alphaTest;\r\n\r\nvarying vec4 vColor;\r\n\r\n// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D diffuseSampler;\r\n\r\n// Fog\r\n#include<fogFragmentDeclaration>\r\n\r\nvoid main(void) {\r\n\tvec4 color = texture2D(diffuseSampler, vUV);\r\n\r\n\tif (alphaTest) \r\n\t{\r\n\t\tif (color.a < 0.95)\r\n\t\t\tdiscard;\r\n\t}\r\n\r\n\tcolor *= vColor;\r\n\r\n#include<fogFragment>\r\n\r\n\tgl_FragColor = color;\r\n}",
sprites_vertex: "﻿// Attributes\r\nattribute vec4 position;\r\nattribute vec4 options;\r\nattribute vec4 cellInfo;\r\nattribute vec4 color;\r\n\r\n// Uniforms\r\nuniform vec2 textureInfos;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\n// Output\r\nvarying vec2 vUV;\r\nvarying vec4 vColor;\r\n\r\n#include<fogVertexDeclaration>\r\n\r\nvoid main(void) {\t\r\n\tvec3 viewPos = (view * vec4(position.xyz, 1.0)).xyz; \r\n\tvec2 cornerPos;\r\n\t\r\n\tfloat angle = position.w;\r\n\tvec2 size = vec2(options.x, options.y);\r\n\tvec2 offset = options.zw;\r\n\tvec2 uvScale = textureInfos.xy;\r\n\r\n\tcornerPos = vec2(offset.x - 0.5, offset.y  - 0.5) * size;\r\n\r\n\t// Rotate\r\n\tvec3 rotatedCorner;\r\n\trotatedCorner.x = cornerPos.x * cos(angle) - cornerPos.y * sin(angle);\r\n\trotatedCorner.y = cornerPos.x * sin(angle) + cornerPos.y * cos(angle);\r\n\trotatedCorner.z = 0.;\r\n\r\n\t// Position\r\n\tviewPos += rotatedCorner;\r\n\tgl_Position = projection * vec4(viewPos, 1.0);   \r\n\r\n\t// Color\r\n\tvColor = color;\r\n\t\r\n\t// Texture\r\n\tvec2 uvOffset = vec2(abs(offset.x - cellInfo.x), 1.0 - abs(offset.y - cellInfo.y));\r\n\r\n\tvUV = (uvOffset + cellInfo.zw) * uvScale;\r\n\r\n\t// Fog\r\n#ifdef FOG\r\n\tfFogDistance = viewPos.z;\r\n#endif\r\n}",
ssaoCombine_fragment: "﻿uniform sampler2D textureSampler;\r\nuniform sampler2D originalColor;\r\n\r\nvarying vec2 vUV;\r\n\r\nvoid main(void) {\r\n\tvec4 ssaoColor = texture2D(textureSampler, vUV);\r\n\tvec4 sceneColor = texture2D(originalColor, vUV);\r\n\r\n\tgl_FragColor = sceneColor * ssaoColor;\r\n}\r\n",
ssao_fragment: "﻿// SSAO Shader\r\nuniform sampler2D textureSampler;\r\n\r\nvarying vec2 vUV;\r\n\r\n#ifdef SSAO\r\nuniform sampler2D randomSampler;\r\n\r\nuniform float randTextureTiles;\r\nuniform float samplesFactor;\r\nuniform vec3 sampleSphere[SAMPLES];\r\n\r\nuniform float totalStrength;\r\nuniform float radius;\r\nuniform float area;\r\nuniform float fallOff;\r\nuniform float base;\r\n\r\nvec3 normalFromDepth(float depth, vec2 coords)\r\n{\r\n\tvec2 offset1 = vec2(0.0, radius);\r\n\tvec2 offset2 = vec2(radius, 0.0);\r\n\r\n\tfloat depth1 = texture2D(textureSampler, coords + offset1).r;\r\n\tfloat depth2 = texture2D(textureSampler, coords + offset2).r;\r\n\r\n\tvec3 p1 = vec3(offset1, depth1 - depth);\r\n\tvec3 p2 = vec3(offset2, depth2 - depth);\r\n\r\n\tvec3 normal = cross(p1, p2);\r\n\tnormal.z = -normal.z;\r\n\r\n\treturn normalize(normal);\r\n}\r\n\r\nvoid main()\r\n{\r\n\tvec3 random = normalize(texture2D(randomSampler, vUV * randTextureTiles).rgb);\r\n\tfloat depth = texture2D(textureSampler, vUV).r;\r\n\tvec3 position = vec3(vUV, depth);\r\n\tvec3 normal = normalFromDepth(depth, vUV);\r\n\tfloat radiusDepth = radius / depth;\r\n\tfloat occlusion = 0.0;\r\n\r\n\tvec3 ray;\r\n\tvec3 hemiRay;\r\n\tfloat occlusionDepth;\r\n\tfloat difference;\r\n\r\n\tfor (int i = 0; i < SAMPLES; i++)\r\n\t{\r\n\t\tray = radiusDepth * reflect(sampleSphere[i], random);\r\n\t\themiRay = position + sign(dot(ray, normal)) * ray;\r\n\r\n\t\tocclusionDepth = texture2D(textureSampler, clamp(hemiRay.xy, vec2(0.001, 0.001), vec2(0.999, 0.999))).r;\r\n\t\tdifference = depth - occlusionDepth;\r\n\r\n\t\tocclusion += step(fallOff, difference) * (1.0 - smoothstep(fallOff, area, difference));\r\n\t}\r\n\r\n\tfloat ao = 1.0 - totalStrength * occlusion * samplesFactor;\r\n\tfloat result = clamp(ao + base, 0.0, 1.0);\r\n\r\n\tgl_FragColor.r = result;\r\n\tgl_FragColor.g = result;\r\n\tgl_FragColor.b = result;\r\n\tgl_FragColor.a = 1.0;\r\n}\r\n#endif\r\n\r\n#ifdef BILATERAL_BLUR\r\nuniform sampler2D depthSampler;\r\nuniform float outSize;\r\nuniform float samplerOffsets[SAMPLES];\r\n\r\nvoid main()\r\n{\r\n\r\n\tfloat texelsize = 1.0 / outSize;\r\n\tfloat compareDepth = texture2D(depthSampler, vUV).r;\r\n\tfloat result = 0.0;\r\n\tfloat weightSum = 0.0;\r\n\r\n\tfor (int i = 0; i < SAMPLES; ++i)\r\n\t{\r\n\t\t#ifdef BILATERAL_BLUR_H\r\n\t\tvec2 sampleOffset = vec2(texelsize * samplerOffsets[i], 0.0);\r\n\t\t#else\r\n\t\tvec2 sampleOffset = vec2(0.0, texelsize * samplerOffsets[i]);\r\n\t\t#endif\r\n\t\tvec2 samplePos = vUV + sampleOffset;\r\n\r\n\t\tfloat sampleDepth = texture2D(depthSampler, samplePos).r;\r\n\t\tfloat weight = (1.0 / (0.0001 + abs(compareDepth - sampleDepth)));\r\n\r\n\t\tresult += texture2D(textureSampler, samplePos).r * weight;\r\n\t\tweightSum += weight;\r\n\t}\r\n\r\n\tresult /= weightSum;\r\n\r\n\tgl_FragColor.rgb = vec3(result);\r\n\tgl_FragColor.a = 1.0;\r\n}\r\n#endif\r\n",
standard_fragment: "﻿uniform sampler2D textureSampler;\r\nvarying vec2 vUV;\r\n\r\n#if defined(PASS_POST_PROCESS)\r\nvoid main(void)\r\n{\r\n\tvec4 color = texture2D(textureSampler, vUV);\r\n\tgl_FragColor = color;\r\n}\r\n#endif\r\n\r\n#if defined(DOWN_SAMPLE_X4)\r\nuniform vec2 dsOffsets[16];\r\n\r\nvoid main(void)\r\n{\r\n\tvec4 average = vec4(0.0, 0.0, 0.0, 0.0);\r\n\r\n\taverage = texture2D(textureSampler, vUV + dsOffsets[0]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[1]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[2]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[3]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[4]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[5]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[6]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[7]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[8]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[9]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[10]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[11]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[12]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[13]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[14]);\r\n\taverage += texture2D(textureSampler, vUV + dsOffsets[15]);\r\n\r\n\taverage /= 16.0;\r\n\r\n\tgl_FragColor = average;\r\n}\r\n#endif\r\n\r\n#if defined(BRIGHT_PASS)\r\nuniform vec2 dsOffsets[4];\r\nuniform float brightThreshold;\r\n\r\nvoid main(void)\r\n{\r\n\tvec4 average = vec4(0.0, 0.0, 0.0, 0.0);\r\n\r\n\taverage = texture2D(textureSampler, vUV + vec2(dsOffsets[0].x, dsOffsets[0].y));\r\n\taverage += texture2D(textureSampler, vUV + vec2(dsOffsets[1].x, dsOffsets[1].y));\r\n\taverage += texture2D(textureSampler, vUV + vec2(dsOffsets[2].x, dsOffsets[2].y));\r\n\taverage += texture2D(textureSampler, vUV + vec2(dsOffsets[3].x, dsOffsets[3].y));\r\n\r\n\taverage *= 0.25;\r\n\r\n\tfloat luminance = length(average.rgb);\r\n\r\n\tif (luminance < brightThreshold) {\r\n\t\taverage = vec4(0.0, 0.0, 0.0, 1.0);\r\n\t}\r\n\r\n\tgl_FragColor = average;\r\n}\r\n#endif\r\n\r\n#if defined(GAUSSIAN_BLUR_H) || defined(GAUSSIAN_BLUR_V)\r\nuniform float blurOffsets[9];\r\nuniform float blurWeights[9];\r\nuniform float blurWidth;\r\n\r\nvoid main(void)\r\n{\r\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\r\n\r\n\tfor (int i = 0; i < 9; i++) {\r\n#ifdef GAUSSIAN_BLUR_H\r\n\t\tcolor += (texture2D(textureSampler, vUV + vec2(blurOffsets[i] * blurWidth, 0.0)) * blurWeights[i]);\r\n\t\tcolor += (texture2D(textureSampler, vUV - vec2(blurOffsets[i] * blurWidth, 0.0)) * blurWeights[i]);\r\n#else\r\n\t\tcolor += (texture2D(textureSampler, vUV + vec2(0.0, blurOffsets[i] * blurWidth)) * blurWeights[i]);\r\n\t\tcolor += (texture2D(textureSampler, vUV - vec2(0.0, blurOffsets[i] * blurWidth)) * blurWeights[i]);\r\n#endif\r\n\t}\r\n\r\n\tcolor.a = 1.0;\r\n\tgl_FragColor = color;\r\n}\r\n#endif\r\n\r\n#if defined(TEXTURE_ADDER)\r\nuniform sampler2D otherSampler;\r\nuniform sampler2D lensSampler;\r\n\r\nuniform float exposure;\r\n\r\nvoid main(void)\r\n{\r\n\tvec3 colour = texture2D(textureSampler, vUV).rgb;\r\n\r\n\tcolour *= exposure;\r\n\r\n\tvec3 X = max(vec3(0.0, 0.0, 0.0), colour - 0.004);\r\n\tvec3 retColor = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\r\n\r\n\tcolour = retColor * retColor;\r\n\tcolour += colour * texture2D(lensSampler, vUV).rgb;\r\n\r\n\tvec4 finalColor = vec4(colour.rgb, 1.0) + texture2D(otherSampler, vUV);\r\n\r\n\tgl_FragColor = finalColor;\r\n}\r\n#endif\r\n\r\n#if defined(LENS_FLARE)\r\n#define GHOSTS 3\r\n\r\nuniform sampler2D lensColorSampler;\r\n\r\nuniform float strength;\r\nuniform float ghostDispersal;\r\nuniform float haloWidth;\r\n\r\nuniform vec2 resolution;\r\nuniform float distortionStrength;\r\n\r\nfloat hash(vec2 p)\r\n{\r\n\tfloat h = dot(p, vec2(127.1, 311.7));\r\n\treturn -1.0 + 2.0*fract(sin(h)*43758.5453123);\r\n}\r\n\r\nfloat noise(in vec2 p)\r\n{\r\n\tvec2 i = floor(p);\r\n\tvec2 f = fract(p);\r\n\tvec2 u = f*f*(3.0 - 2.0*f);\r\n\r\n\treturn mix(mix(hash(i + vec2(0.0, 0.0)),\r\n\t\thash(i + vec2(1.0, 0.0)), u.x),\r\n\t\tmix(hash(i + vec2(0.0, 1.0)),\r\n\t\t\thash(i + vec2(1.0, 1.0)), u.x), u.y);\r\n}\r\n\r\nfloat fbm(vec2 p)\r\n{\r\n\tfloat f = 0.0;\r\n\tf += 0.5000 * noise(p); p *= 2.02;\r\n\tf += 0.2500 * noise(p); p *= 2.03;\r\n\tf += 0.1250 * noise(p); p *= 2.01;\r\n\tf += 0.0625 * noise(p); p *= 2.04;\r\n\tf /= 0.9375;\r\n\treturn f;\r\n}\r\n\r\nvec3 pattern(vec2 uv)\r\n{\r\n\tvec2 p = -1.0 + 2.0 * uv;\r\n\tfloat p2 = dot(p, p);\r\n\tfloat f = fbm(vec2(15.0*p2)) / 2.0;\r\n\tfloat r = 0.2 + 0.6 * sin(12.5*length(uv - vec2(0.5)));\r\n\tfloat g = 0.2 + 0.6 * sin(20.5*length(uv - vec2(0.5)));\r\n\tfloat b = 0.2 + 0.6 * sin(17.2*length(uv - vec2(0.5)));\r\n\treturn (1.0 - f) * vec3(r, g, b);\r\n}\r\n\r\nfloat luminance(vec3 color)\r\n{\r\n\treturn dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\r\n}\r\n\r\nvec4 textureDistorted(sampler2D tex, vec2 texcoord, vec2 direction, vec3 distortion)\r\n{\r\n\treturn vec4(\r\n\t\ttexture2D(tex, texcoord + direction * distortion.r).r,\r\n\t\ttexture2D(tex, texcoord + direction * distortion.g).g,\r\n\t\ttexture2D(tex, texcoord + direction * distortion.b).b,\r\n\t\t1.0\r\n\t);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\tvec2 uv = -vUV + vec2(1.0);\r\n\tvec2 ghostDir = (vec2(0.5) - uv) * ghostDispersal;\r\n\r\n\tvec2 texelSize = 1.0 / resolution;\r\n\tvec3 distortion = vec3(-texelSize.x * distortionStrength, 0.0, texelSize.x * distortionStrength);\r\n\r\n\tvec4 result = vec4(0.0);\r\n\tfloat ghostIndice = 1.0;\r\n\r\n\tfor (int i = 0; i < GHOSTS; ++i)\r\n\t{\r\n\t\tvec2 offset = fract(uv + ghostDir * ghostIndice);\r\n\t\tfloat weight = length(vec2(0.5) - offset) / length(vec2(0.5));\r\n\t\tweight = pow(1.0 - weight, 10.0);\r\n\r\n\t\tresult += textureDistorted(textureSampler, offset, normalize(ghostDir), distortion) * weight * strength;\r\n\r\n\t\tghostIndice += 1.0;\r\n\t}\r\n\r\n\tvec2 haloVec = normalize(ghostDir) * haloWidth;\r\n\r\n\tfloat weight = length(vec2(0.5) - fract(uv + haloVec)) / length(vec2(0.5));\r\n\tweight = pow(1.0 - weight, 10.0);\r\n\r\n\tresult += textureDistorted(textureSampler, fract(uv + haloVec), normalize(ghostDir), distortion) * weight * strength;\r\n\r\n\tresult *= texture2D(lensColorSampler, vec2(length(vec2(0.5) - uv) / length(vec2(0.5))));\r\n\r\n\tgl_FragColor = result;\r\n}\r\n#endif\r\n\r\n#if defined(LENS_FLARE_COMPOSE)\r\nuniform sampler2D otherSampler;\r\nuniform sampler2D lensDirtSampler;\r\nuniform sampler2D lensStarSampler;\r\n\r\nuniform mat4 lensStarMatrix;\r\n\r\nvoid main(void)\r\n{\r\n\tvec2 lensFlareCoords = (lensStarMatrix * vec4(vUV, 1.0, 1.0)).xy;\r\n\r\n\tvec4 lensMod = texture2D(lensDirtSampler, vUV);\r\n\tlensMod += texture2D(lensStarSampler, vUV);\r\n\r\n\tvec4 result = texture2D(textureSampler, vUV) * lensMod;\r\n\r\n\tgl_FragColor = texture2D(otherSampler, vUV) + result;\r\n}\r\n#endif\r\n\r\n#if defined(DEPTH_OF_FIELD)\r\nuniform sampler2D otherSampler;\r\nuniform sampler2D depthSampler;\r\n\r\nuniform float distance;\r\n\r\nvoid main(void)\r\n{\r\n\tvec4 sharp = texture2D(otherSampler, vUV);\r\n\tvec4 blur = texture2D(textureSampler, vUV);\r\n\tfloat dist = clamp(texture2D(depthSampler, vUV).r * distance, 0.0, 1.0);\r\n\tfloat factor = 0.0;\r\n\r\n\tif (dist < 0.05)\r\n\t\tfactor = 1.0;\r\n\telse if (dist < 0.1)\r\n\t\tfactor = 20.0 * (0.1 - dist);\r\n\telse if (dist < 0.5)\r\n\t\tfactor = 0.0;\r\n\telse\r\n\t\tfactor = 2.0 * (dist - 0.5);\r\n\r\n\tfactor = clamp(factor, 0.0, 0.90);\r\n\tgl_FragColor = mix(sharp, blur, factor);\r\n}\r\n\r\n#endif\r\n",
stereoscopicInterlace_fragment: "﻿const vec3 TWO = vec3(2.0, 2.0, 2.0);\r\n\r\nvarying vec2 vUV;\r\nuniform sampler2D camASampler;\r\nuniform sampler2D textureSampler;\r\nuniform vec2 stepSize;\r\n\r\nvoid main(void)\r\n{\r\n    bool useCamB;\r\n    vec2 texCoord1;\r\n    vec2 texCoord2;\r\n    \r\n    vec3 frag1;\r\n    vec3 frag2;\r\n    \r\n#ifdef IS_STEREOSCOPIC_HORIZ\r\n\t    useCamB = vUV.x > 0.5;\r\n\t    texCoord1 = vec2(useCamB ? (vUV.x - 0.5) * 2.0 : vUV.x * 2.0, vUV.y);\r\n\t    texCoord2 = vec2(texCoord1.x + stepSize.x, vUV.y);\r\n#else\r\n\t    useCamB = vUV.y > 0.5;\r\n\t    texCoord1 = vec2(vUV.x, useCamB ? (vUV.y - 0.5) * 2.0 : vUV.y * 2.0);\r\n\t    texCoord2 = vec2(vUV.x, texCoord1.y + stepSize.y);\r\n#endif\r\n    \r\n    // cannot assign a sampler to a variable, so must duplicate texture accesses\r\n    if (useCamB){\r\n        frag1 = texture2D(textureSampler, texCoord1).rgb;\r\n        frag2 = texture2D(textureSampler, texCoord2).rgb;\r\n    }else{\r\n        frag1 = texture2D(camASampler   , texCoord1).rgb;\r\n        frag2 = texture2D(camASampler   , texCoord2).rgb;\r\n    }\r\n    \r\n    gl_FragColor = vec4((frag1 + frag2) / TWO, 1.0);\r\n}",
tonemap_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\n\r\n// Constants\r\nuniform float _ExposureAdjustment;\r\n\r\n#if defined(HABLE_TONEMAPPING)\r\n    const float A = 0.15;\r\n    const float B = 0.50;\r\n    const float C = 0.10;\r\n    const float D = 0.20;\r\n    const float E = 0.02;\r\n    const float F = 0.30;\r\n    const float W = 11.2;\r\n#endif\r\n\r\nfloat Luminance(vec3 c)\r\n{\r\n    return dot(c, vec3(0.22, 0.707, 0.071));\r\n}\r\n\r\nvoid main(void) \r\n{\r\n    vec3 colour = texture2D(textureSampler, vUV).rgb;\r\n\r\n#if defined(REINHARD_TONEMAPPING)\r\n\r\n    float lum = Luminance(colour.rgb); \r\n    float lumTm = lum * _ExposureAdjustment;\r\n    float scale = lumTm / (1.0 + lumTm);  \r\n\r\n    colour *= scale / lum;\r\n\r\n#elif defined(HABLE_TONEMAPPING)\r\n\r\n    colour *= _ExposureAdjustment;\r\n\r\n    const float ExposureBias = 2.0;\r\n    vec3 x = ExposureBias * colour;\r\n\r\n    vec3 curr = ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\r\n    \r\n    x = vec3(W, W, W);\r\n    vec3 whiteScale = 1.0 / (((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F);\r\n    colour = curr * whiteScale;\r\n\r\n#elif defined(OPTIMIZED_HEJIDAWSON_TONEMAPPING)\r\n\r\n    colour *= _ExposureAdjustment;\r\n    \r\n    vec3 X = max(vec3(0.0, 0.0, 0.0), colour - 0.004);\r\n    vec3 retColor = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\r\n\r\n    colour = retColor * retColor;\r\n\r\n#elif defined(PHOTOGRAPHIC_TONEMAPPING)\r\n\r\n    colour =  vec3(1.0, 1.0, 1.0) - exp2(-_ExposureAdjustment * colour);\r\n\r\n#endif\r\n\r\n\tgl_FragColor = vec4(colour.rgb, 1.0);\r\n}",
volumetricLightScatteringPass_fragment: "﻿#if defined(ALPHATEST) || defined(NEED_UV)\r\nvarying vec2 vUV;\r\n#endif\r\n\r\n#if defined(ALPHATEST)\r\nuniform sampler2D diffuseSampler;\r\n#endif\r\n\r\nvoid main(void)\r\n{\r\n#if defined(ALPHATEST)\r\n\tvec4 diffuseColor = texture2D(diffuseSampler, vUV);\r\n\r\n\tif (diffuseColor.a < 0.4)\r\n\t\tdiscard;\r\n#endif\r\n\r\n\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n}\r\n\r\n",
volumetricLightScattering_fragment: "﻿uniform sampler2D textureSampler;\r\nuniform sampler2D lightScatteringSampler;\r\n\r\nuniform float decay;\r\nuniform float exposure;\r\nuniform float weight;\r\nuniform float density;\r\nuniform vec2 meshPositionOnScreen;\r\n\r\nvarying vec2 vUV;\r\n\r\nvoid main(void) {\r\n    vec2 tc = vUV;\r\n\tvec2 deltaTexCoord = (tc - meshPositionOnScreen.xy);\r\n    deltaTexCoord *= 1.0 / float(NUM_SAMPLES) * density;\r\n\r\n    float illuminationDecay = 1.0;\r\n\r\n\tvec4 color = texture2D(lightScatteringSampler, tc) * 0.4;\r\n\r\n    for(int i=0; i < NUM_SAMPLES; i++) {\r\n        tc -= deltaTexCoord;\r\n\t\tvec4 sample = texture2D(lightScatteringSampler, tc) * 0.4;\r\n        sample *= illuminationDecay * weight;\r\n        color += sample;\r\n        illuminationDecay *= decay;\r\n    }\r\n\r\n    vec4 realColor = texture2D(textureSampler, vUV);\r\n    gl_FragColor = ((vec4((vec3(color.r, color.g, color.b) * exposure), 1)) + (realColor * (1.5 - 0.4)));\r\n}\r\n",
vrDistortionCorrection_fragment: "﻿// Samplers\r\nvarying vec2 vUV;\r\nuniform sampler2D textureSampler;\r\nuniform vec2 LensCenter;\r\nuniform vec2 Scale;\r\nuniform vec2 ScaleIn;\r\nuniform vec4 HmdWarpParam;\r\n\r\nvec2 HmdWarp(vec2 in01) {\r\n\r\n\tvec2 theta = (in01 - LensCenter) * ScaleIn; // Scales to [-1, 1]\r\n\tfloat rSq = theta.x * theta.x + theta.y * theta.y;\r\n\tvec2 rvector = theta * (HmdWarpParam.x + HmdWarpParam.y * rSq + HmdWarpParam.z * rSq * rSq + HmdWarpParam.w * rSq * rSq * rSq);\r\n\treturn LensCenter + Scale * rvector;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\tvec2 tc = HmdWarp(vUV);\r\n\tif (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\r\n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n\telse{\r\n\t\tgl_FragColor = vec4(texture2D(textureSampler, tc).rgb, 1.0);\r\n\t}\r\n}",
bonesDeclaration: "﻿#if NUM_BONE_INFLUENCERS > 0\r\n\tuniform mat4 mBones[BonesPerMesh];\r\n\r\n\tattribute vec4 matricesIndices;\r\n\tattribute vec4 matricesWeights;\r\n\t#if NUM_BONE_INFLUENCERS > 4\r\n\t\tattribute vec4 matricesIndicesExtra;\r\n\t\tattribute vec4 matricesWeightsExtra;\r\n\t#endif\r\n#endif",
bonesVertex: "﻿#if NUM_BONE_INFLUENCERS > 0\r\n\tmat4 influence;\r\n\tinfluence = mBones[int(matricesIndices[0])] * matricesWeights[0];\r\n\r\n\t#if NUM_BONE_INFLUENCERS > 1\r\n\t\tinfluence += mBones[int(matricesIndices[1])] * matricesWeights[1];\r\n\t#endif\t\r\n\t#if NUM_BONE_INFLUENCERS > 2\r\n\t\tinfluence += mBones[int(matricesIndices[2])] * matricesWeights[2];\r\n\t#endif\t\r\n\t#if NUM_BONE_INFLUENCERS > 3\r\n\t\tinfluence += mBones[int(matricesIndices[3])] * matricesWeights[3];\r\n\t#endif\t\r\n\r\n\t#if NUM_BONE_INFLUENCERS > 4\r\n\t\tinfluence += mBones[int(matricesIndicesExtra[0])] * matricesWeightsExtra[0];\r\n\t#endif\t\r\n\t#if NUM_BONE_INFLUENCERS > 5\r\n\t\tinfluence += mBones[int(matricesIndicesExtra[1])] * matricesWeightsExtra[1];\r\n\t#endif\t\r\n\t#if NUM_BONE_INFLUENCERS > 6\r\n\t\tinfluence += mBones[int(matricesIndicesExtra[2])] * matricesWeightsExtra[2];\r\n\t#endif\t\r\n\t#if NUM_BONE_INFLUENCERS > 7\r\n\t\tinfluence += mBones[int(matricesIndicesExtra[3])] * matricesWeightsExtra[3];\r\n\t#endif\t\r\n\r\n\tfinalWorld = finalWorld * influence;\r\n#endif",
bumpFragment: "﻿vec2 uvOffset = vec2(0.0, 0.0);\r\n\r\n#if defined(BUMP) || defined(PARALLAX)\r\n\tmat3 TBN = cotangent_frame(normalW * vBumpInfos.y, -viewDirectionW, vBumpUV);\r\n#endif\r\n\r\n#ifdef PARALLAX\r\n\tmat3 invTBN = transposeMat3(TBN);\r\n\r\n\t#ifdef PARALLAXOCCLUSION\r\n\t\tuvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, vBumpUV, vBumpInfos.z);\r\n\t#else\r\n\t\tuvOffset = parallaxOffset(invTBN * viewDirectionW, vBumpInfos.z);\r\n\t#endif\r\n#endif\r\n\r\n#ifdef BUMP\r\n\tnormalW = perturbNormal(viewDirectionW, TBN, vBumpUV + uvOffset);\r\n#endif",
bumpFragmentFunctions: "﻿#ifdef BUMP\r\n\tvarying vec2 vBumpUV;\r\n\tuniform vec3 vBumpInfos;\r\n\tuniform sampler2D bumpSampler;\r\n\r\n\t// Thanks to http://www.thetenthplanet.de/archives/1180\r\n\tmat3 cotangent_frame(vec3 normal, vec3 p, vec2 uv)\r\n\t{\r\n\t\t// get edge vectors of the pixel triangle\r\n\t\tvec3 dp1 = dFdx(p);\r\n\t\tvec3 dp2 = dFdy(p);\r\n\t\tvec2 duv1 = dFdx(uv);\r\n\t\tvec2 duv2 = dFdy(uv);\r\n\r\n\t\t// solve the linear system\r\n\t\tvec3 dp2perp = cross(dp2, normal);\r\n\t\tvec3 dp1perp = cross(normal, dp1);\r\n\t\tvec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\r\n\t\tvec3 binormal = dp2perp * duv1.y + dp1perp * duv2.y;\r\n\r\n\t\t// construct a scale-invariant frame \r\n\t\tfloat invmax = inversesqrt(max(dot(tangent, tangent), dot(binormal, binormal)));\r\n\t\treturn mat3(tangent * invmax, binormal * invmax, normal);\r\n\t}\r\n\r\n\tvec3 perturbNormal(vec3 viewDir, mat3 cotangentFrame, vec2 uv)\r\n\t{\r\n\t\tvec3 map = texture2D(bumpSampler, uv).xyz;\r\n\r\n\t#ifdef INVERTNORMALMAPX\r\n\t\tmap.x = 1.0 - map.x;\r\n\t#endif\r\n\t#ifdef INVERTNORMALMAPY\r\n\t\tmap.y = 1.0 - map.y;\r\n\t#endif\r\n\r\n\t\tmap = map * 255. / 127. - 128. / 127.;\r\n\t\treturn normalize(cotangentFrame * map);\r\n\t}\r\n\r\n\t#ifdef PARALLAX\r\n\t\tconst float minSamples = 4.;\r\n\t\tconst float maxSamples = 15.;\r\n\t\tconst int iMaxSamples = 15;\r\n\r\n\t\t// http://www.gamedev.net/page/resources/_/technical/graphics-programming-and-theory/a-closer-look-at-parallax-occlusion-mapping-r3262\r\n\t\tvec2 parallaxOcclusion(vec3 vViewDirCoT, vec3 vNormalCoT, vec2 texCoord, float parallaxScale) {\r\n\r\n\t\t\tfloat parallaxLimit = length(vViewDirCoT.xy) / vViewDirCoT.z;\r\n\t\t\tparallaxLimit *= parallaxScale;\r\n\t\t\tvec2 vOffsetDir = normalize(vViewDirCoT.xy);\r\n\t\t\tvec2 vMaxOffset = vOffsetDir * parallaxLimit;\r\n\t\t\tfloat numSamples = maxSamples + (dot(vViewDirCoT, vNormalCoT) * (minSamples - maxSamples));\r\n\t\t\tfloat stepSize = 1.0 / numSamples;\r\n\r\n\t\t\t// Initialize the starting view ray height and the texture offsets.\r\n\t\t\tfloat currRayHeight = 1.0;\r\n\t\t\tvec2 vCurrOffset = vec2(0, 0);\r\n\t\t\tvec2 vLastOffset = vec2(0, 0);\r\n\r\n\t\t\tfloat lastSampledHeight = 1.0;\r\n\t\t\tfloat currSampledHeight = 1.0;\r\n\r\n\t\t\tfor (int i = 0; i < iMaxSamples; i++)\r\n\t\t\t{\r\n\t\t\t\tcurrSampledHeight = texture2D(bumpSampler, vBumpUV + vCurrOffset).w;\r\n\r\n\t\t\t\t// Test if the view ray has intersected the surface.\r\n\t\t\t\tif (currSampledHeight > currRayHeight)\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat delta1 = currSampledHeight - currRayHeight;\r\n\t\t\t\t\tfloat delta2 = (currRayHeight + stepSize) - lastSampledHeight;\r\n\t\t\t\t\tfloat ratio = delta1 / (delta1 + delta2);\r\n\t\t\t\t\tvCurrOffset = (ratio)* vLastOffset + (1.0 - ratio) * vCurrOffset;\r\n\r\n\t\t\t\t\t// Force the exit of the loop\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tcurrRayHeight -= stepSize;\r\n\t\t\t\t\tvLastOffset = vCurrOffset;\r\n\t\t\t\t\tvCurrOffset += stepSize * vMaxOffset;\r\n\r\n\t\t\t\t\tlastSampledHeight = currSampledHeight;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn vCurrOffset;\r\n\t\t}\r\n\r\n\t\tvec2 parallaxOffset(vec3 viewDir, float heightScale)\r\n\t\t{\r\n\t\t\t// calculate amount of offset for Parallax Mapping With Offset Limiting\r\n\t\t\tfloat height = texture2D(bumpSampler, vBumpUV).w;\r\n\t\t\tvec2 texCoordOffset = heightScale * viewDir.xy * height;\r\n\t\t\treturn -texCoordOffset;\r\n\t\t}\r\n\t#endif\r\n#endif",
clipPlaneFragment: "﻿#ifdef CLIPPLANE\r\n\tif (fClipDistance > 0.0)\r\n\t{\r\n\t\tdiscard;\r\n\t}\r\n#endif",
clipPlaneFragmentDeclaration: "﻿#ifdef CLIPPLANE\r\n\tvarying float fClipDistance;\r\n#endif",
clipPlaneVertex: "﻿#ifdef CLIPPLANE\r\n\tfClipDistance = dot(worldPos, vClipPlane);\r\n#endif",
clipPlaneVertexDeclaration: "﻿#ifdef CLIPPLANE\r\n\tuniform vec4 vClipPlane;\r\n\tvarying float fClipDistance;\r\n#endif",
colorCurves: "const vec3 HDTVRec709_RGBLuminanceCoefficients = vec3(0.2126, 0.7152, 0.0722);\r\n\r\nvec3 applyColorCurves(vec3 original) {\r\n\tvec3 result = original;\r\n\r\n\t// Apply colour grading curves: luma-based adjustments for saturation, exposure and white balance (color filter)\r\n\t// Note: the luma-based ramp is calibrated so that at 50% luma the midtone adjustment is full active, and the shadow/highlight \r\n\t// adjustments are fully active by 16% and 83% luma, respectively.\r\n\tfloat luma = dot(result.rgb, HDTVRec709_RGBLuminanceCoefficients);\r\n\r\n\tvec2 curveMix = clamp(vec2(luma * 3.0 - 1.5, luma * -3.0 + 1.5), vec2(0.0, 0.0), vec2(1.0, 1.0));\r\n\tvec4 colorCurve = vCameraColorCurveNeutral + curveMix.x * vCameraColorCurvePositive - curveMix.y * vCameraColorCurveNegative;\r\n\r\n\tresult.rgb *= colorCurve.rgb;\r\n\tresult.rgb = mix(vec3(luma, luma, luma), result.rgb, colorCurve.a);\r\n\r\n\treturn result;\r\n}",
colorCurvesDefinition: "uniform vec4 vCameraColorCurveNeutral;\r\nuniform vec4 vCameraColorCurvePositive;\r\nuniform vec4 vCameraColorCurveNegative;",
colorGrading: "vec4 colorGrades(vec4 color) \r\n{    \r\n    // Dynamic runtime calculations (dependent on input color)\r\n    float sliceContinuous = color.z * vCameraColorGradingInfos.z;\r\n    float sliceInteger = floor(sliceContinuous);\r\n\r\n    // Note: this is mathematically equivalent to fract(sliceContinuous); but we use explicit subtract\r\n    // rather than separate fract() for correct results near slice boundaries (matching sliceInteger choice)\r\n    float sliceFraction = sliceContinuous - sliceInteger; \r\n\r\n    // Calculate UV offset from slice origin (top-left)\r\n    vec2 sliceUV = color.xy * vCameraColorGradingScaleOffset.xy + vCameraColorGradingScaleOffset.zw;\r\n\r\n    // Calculate UV positions into overall texture for neighbouring slices \r\n    // (to emulate trilinear filtering on missing 3D hardware texture support)\r\n    sliceUV.x += sliceInteger * vCameraColorGradingInfos.w;\r\n    vec4 slice0Color = texture2D(cameraColorGrading2DSampler, sliceUV);\r\n\r\n    sliceUV.x += vCameraColorGradingInfos.w;\r\n    vec4 slice1Color = texture2D(cameraColorGrading2DSampler, sliceUV);\r\n\r\n    vec3 result = mix(slice0Color.rgb, slice1Color.rgb, sliceFraction);\r\n    color.rgb = mix(color.rgb, result, vCameraColorGradingInfos.x);\r\n\r\n    return color;\r\n}",
colorGradingDefinition: "uniform sampler2D cameraColorGrading2DSampler;\r\nuniform vec4 vCameraColorGradingInfos;\r\nuniform vec4 vCameraColorGradingScaleOffset;",
fogFragment: "﻿#ifdef FOG\r\n\tfloat fog = CalcFogFactor();\r\n\tcolor.rgb = fog * color.rgb + (1.0 - fog) * vFogColor;\r\n#endif",
fogFragmentDeclaration: "﻿#ifdef FOG\r\n\r\n#define FOGMODE_NONE    0.\r\n#define FOGMODE_EXP     1.\r\n#define FOGMODE_EXP2    2.\r\n#define FOGMODE_LINEAR  3.\r\n#define E 2.71828\r\n\r\nuniform vec4 vFogInfos;\r\nuniform vec3 vFogColor;\r\nvarying float fFogDistance;\r\n\r\nfloat CalcFogFactor()\r\n{\r\n\tfloat fogCoeff = 1.0;\r\n\tfloat fogStart = vFogInfos.y;\r\n\tfloat fogEnd = vFogInfos.z;\r\n\tfloat fogDensity = vFogInfos.w;\r\n\r\n\tif (FOGMODE_LINEAR == vFogInfos.x)\r\n\t{\r\n\t\tfogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\r\n\t}\r\n\telse if (FOGMODE_EXP == vFogInfos.x)\r\n\t{\r\n\t\tfogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\r\n\t}\r\n\telse if (FOGMODE_EXP2 == vFogInfos.x)\r\n\t{\r\n\t\tfogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\r\n\t}\r\n\r\n\treturn clamp(fogCoeff, 0.0, 1.0);\r\n}\r\n#endif",
fogVertex: "﻿#ifdef FOG\r\nfFogDistance = (view * worldPos).z;\r\n#endif",
fogVertexDeclaration: "﻿#ifdef FOG\r\n\tvarying float fFogDistance;\r\n#endif",
fresnelFunction: "﻿#ifdef FRESNEL\r\n\tfloat computeFresnelTerm(vec3 viewDirection, vec3 worldNormal, float bias, float power)\r\n\t{\r\n\t\tfloat fresnelTerm = pow(bias + abs(dot(viewDirection, worldNormal)), power);\r\n\t\treturn clamp(fresnelTerm, 0., 1.);\r\n\t}\r\n#endif",
harmonicsFunctions: "#ifdef USESPHERICALFROMREFLECTIONMAP\r\n    uniform vec3 vSphericalX;\r\n    uniform vec3 vSphericalY;\r\n    uniform vec3 vSphericalZ;\r\n    uniform vec3 vSphericalXX;\r\n    uniform vec3 vSphericalYY;\r\n    uniform vec3 vSphericalZZ;\r\n    uniform vec3 vSphericalXY;\r\n    uniform vec3 vSphericalYZ;\r\n    uniform vec3 vSphericalZX;\r\n\r\n    vec3 EnvironmentIrradiance(vec3 normal)\r\n    {\r\n        // Note: 'normal' is assumed to be normalised (or near normalised)\r\n        // This isn't as critical as it is with other calculations (e.g. specular highlight), but the result will be incorrect nonetheless.\r\n\r\n        // TODO: switch to optimal implementation\r\n        vec3 result =\r\n            vSphericalX * normal.x +\r\n            vSphericalY * normal.y +\r\n            vSphericalZ * normal.z +\r\n            vSphericalXX * normal.x * normal.x +\r\n            vSphericalYY * normal.y * normal.y +\r\n            vSphericalZZ * normal.z * normal.z +\r\n            vSphericalYZ * normal.y * normal.z +\r\n            vSphericalZX * normal.z * normal.x +\r\n            vSphericalXY * normal.x * normal.y;\r\n\r\n        return result.rgb;\r\n    }\r\n#endif",
helperFunctions: "﻿mat3 transposeMat3(mat3 inMatrix) {\r\n\tvec3 i0 = inMatrix[0];\r\n\tvec3 i1 = inMatrix[1];\r\n\tvec3 i2 = inMatrix[2];\r\n\r\n\tmat3 outMatrix = mat3(\r\n\t\tvec3(i0.x, i1.x, i2.x),\r\n\t\tvec3(i0.y, i1.y, i2.y),\r\n\t\tvec3(i0.z, i1.z, i2.z)\r\n\t\t);\r\n\r\n\treturn outMatrix;\r\n}",
instancesDeclaration: "﻿#ifdef INSTANCES\r\n\tattribute vec4 world0;\r\n\tattribute vec4 world1;\r\n\tattribute vec4 world2;\r\n\tattribute vec4 world3;\r\n#else\r\n\tuniform mat4 world;\r\n#endif",
instancesVertex: "﻿#ifdef INSTANCES\r\n\tmat4 finalWorld = mat4(world0, world1, world2, world3);\r\n#else\r\n\tmat4 finalWorld = world;\r\n#endif",
lightFragment: "﻿#ifdef LIGHT{X}\r\n    #if defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\r\n        //No light calculation\r\n    #else\r\n        #ifndef SPECULARTERM\r\n            vec3 vLightSpecular{X} = vec3(0.);\r\n        #endif\r\n        #ifdef SPOTLIGHT{X}\r\n            info = computeSpotLighting(viewDirectionW, normalW, vLightData{X}, vLightDirection{X}, vLightDiffuse{X}.rgb, vLightSpecular{X}, vLightDiffuse{X}.a, glossiness);\r\n        #endif\r\n        #ifdef HEMILIGHT{X}\r\n            info = computeHemisphericLighting(viewDirectionW, normalW, vLightData{X}, vLightDiffuse{X}.rgb, vLightSpecular{X}, vLightGround{X}, glossiness);\r\n        #endif\r\n        #if defined(Vector2LIGHT{X}) || defined(DIRLIGHT{X})\r\n            info = computeLighting(viewDirectionW, normalW, vLightData{X}, vLightDiffuse{X}.rgb, vLightSpecular{X}, vLightDiffuse{X}.a, glossiness);\r\n        #endif\r\n    #endif\r\n\t#ifdef SHADOW{X}\r\n\t\t#ifdef SHADOWVSM{X}\r\n\t\t\tshadow = computeShadowWithVSM(vPositionFromLight{X}, shadowSampler{X}, shadowsInfo{X}.z, shadowsInfo{X}.x);\r\n\t\t#else\r\n\t\t#ifdef SHADOWPCF{X}\r\n\t\t\t#if defined(Vector2LIGHT{X})\r\n\t\t\t\tshadow = computeShadowWithPCFCube(vLightData{X}.xyz, shadowSampler{X}, shadowsInfo{X}.y, shadowsInfo{X}.z, shadowsInfo{X}.x);\r\n\t\t\t#else\r\n\t\t\t\tshadow = computeShadowWithPCF(vPositionFromLight{X}, shadowSampler{X}, shadowsInfo{X}.y, shadowsInfo{X}.z, shadowsInfo{X}.x);\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\t#if defined(Vector2LIGHT{X})\r\n\t\t\t\tshadow = computeShadowCube(vLightData{X}.xyz, shadowSampler{X}, shadowsInfo{X}.x, shadowsInfo{X}.z);\r\n\t\t\t#else\r\n\t\t\t\tshadow = computeShadow(vPositionFromLight{X}, shadowSampler{X}, shadowsInfo{X}.x, shadowsInfo{X}.z);\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\t#else\r\n\t\tshadow = 1.;\r\n\t#endif\r\n    #if defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\r\n\t    diffuseBase += lightmapColor * shadow;\r\n\t    #ifdef SPECULARTERM\r\n            #ifndef LIGHTMAPNOSPECULAR{X}\r\n                specularBase += info.specular * shadow * lightmapColor;\r\n            #endif\r\n        #endif\r\n    #else\r\n\t    diffuseBase += info.diffuse * shadow;\r\n\t    #ifdef SPECULARTERM\r\n\t\t    specularBase += info.specular * shadow;\r\n\t    #endif\r\n\t#endif\r\n#endif",
lightFragmentDeclaration: "﻿#ifdef LIGHT{X}\r\n\tuniform vec4 vLightData{X};\r\n\tuniform vec4 vLightDiffuse{X};\r\n\t#ifdef SPECULARTERM\r\n\t\tuniform vec3 vLightSpecular{X};\r\n\t#endif\r\n\t#ifdef SHADOW{X}\r\n\t\t#if defined(SPOTLIGHT{X}) || defined(DIRLIGHT{X})\r\n\t\t\tvarying vec4 vPositionFromLight{X};\r\n\t\t\tuniform sampler2D shadowSampler{X};\r\n\t\t#else\r\n\t\t\tuniform samplerCube shadowSampler{X};\r\n\t\t#endif\r\n\t\tuniform vec3 shadowsInfo{X};\r\n\t#endif\r\n\t#ifdef SPOTLIGHT{X}\r\n\t\tuniform vec4 vLightDirection{X};\r\n\t#endif\r\n\t#ifdef HEMILIGHT{X}\r\n\t\tuniform vec3 vLightGround{X};\r\n\t#endif\r\n#endif",
lightsFragmentFunctions: "﻿// Light Computing\r\nstruct lightingInfo\r\n{\r\n\tvec3 diffuse;\r\n#ifdef SPECULARTERM\r\n\tvec3 specular;\r\n#endif\r\n};\r\n\r\nlightingInfo computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, float range, float glossiness) {\r\n\tlightingInfo result;\r\n\r\n\tvec3 lightVectorW;\r\n\tfloat attenuation = 1.0;\r\n\tif (lightData.w == 0.)\r\n\t{\r\n\t\tvec3 direction = lightData.xyz - vPositionW;\r\n\r\n\t\tattenuation = max(0., 1.0 - length(direction) / range);\r\n\t\tlightVectorW = normalize(direction);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tlightVectorW = normalize(-lightData.xyz);\r\n\t}\r\n\r\n\t// diffuse\r\n\tfloat ndl = max(0., dot(vNormal, lightVectorW));\r\n\tresult.diffuse = ndl * diffuseColor * attenuation;\r\n\r\n#ifdef SPECULARTERM\r\n\t// Specular\r\n\tvec3 angleW = normalize(viewDirectionW + lightVectorW);\r\n\tfloat specComp = max(0., dot(vNormal, angleW));\r\n\tspecComp = pow(specComp, max(1., glossiness));\r\n\r\n\tresult.specular = specComp * specularColor * attenuation;\r\n#endif\r\n\treturn result;\r\n}\r\n\r\nlightingInfo computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec3 diffuseColor, vec3 specularColor, float range, float glossiness) {\r\n\tlightingInfo result;\r\n\r\n\tvec3 direction = lightData.xyz - vPositionW;\r\n\tvec3 lightVectorW = normalize(direction);\r\n\tfloat attenuation = max(0., 1.0 - length(direction) / range);\r\n\r\n\t// diffuse\r\n\tfloat cosAngle = max(0., dot(-lightDirection.xyz, lightVectorW));\r\n\r\n\tif (cosAngle >= lightDirection.w)\r\n\t{\r\n\t\tcosAngle = max(0., pow(cosAngle, lightData.w));\r\n\t\tattenuation *= cosAngle;\r\n\r\n\t\t// Diffuse\r\n\t\tfloat ndl = max(0., dot(vNormal, -lightDirection.xyz));\r\n\t\tresult.diffuse = ndl * diffuseColor * attenuation;\r\n\r\n#ifdef SPECULARTERM\r\n\t\t// Specular\r\n\t\tvec3 angleW = normalize(viewDirectionW - lightDirection.xyz);\r\n\t\tfloat specComp = max(0., dot(vNormal, angleW));\r\n\t\tspecComp = pow(specComp, max(1., glossiness));\r\n\r\n\t\tresult.specular = specComp * specularColor * attenuation;\r\n#endif\r\n\t\treturn result;\r\n\t}\r\n\r\n\tresult.diffuse = vec3(0.);\r\n#ifdef SPECULARTERM\r\n\tresult.specular = vec3(0.);\r\n#endif\r\n\r\n\treturn result;\r\n}\r\n\r\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, vec3 groundColor, float glossiness) {\r\n\tlightingInfo result;\r\n\r\n\t// Diffuse\r\n\tfloat ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\r\n\tresult.diffuse = mix(groundColor, diffuseColor, ndl);\r\n\r\n#ifdef SPECULARTERM\r\n\t// Specular\r\n\tvec3 angleW = normalize(viewDirectionW + lightData.xyz);\r\n\tfloat specComp = max(0., dot(vNormal, angleW));\r\n\tspecComp = pow(specComp, max(1., glossiness));\r\n\r\n\tresult.specular = specComp * specularColor;\r\n#endif\r\n\r\n\treturn result;\r\n}\r\n",
logDepthDeclaration: "﻿#ifdef LOGARITHMICDEPTH\r\n\tuniform float logarithmicDepthConstant;\r\n\tvarying float vFragmentDepth;\r\n#endif",
logDepthFragment: "﻿#ifdef LOGARITHMICDEPTH\r\n\tgl_FragDepthEXT = log2(vFragmentDepth) * logarithmicDepthConstant * 0.5;\r\n#endif",
logDepthVertex: "﻿#ifdef LOGARITHMICDEPTH\r\n\tvFragmentDepth = 1.0 + gl_Position.w;\r\n\tgl_Position.z = log2(max(0.000001, vFragmentDepth)) * logarithmicDepthConstant;\r\n#endif",
pbrFunctions: "// Constants\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\r\n\r\n// PBR CUSTOM CONSTANTS\r\nconst float kPi = 3.1415926535897932384626433832795;\r\nconst float kRougnhessToAlphaScale = 0.1;\r\nconst float kRougnhessToAlphaOffset = 0.29248125;\r\n\r\nfloat Square(float value)\r\n{\r\n    return value * value;\r\n}\r\n\r\nfloat getLuminance(vec3 color)\r\n{\r\n    return clamp(dot(color, vec3(0.2126, 0.7152, 0.0722)), 0., 1.);\r\n}\r\n\r\nfloat convertRoughnessToAverageSlope(float roughness)\r\n{\r\n    // Calculate AlphaG as square of roughness; add epsilon to avoid numerical issues\r\n    const float kMinimumVariance = 0.0005;\r\n    float alphaG = Square(roughness) + kMinimumVariance;\r\n    return alphaG;\r\n}\r\n\r\n// Based on Beckamm roughness to Blinn exponent + http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html \r\nfloat getMipMapIndexFromAverageSlope(float maxMipLevel, float alpha)\r\n{\r\n    // do not take in account lower mips hence -1... and wait from proper preprocess.\r\n    // formula comes from approximation of the mathematical solution.\r\n    //float mip = maxMipLevel + kRougnhessToAlphaOffset + 0.5 * log2(alpha);\r\n    \r\n    // In the mean time \r\n    // Always [0..1] goes from max mip to min mip in a log2 way.  \r\n    // Change 5 to nummip below.\r\n    // http://www.wolframalpha.com/input/?i=x+in+0..1+plot+(+5+%2B+0.3+%2B+0.1+*+5+*+log2(+(1+-+x)+*+(1+-+x)+%2B+0.0005))\r\n    float mip = kRougnhessToAlphaOffset + maxMipLevel + (maxMipLevel * kRougnhessToAlphaScale * log2(alpha));\r\n    \r\n    return clamp(mip, 0., maxMipLevel);\r\n}\r\n\r\nfloat getMipMapIndexFromAverageSlopeWithPMREM(float maxMipLevel, float alphaG)\r\n{\r\n    float specularPower = clamp(2. / alphaG - 2., 0.000001, 2048.);\r\n    \r\n    // Based on CubeMapGen for cosine power with 2048 spec default and 0.25 dropoff \r\n    return clamp(- 0.5 * log2(specularPower) + 5.5, 0., maxMipLevel);\r\n}\r\n\r\n// From Microfacet Models for Refraction through Rough Surfaces, Walter et al. 2007\r\nfloat smithVisibilityG1_TrowbridgeReitzGGX(float dot, float alphaG)\r\n{\r\n    float tanSquared = (1.0 - dot * dot) / (dot * dot);\r\n    return 2.0 / (1.0 + sqrt(1.0 + alphaG * alphaG * tanSquared));\r\n}\r\n\r\nfloat smithVisibilityG_TrowbridgeReitzGGX_Walter(float NdotL, float NdotV, float alphaG)\r\n{\r\n    return smithVisibilityG1_TrowbridgeReitzGGX(NdotL, alphaG) * smithVisibilityG1_TrowbridgeReitzGGX(NdotV, alphaG);\r\n}\r\n\r\n// Trowbridge-Reitz (GGX)\r\n// Generalised Trowbridge-Reitz with gamma power=2.0\r\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH, float alphaG)\r\n{\r\n    // Note: alphaG is average slope (gradient) of the normals in slope-space.\r\n    // It is also the (trigonometric) tangent of the median distribution value, i.e. 50% of normals have\r\n    // a tangent (gradient) closer to the macrosurface than this slope.\r\n    float a2 = Square(alphaG);\r\n    float d = NdotH * NdotH * (a2 - 1.0) + 1.0;\r\n    return a2 / (kPi * d * d);\r\n}\r\n\r\nvec3 fresnelSchlickGGX(float VdotH, vec3 reflectance0, vec3 reflectance90)\r\n{\r\n    return reflectance0 + (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotH, 0., 1.), 5.0);\r\n}\r\n\r\nvec3 FresnelSchlickEnvironmentGGX(float VdotN, vec3 reflectance0, vec3 reflectance90, float smoothness)\r\n{\r\n    // Schlick fresnel approximation, extended with basic smoothness term so that rough surfaces do not approach reflectance90 at grazing angle\r\n    float weight = mix(FRESNEL_MAXIMUM_ON_ROUGH, 1.0, smoothness);\r\n    return reflectance0 + weight * (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotN, 0., 1.), 5.0);\r\n}\r\n\r\n// Cook Torance Specular computation.\r\nvec3 computeSpecularTerm(float NdotH, float NdotL, float NdotV, float VdotH, float roughness, vec3 specularColor, vec3 reflectance90)\r\n{\r\n    float alphaG = convertRoughnessToAverageSlope(roughness);\r\n    float distribution = normalDistributionFunction_TrowbridgeReitzGGX(NdotH, alphaG);\r\n    float visibility = smithVisibilityG_TrowbridgeReitzGGX_Walter(NdotL, NdotV, alphaG);\r\n    visibility /= (4.0 * NdotL * NdotV); // Cook Torance Denominator  integated in viibility to avoid issues when visibility function changes.\r\n\r\n    vec3 fresnel = fresnelSchlickGGX(VdotH, specularColor, reflectance90);\r\n\r\n    float specTerm = max(0., visibility * distribution) * NdotL;\r\n    return fresnel * specTerm * kPi; // TODO: audit pi constants\r\n}\r\n\r\nfloat computeDiffuseTerm(float NdotL, float NdotV, float VdotH, float roughness)\r\n{\r\n    // Diffuse fresnel falloff as per Disney principled BRDF, and in the spirit of\r\n    // of general coupled diffuse/specular models e.g. Ashikhmin Shirley.\r\n    float diffuseFresnelNV = pow(clamp(1.0 - NdotL, 0.000001, 1.), 5.0);\r\n    float diffuseFresnelNL = pow(clamp(1.0 - NdotV, 0.000001, 1.), 5.0);\r\n    float diffuseFresnel90 = 0.5 + 2.0 * VdotH * VdotH * roughness;\r\n    float diffuseFresnelTerm =\r\n        (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNL) *\r\n        (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNV);\r\n\r\n\r\n    return diffuseFresnelTerm * NdotL;\r\n    // PI Test\r\n    // diffuseFresnelTerm /= kPi;\r\n}\r\n\r\nfloat adjustRoughnessFromLightProperties(float roughness, float lightRadius, float lightDistance)\r\n{\r\n    #ifdef USEPHYSICALLIGHTFALLOFF\r\n        // At small angle this approximation works. \r\n        float lightRoughness = lightRadius / lightDistance;\r\n        // Distribution can sum.\r\n        float totalRoughness = clamp(lightRoughness + roughness, 0., 1.);\r\n        return totalRoughness;\r\n    #else\r\n        return roughness;\r\n    #endif\r\n}\r\n\r\nfloat computeDefaultMicroSurface(float microSurface, vec3 reflectivityColor)\r\n{\r\n    float kReflectivityNoAlphaWorkflow_SmoothnessMax = 0.95;\r\n\r\n    float reflectivityLuminance = getLuminance(reflectivityColor);\r\n    float reflectivityLuma = sqrt(reflectivityLuminance);\r\n    microSurface = reflectivityLuma * kReflectivityNoAlphaWorkflow_SmoothnessMax;\r\n\r\n    return microSurface;\r\n}\r\n\r\nvec3 toLinearSpace(vec3 color)\r\n{\r\n    return vec3(pow(color.r, 2.2), pow(color.g, 2.2), pow(color.b, 2.2));\r\n}\r\n\r\nvec3 toGammaSpace(vec3 color)\r\n{\r\n    return vec3(pow(color.r, 1.0 / 2.2), pow(color.g, 1.0 / 2.2), pow(color.b, 1.0 / 2.2));\r\n}\r\n\r\n#ifdef CAMERATONEMAP\r\n    vec3 toneMaps(vec3 color)\r\n    {\r\n        color = max(color, 0.0);\r\n\r\n        // TONE MAPPING / EXPOSURE\r\n        color.rgb = color.rgb * vCameraInfos.x;\r\n\r\n        float tuning = 1.5; // TODO: sync up so e.g. 18% greys are matched to exposure appropriately\r\n        // PI Test\r\n        // tuning *=  kPi;\r\n        vec3 tonemapped = 1.0 - exp2(-color.rgb * tuning); // simple local photographic tonemapper\r\n        color.rgb = mix(color.rgb, tonemapped, 1.0);\r\n        return color;\r\n    }\r\n#endif\r\n\r\n#ifdef CAMERACONTRAST\r\n    vec4 contrasts(vec4 color)\r\n    {\r\n        color = clamp(color, 0.0, 1.0);\r\n\r\n        vec3 resultHighContrast = color.rgb * color.rgb * (3.0 - 2.0 * color.rgb);\r\n        float contrast = vCameraInfos.y;\r\n        if (contrast < 1.0)\r\n        {\r\n            // Decrease contrast: interpolate towards zero-contrast image (flat grey)\r\n            color.rgb = mix(vec3(0.5, 0.5, 0.5), color.rgb, contrast);\r\n        }\r\n        else\r\n        {\r\n            // Increase contrast: apply simple shoulder-toe high contrast curve\r\n            color.rgb = mix(color.rgb, resultHighContrast, contrast - 1.0);\r\n        }\r\n\r\n        return color;\r\n    }\r\n#endif",
pbrLightFunctions: "// Light Computing\r\nstruct lightingInfo\r\n{\r\n    vec3 diffuse;\r\n    #ifdef SPECULARTERM\r\n        vec3 specular;\r\n    #endif\r\n};\r\n\r\nfloat computeDistanceLightFalloff(vec3 lightOffset, float lightDistanceSquared, float range)\r\n{   \r\n    #ifdef USEPHYSICALLIGHTFALLOFF\r\n        float lightDistanceFalloff = 1.0 / ((lightDistanceSquared + 0.0001));\r\n    #else\r\n        float lightDistanceFalloff = max(0., 1.0 - length(lightOffset) / range);\r\n    #endif\r\n    \r\n    return lightDistanceFalloff;\r\n}\r\n\r\nfloat computeDirectionalLightFalloff(vec3 lightDirection, vec3 directionToLightCenterW, float lightAngle, float exponent)\r\n{\r\n    float falloff = 0.0;\r\n    \r\n    #ifdef USEPHYSICALLIGHTFALLOFF\r\n        float cosHalfAngle = cos(lightAngle * 0.5);\r\n        const float kMinusLog2ConeAngleIntensityRatio = 6.64385618977; // -log2(0.01)\r\n\r\n        // Calculate a Spherical Gaussian (von Mises-Fisher distribution, not angle-based Gaussian) such that the peak is in the light direction,\r\n        // and the value at the nominal cone angle is 1% of the peak. Because we want the distribution to decay from unity (100%)\r\n        // at the peak direction (dot product = 1) down to 1% at the nominal cone cutoff (dot product = cosAngle) \r\n        // the falloff rate expressed in terms of the base-two dot product is therefore -log2(ConeAngleIntensityRatio) / (1.0 - cosAngle).\r\n        // Note that the distribution is unnormalised in that peak density is unity, rather than the total energy is unity.\r\n        float concentrationKappa = kMinusLog2ConeAngleIntensityRatio / (1.0 - cosHalfAngle);\r\n    \r\n        // Evaluate spherical gaussian for light directional falloff for spot light type (note: spot directional falloff; \r\n        // not directional light type)\r\n        vec4 lightDirectionSpreadSG = vec4(-lightDirection * concentrationKappa, -concentrationKappa);\r\n        falloff = exp2(dot(vec4(directionToLightCenterW, 1.0), lightDirectionSpreadSG));\r\n    #else\r\n        float cosAngle = max(0.000000000000001, dot(-lightDirection, directionToLightCenterW));\r\n        if (cosAngle >= lightAngle)\r\n        {\r\n            falloff = max(0., pow(cosAngle, exponent));\r\n        }\r\n    #endif\r\n    \r\n    return falloff;\r\n}\r\n\r\nlightingInfo computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, float rangeRadius, float roughness, float NdotV, vec3 reflectance90, out float NdotL) {\r\n    lightingInfo result;\r\n\r\n    vec3 lightDirection;\r\n    float attenuation = 1.0;\r\n    float lightDistance;\r\n    \r\n    // Vector2\r\n    if (lightData.w == 0.)\r\n    {\r\n        vec3 lightOffset = lightData.xyz - vPositionW;\r\n        float lightDistanceSquared = dot(lightOffset, lightOffset);\r\n        attenuation = computeDistanceLightFalloff(lightOffset, lightDistanceSquared, rangeRadius);\r\n        \r\n        lightDistance = sqrt(lightDistanceSquared);\r\n        lightDirection = normalize(lightOffset);\r\n    }\r\n    // Directional\r\n    else\r\n    {\r\n        lightDistance = length(-lightData.xyz);\r\n        lightDirection = normalize(-lightData.xyz);\r\n    }\r\n    \r\n    // Roughness\r\n    roughness = adjustRoughnessFromLightProperties(roughness, rangeRadius, lightDistance);\r\n    \r\n    // diffuse\r\n    vec3 H = normalize(viewDirectionW + lightDirection);\r\n    NdotL = max(0.00000000001, dot(vNormal, lightDirection));\r\n    float VdotH = clamp(0.00000000001, 1.0, dot(viewDirectionW, H));\r\n\r\n    float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\r\n    result.diffuse = diffuseTerm * diffuseColor * attenuation;\r\n\r\n    #ifdef SPECULARTERM\r\n        // Specular\r\n        float NdotH = max(0.00000000001, dot(vNormal, H));\r\n\r\n        vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor, reflectance90);\r\n        result.specular = specTerm * attenuation;\r\n    #endif\r\n\r\n    return result;\r\n}\r\n\r\nlightingInfo computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec3 diffuseColor, vec3 specularColor, float rangeRadius, float roughness, float NdotV, vec3 reflectance90, out float NdotL) {\r\n    lightingInfo result;\r\n\r\n    vec3 lightOffset = lightData.xyz - vPositionW;\r\n    vec3 directionToLightCenterW = normalize(lightOffset);\r\n\r\n    // Distance falloff.\r\n    float lightDistanceSquared = dot(lightOffset, lightOffset);\r\n    float attenuation = computeDistanceLightFalloff(lightOffset, lightDistanceSquared, rangeRadius);\r\n    \r\n    // Directional falloff.\r\n    float directionalAttenuation = computeDirectionalLightFalloff(lightDirection.xyz, directionToLightCenterW, lightDirection.w, lightData.w);\r\n    attenuation *= directionalAttenuation;\r\n    \r\n    // Roughness.\r\n    float lightDistance = sqrt(lightDistanceSquared);\r\n    roughness = adjustRoughnessFromLightProperties(roughness, rangeRadius, lightDistance);\r\n    \r\n    // Diffuse\r\n    vec3 H = normalize(viewDirectionW - lightDirection.xyz);\r\n    NdotL = max(0.00000000001, dot(vNormal, -lightDirection.xyz));\r\n    float VdotH = clamp(dot(viewDirectionW, H), 0.00000000001, 1.0);\r\n\r\n    float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\r\n    result.diffuse = diffuseTerm * diffuseColor * attenuation;\r\n\r\n    #ifdef SPECULARTERM\r\n        // Specular\r\n        float NdotH = max(0.00000000001, dot(vNormal, H));\r\n\r\n        vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor, reflectance90);\r\n        result.specular = specTerm  * attenuation;\r\n    #endif\r\n\r\n    return result;\r\n}\r\n\r\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, vec3 groundColor, float roughness, float NdotV, vec3 reflectance90, out float NdotL) {\r\n    lightingInfo result;\r\n\r\n    // Roughness\r\n    // Do not touch roughness on hemispheric.\r\n\r\n    // Diffuse\r\n    NdotL = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\r\n    result.diffuse = mix(groundColor, diffuseColor, NdotL);\r\n\r\n    #ifdef SPECULARTERM\r\n        // Specular\r\n        vec3 lightVectorW = normalize(lightData.xyz);\r\n        vec3 H = normalize(viewDirectionW + lightVectorW);\r\n        float NdotH = max(0.00000000001, dot(vNormal, H));\r\n        NdotL = max(0.00000000001, NdotL);\r\n        float VdotH = clamp(0.00000000001, 1.0, dot(viewDirectionW, H));\r\n\r\n        vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor, reflectance90);\r\n        result.specular = specTerm;\r\n    #endif\r\n\r\n    return result;\r\n}",
pbrLightFunctionsCall: "#ifdef LIGHT{X}\r\n    #if defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\r\n        //No light calculation\r\n    #else\r\n        #ifndef SPECULARTERM\r\n            vec3 vLightSpecular{X} = vec3(0.0);\r\n        #endif\r\n        #ifdef SPOTLIGHT{X}\r\n            info = computeSpotLighting(viewDirectionW, normalW, vLightData{X}, vLightDirection{X}, vLightDiffuse{X}.rgb, vLightSpecular{X}, vLightDiffuse{X}.a, roughness, NdotV, specularEnvironmentR90, NdotL);\r\n        #endif\r\n        #ifdef HEMILIGHT{X}\r\n            info = computeHemisphericLighting(viewDirectionW, normalW, vLightData{X}, vLightDiffuse{X}.rgb, vLightSpecular{X}, vLightGround{X}, roughness, NdotV, specularEnvironmentR90, NdotL);\r\n        #endif\r\n        #if defined(Vector2LIGHT{X}) || defined(DIRLIGHT{X})\r\n            info = computeLighting(viewDirectionW, normalW, vLightData{X}, vLightDiffuse{X}.rgb, vLightSpecular{X}, vLightDiffuse{X}.a, roughness, NdotV, specularEnvironmentR90, NdotL);\r\n        #endif\r\n    #endif\r\n    \r\n    #ifdef SHADOW{X}\r\n        #ifdef SHADOWVSM{X}\r\n            notShadowLevel = computeShadowWithVSM(vPositionFromLight{X}, shadowSampler{X}, shadowsInfo{X}.z, shadowsInfo{X}.x);\r\n        #else\r\n            #ifdef SHADOWPCF{X}\r\n                #if defined(Vector2LIGHT{X})\r\n                    notShadowLevel = computeShadowWithPCFCube(vLightData{X}.xyz, shadowSampler{X}, shadowsInfo{X}.y, shadowsInfo{X}.z, shadowsInfo{X}.x);\r\n                #else\r\n                    notShadowLevel = computeShadowWithPCF(vPositionFromLight{X}, shadowSampler{X}, shadowsInfo{X}.y, shadowsInfo{X}.z, shadowsInfo{X}.x);\r\n                #endif\r\n            #else\r\n                #if defined(Vector2LIGHT{X})\r\n                    notShadowLevel = computeShadowCube(vLightData{X}.xyz, shadowSampler{X}, shadowsInfo{X}.x, shadowsInfo{X}.z);\r\n                #else\r\n                    notShadowLevel = computeShadow(vPositionFromLight{X}, shadowSampler{X}, shadowsInfo{X}.x, shadowsInfo{X}.z);\r\n                #endif\r\n            #endif\r\n        #endif\r\n    #else\r\n        notShadowLevel = 1.;\r\n    #endif\r\n    \r\n    #if defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\r\n\t    lightDiffuseContribution += lightmapColor * notShadowLevel;\r\n\t    \r\n        #ifdef SPECULARTERM\r\n            #ifndef LIGHTMAPNOSPECULAR{X}\r\n                lightSpecularContribution += info.specular * notShadowLevel * lightmapColor;\r\n            #endif\r\n        #endif\r\n    #else\r\n        lightDiffuseContribution += info.diffuse * notShadowLevel;\r\n        \r\n        #ifdef OVERLOADEDSHADOWVALUES\r\n            if (NdotL < 0.000000000011)\r\n            {\r\n                notShadowLevel = 1.;\r\n            }\r\n            shadowedOnlyLightDiffuseContribution *= notShadowLevel;\r\n        #endif\r\n\r\n        #ifdef SPECULARTERM\r\n            lightSpecularContribution += info.specular * notShadowLevel;\r\n        #endif\r\n    #endif\r\n#endif",
pbrShadowFunctions: "// Shadows\r\n#ifdef SHADOWS\r\n\r\n\t#ifndef SHADOWFULLFLOAT\r\n        float unpack(vec4 color)\r\n        {\r\n            const vec4 bit_shift = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n            return dot(color, bit_shift);\r\n        }\r\n    #endif\r\n\r\n    uniform vec2 depthValues;\r\n\r\n    float computeShadowCube(vec3 lightPosition, samplerCube shadowSampler, float darkness, float bias)\r\n    {\r\n        vec3 directionToLight = vPositionW - lightPosition;\r\n        float depth = length(directionToLight);\r\n        depth = clamp(depth, 0., 1.0);\r\n\r\n        directionToLight = normalize(directionToLight);\r\n        directionToLight.y = - directionToLight.y;\r\n\r\n\t\t#ifndef SHADOWFULLFLOAT\r\n            float shadow = unpack(textureCube(shadowSampler, directionToLight)) + bias;\r\n        #else\r\n            float shadow = textureCube(shadowSampler, directionToLight).x + bias;\r\n        #endif\r\n\r\n        if (depth > shadow)\r\n        {\r\n            #ifdef OVERLOADEDSHADOWVALUES\r\n                return mix(1.0, darkness, vOverloadedShadowIntensity.x);\r\n            #else\r\n                return darkness;\r\n            #endif\r\n        }\r\n        return 1.0;\r\n    }\r\n\r\n    float computeShadowWithPCFCube(vec3 lightPosition, samplerCube shadowSampler, float mapSize, float bias, float darkness)\r\n    {\r\n        vec3 directionToLight = vPositionW - lightPosition;\r\n        float depth = length(directionToLight);\r\n\r\n        depth = (depth - depthValues.x) / (depthValues.y - depthValues.x);\r\n        depth = clamp(depth, 0., 1.0);\r\n\r\n        directionToLight = normalize(directionToLight);\r\n        directionToLight.y = -directionToLight.y;\r\n\r\n        float visibility = 1.;\r\n\r\n        vec3 poissonDisk[4];\r\n        poissonDisk[0] = vec3(-1.0, 1.0, -1.0);\r\n        poissonDisk[1] = vec3(1.0, -1.0, -1.0);\r\n        poissonDisk[2] = vec3(-1.0, -1.0, -1.0);\r\n        poissonDisk[3] = vec3(1.0, -1.0, 1.0);\r\n\r\n        // Poisson Sampling\r\n        float biasedDepth = depth - bias;\r\n\r\n\t\t#ifndef SHADOWFULLFLOAT\r\n            if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[0] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n            if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[1] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n            if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[2] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n            if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[3] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n        #else\r\n            if (textureCube(shadowSampler, directionToLight + poissonDisk[0] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n            if (textureCube(shadowSampler, directionToLight + poissonDisk[1] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n            if (textureCube(shadowSampler, directionToLight + poissonDisk[2] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n            if (textureCube(shadowSampler, directionToLight + poissonDisk[3] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n        #endif\r\n\r\n        #ifdef OVERLOADEDSHADOWVALUES\r\n            return  min(1.0, mix(1.0, visibility + darkness, vOverloadedShadowIntensity.x));\r\n        #else\r\n            return  min(1.0, visibility + darkness);\r\n        #endif\r\n    }\r\n\r\n\tfloat computeShadow(vec4 vPositionFromLight, sampler2D shadowSampler, float darkness, float bias)\r\n    {\r\n        vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\r\n        depth = 0.5 * depth + vec3(0.5);\r\n        vec2 uv = depth.xy;\r\n\r\n        if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\r\n        {\r\n            return 1.0;\r\n        }\r\n\r\n\t\t#ifndef SHADOWFULLFLOAT\r\n            float shadow = unpack(texture2D(shadowSampler, uv)) + bias;\r\n        #else\r\n            float shadow = texture2D(shadowSampler, uv).x + bias;\r\n        #endif\r\n\r\n        if (depth.z > shadow)\r\n        {\r\n            #ifdef OVERLOADEDSHADOWVALUES\r\n                return mix(1.0, darkness, vOverloadedShadowIntensity.x);\r\n            #else\r\n                return darkness;\r\n            #endif\r\n        }\r\n        return 1.;\r\n    }\r\n\r\n    float computeShadowWithPCF(vec4 vPositionFromLight, sampler2D shadowSampler, float mapSize, float bias, float darkness)\r\n    {\r\n        vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\r\n        depth = 0.5 * depth + vec3(0.5);\r\n        vec2 uv = depth.xy;\r\n\r\n        if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\r\n        {\r\n            return 1.0;\r\n        }\r\n\r\n        float visibility = 1.;\r\n\r\n        vec2 poissonDisk[4];\r\n        poissonDisk[0] = vec2(-0.94201624, -0.39906216);\r\n        poissonDisk[1] = vec2(0.94558609, -0.76890725);\r\n        poissonDisk[2] = vec2(-0.094184101, -0.92938870);\r\n        poissonDisk[3] = vec2(0.34495938, 0.29387760);\r\n\r\n        // Poisson Sampling\r\n        float biasedDepth = depth.z - bias;\r\n\r\n\t\t#ifndef SHADOWFULLFLOAT\r\n            if (unpack(texture2D(shadowSampler, uv + poissonDisk[0] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n            if (unpack(texture2D(shadowSampler, uv + poissonDisk[1] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n            if (unpack(texture2D(shadowSampler, uv + poissonDisk[2] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n            if (unpack(texture2D(shadowSampler, uv + poissonDisk[3] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n        #else\r\n            if (texture2D(shadowSampler, uv + poissonDisk[0] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n            if (texture2D(shadowSampler, uv + poissonDisk[1] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n            if (texture2D(shadowSampler, uv + poissonDisk[2] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n            if (texture2D(shadowSampler, uv + poissonDisk[3] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n        #endif\r\n\r\n        #ifdef OVERLOADEDSHADOWVALUES\r\n            return  min(1.0, mix(1.0, visibility + darkness, vOverloadedShadowIntensity.x));\r\n        #else\r\n            return  min(1.0, visibility + darkness);\r\n        #endif\r\n    }\r\n\r\n\t#ifndef SHADOWFULLFLOAT\r\n        // Thanks to http://devmaster.net/\r\n        float unpackHalf(vec2 color)\r\n        {\r\n            return color.x + (color.y / 255.0);\r\n        }\r\n    #endif\r\n\r\n    float linstep(float low, float high, float v) {\r\n        return clamp((v - low) / (high - low), 0.0, 1.0);\r\n    }\r\n\r\n    float ChebychevInequality(vec2 moments, float compare, float bias)\r\n    {\r\n        float p = smoothstep(compare - bias, compare, moments.x);\r\n        float variance = max(moments.y - moments.x * moments.x, 0.02);\r\n        float d = compare - moments.x;\r\n        float p_max = linstep(0.2, 1.0, variance / (variance + d * d));\r\n\r\n        return clamp(max(p, p_max), 0.0, 1.0);\r\n    }\r\n\r\n    float computeShadowWithVSM(vec4 vPositionFromLight, sampler2D shadowSampler, float bias, float darkness)\r\n    {\r\n        vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\r\n        depth = 0.5 * depth + vec3(0.5);\r\n        vec2 uv = depth.xy;\r\n\r\n        if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0 || depth.z >= 1.0)\r\n        {\r\n            return 1.0;\r\n        }\r\n\r\n        vec4 texel = texture2D(shadowSampler, uv);\r\n\r\n        #ifndef SHADOWFULLFLOAT\r\n            vec2 moments = vec2(unpackHalf(texel.xy), unpackHalf(texel.zw));\r\n        #else\r\n            vec2 moments = texel.xy;\r\n        #endif\r\n\r\n        #ifdef OVERLOADEDSHADOWVALUES\r\n            return min(1.0, mix(1.0, 1.0 - ChebychevInequality(moments, depth.z, bias) + darkness, vOverloadedShadowIntensity.x));\r\n        #else\r\n            return min(1.0, 1.0 - ChebychevInequality(moments, depth.z, bias) + darkness);\r\n        #endif\r\n    }\r\n\r\n#endif",
Vector2CloudVertex: "﻿#ifdef Vector2SIZE\r\n\tgl_PointSize = Vector2Size;\r\n#endif",
Vector2CloudVertexDeclaration: "﻿#ifdef Vector2SIZE\r\n\tuniform float Vector2Size;\r\n#endif",
reflectionFunction: "﻿vec3 computeReflectionCoords(vec4 worldPos, vec3 worldNormal)\r\n{\r\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\r\n\tvec3 direction = normalize(vDirectionW);\r\n\r\n\tfloat t = clamp(direction.y * -0.5 + 0.5, 0., 1.0);\r\n\tfloat s = atan(direction.z, direction.x) * RECIPROCAL_PI2 + 0.5;\r\n\r\n\treturn vec3(s, t, 0);\r\n#endif\r\n\r\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\r\n\r\n\tvec3 cameraToVertex = normalize(worldPos.xyz - vEyePosition);\r\n\tvec3 r = reflect(cameraToVertex, worldNormal);\r\n\tfloat t = clamp(r.y * -0.5 + 0.5, 0., 1.0);\r\n\tfloat s = atan(r.z, r.x) * RECIPROCAL_PI2 + 0.5;\r\n\r\n\treturn vec3(s, t, 0);\r\n#endif\r\n\r\n#ifdef REFLECTIONMAP_SPHERICAL\r\n\tvec3 viewDir = normalize(vec3(view * worldPos));\r\n\tvec3 viewNormal = normalize(vec3(view * vec4(worldNormal, 0.0)));\r\n\r\n\tvec3 r = reflect(viewDir, viewNormal);\r\n\tr.z = r.z - 1.0;\r\n\r\n\tfloat m = 2.0 * length(r);\r\n\r\n\treturn vec3(r.x / m + 0.5, 1.0 - r.y / m - 0.5, 0);\r\n#endif\r\n\r\n#ifdef REFLECTIONMAP_PLANAR\r\n\tvec3 viewDir = worldPos.xyz - vEyePosition;\r\n\tvec3 coords = normalize(reflect(viewDir, worldNormal));\r\n\r\n\treturn vec3(reflectionMatrix * vec4(coords, 1));\r\n#endif\r\n\r\n#ifdef REFLECTIONMAP_CUBIC\r\n\tvec3 viewDir = worldPos.xyz - vEyePosition;\r\n\tvec3 coords = reflect(viewDir, worldNormal);\r\n#ifdef INVERTCUBICMAP\r\n\tcoords.y = 1.0 - coords.y;\r\n#endif\r\n\treturn vec3(reflectionMatrix * vec4(coords, 0));\r\n#endif\r\n\r\n#ifdef REFLECTIONMAP_PROJECTION\r\n\treturn vec3(reflectionMatrix * (view * worldPos));\r\n#endif\r\n\r\n#ifdef REFLECTIONMAP_SKYBOX\r\n\treturn vPositionUVW;\r\n#endif\r\n\r\n#ifdef REFLECTIONMAP_EXPLICIT\r\n\treturn vec3(0, 0, 0);\r\n#endif\r\n}",
shadowsFragmentFunctions: "﻿#ifdef SHADOWS\r\n\t#ifndef SHADOWFULLFLOAT\r\n\t\tfloat unpack(vec4 color)\r\n\t\t{\r\n\t\t\tconst vec4 bit_shift = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n\t\t\treturn dot(color, bit_shift);\r\n\t\t}\r\n\t#endif\r\n\r\n\tuniform vec2 depthValues;\r\n\r\n\tfloat computeShadowCube(vec3 lightPosition, samplerCube shadowSampler, float darkness, float bias)\r\n\t{\r\n\t\tvec3 directionToLight = vPositionW - lightPosition;\r\n\t\tfloat depth = length(directionToLight);\r\n\t\tdepth = (depth - depthValues.x) / (depthValues.y - depthValues.x);\r\n\t\tdepth = clamp(depth, 0., 1.0);\r\n\r\n\t\tdirectionToLight = normalize(directionToLight);\r\n\t\tdirectionToLight.y = -directionToLight.y;\r\n\t\t\r\n\t\t#ifndef SHADOWFULLFLOAT\r\n\t\t\tfloat shadow = unpack(textureCube(shadowSampler, directionToLight)) + bias;\r\n\t\t#else\r\n\t\t\tfloat shadow = textureCube(shadowSampler, directionToLight).x + bias;\r\n\t\t#endif\r\n\r\n\t\tif (depth > shadow)\r\n\t\t{\r\n\t\t\treturn darkness;\r\n\t\t}\r\n\t\treturn 1.0;\r\n\t}\r\n\r\n\tfloat computeShadowWithPCFCube(vec3 lightPosition, samplerCube shadowSampler, float mapSize, float bias, float darkness)\r\n\t{\r\n\t\tvec3 directionToLight = vPositionW - lightPosition;\r\n\t\tfloat depth = length(directionToLight);\r\n\r\n\t\tdepth = (depth - depthValues.x) / (depthValues.y - depthValues.x);\r\n\t\tdepth = clamp(depth, 0., 1.0);\r\n\r\n\t\tdirectionToLight = normalize(directionToLight);\r\n\t\tdirectionToLight.y = -directionToLight.y;\r\n\r\n\t\tfloat visibility = 1.;\r\n\r\n\t\tvec3 poissonDisk[4];\r\n\t\tpoissonDisk[0] = vec3(-1.0, 1.0, -1.0);\r\n\t\tpoissonDisk[1] = vec3(1.0, -1.0, -1.0);\r\n\t\tpoissonDisk[2] = vec3(-1.0, -1.0, -1.0);\r\n\t\tpoissonDisk[3] = vec3(1.0, -1.0, 1.0);\r\n\r\n\t\t// Poisson Sampling\r\n\t\tfloat biasedDepth = depth - bias;\r\n\r\n\t\t#ifndef SHADOWFULLFLOAT\r\n\t\t\tif (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[0] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n\t\t\tif (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[1] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n\t\t\tif (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[2] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n\t\t\tif (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[3] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n\t\t#else\r\n\t\t\tif (textureCube(shadowSampler, directionToLight + poissonDisk[0] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n\t\t\tif (textureCube(shadowSampler, directionToLight + poissonDisk[1] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n\t\t\tif (textureCube(shadowSampler, directionToLight + poissonDisk[2] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n\t\t\tif (textureCube(shadowSampler, directionToLight + poissonDisk[3] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n\t\t#endif\r\n\r\n\t\treturn  min(1.0, visibility + darkness);\r\n\t}\r\n\r\n\tfloat computeShadow(vec4 vPositionFromLight, sampler2D shadowSampler, float darkness, float bias)\r\n\t{\r\n\t\tvec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\r\n\t\tdepth = 0.5 * depth + vec3(0.5);\r\n\t\tvec2 uv = depth.xy;\r\n\r\n\t\tif (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\r\n\t\t{\r\n\t\t\treturn 1.0;\r\n\t\t}\r\n\r\n\t\t#ifndef SHADOWFULLFLOAT\r\n\t\t\tfloat shadow = unpack(texture2D(shadowSampler, uv)) + bias;\r\n\t\t#else\r\n\t\t\tfloat shadow = texture2D(shadowSampler, uv).x + bias;\r\n\t\t#endif\r\n\r\n\t\tif (depth.z > shadow)\r\n\t\t{\r\n\t\t\treturn darkness;\r\n\t\t}\r\n\t\treturn 1.;\r\n\t}\r\n\r\n\tfloat computeShadowWithPCF(vec4 vPositionFromLight, sampler2D shadowSampler, float mapSize, float bias, float darkness)\r\n\t{\r\n\t\tvec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\r\n\t\tdepth = 0.5 * depth + vec3(0.5);\r\n\t\tvec2 uv = depth.xy;\r\n\r\n\t\tif (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\r\n\t\t{\r\n\t\t\treturn 1.0;\r\n\t\t}\r\n\r\n\t\tfloat visibility = 1.;\r\n\r\n\t\tvec2 poissonDisk[4];\r\n\t\tpoissonDisk[0] = vec2(-0.94201624, -0.39906216);\r\n\t\tpoissonDisk[1] = vec2(0.94558609, -0.76890725);\r\n\t\tpoissonDisk[2] = vec2(-0.094184101, -0.92938870);\r\n\t\tpoissonDisk[3] = vec2(0.34495938, 0.29387760);\r\n\r\n\t\t// Poisson Sampling\r\n\t\tfloat biasedDepth = depth.z - bias;\r\n\r\n\t\t#ifndef SHADOWFULLFLOAT\r\n\t\t\tif (unpack(texture2D(shadowSampler, uv + poissonDisk[0] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n\t\t\tif (unpack(texture2D(shadowSampler, uv + poissonDisk[1] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n\t\t\tif (unpack(texture2D(shadowSampler, uv + poissonDisk[2] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n\t\t\tif (unpack(texture2D(shadowSampler, uv + poissonDisk[3] * mapSize)) < biasedDepth) visibility -= 0.25;\r\n\t\t#else\r\n\t\t\tif (texture2D(shadowSampler, uv + poissonDisk[0] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n\t\t\tif (texture2D(shadowSampler, uv + poissonDisk[1] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n\t\t\tif (texture2D(shadowSampler, uv + poissonDisk[2] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n\t\t\tif (texture2D(shadowSampler, uv + poissonDisk[3] * mapSize).x < biasedDepth) visibility -= 0.25;\r\n\t\t#endif\r\n\r\n\t\treturn  min(1.0, visibility + darkness);\r\n\t}\r\n\r\n\t#ifndef SHADOWFULLFLOAT\r\n\t\t// Thanks to http://devmaster.net/\r\n\t\tfloat unpackHalf(vec2 color)\r\n\t\t{\r\n\t\t\treturn color.x + (color.y / 255.0);\r\n\t\t}\r\n\t#endif\r\n\r\n\tfloat linstep(float low, float high, float v) {\r\n\t\treturn clamp((v - low) / (high - low), 0.0, 1.0);\r\n\t}\r\n\r\n\tfloat ChebychevInequality(vec2 moments, float compare, float bias)\r\n\t{\r\n\t\tfloat p = smoothstep(compare - bias, compare, moments.x);\r\n\t\tfloat variance = max(moments.y - moments.x * moments.x, 0.02);\r\n\t\tfloat d = compare - moments.x;\r\n\t\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d * d));\r\n\r\n\t\treturn clamp(max(p, p_max), 0.0, 1.0);\r\n\t}\r\n\r\n\tfloat computeShadowWithVSM(vec4 vPositionFromLight, sampler2D shadowSampler, float bias, float darkness)\r\n\t{\r\n\t\tvec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\r\n\t\tdepth = 0.5 * depth + vec3(0.5);\r\n\t\tvec2 uv = depth.xy;\r\n\r\n\t\tif (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0 || depth.z >= 1.0)\r\n\t\t{\r\n\t\t\treturn 1.0;\r\n\t\t}\r\n\r\n\t\tvec4 texel = texture2D(shadowSampler, uv);\r\n\r\n\t\t#ifndef SHADOWFULLFLOAT\r\n\t\t\tvec2 moments = vec2(unpackHalf(texel.xy), unpackHalf(texel.zw));\r\n\t\t#else\r\n\t\t\tvec2 moments = texel.xy;\r\n\t\t#endif\r\n\r\n\t\treturn min(1.0, 1.0 - ChebychevInequality(moments, depth.z, bias) + darkness);\r\n\t}\r\n#endif",
shadowsVertex: "﻿#ifdef SHADOWS\r\n\t#if defined(SPOTLIGHT{X}) || defined(DIRLIGHT{X})\r\n\t\tvPositionFromLight{X} = lightMatrix{X} * worldPos;\r\n\t#endif\r\n#endif",
shadowsVertexDeclaration: "﻿#ifdef SHADOWS\r\n\t#if defined(SPOTLIGHT{X}) || defined(DIRLIGHT{X})\r\n\t\tuniform mat4 lightMatrix{X};\r\n\t\tvarying vec4 vPositionFromLight{X};\r\n\t#endif\r\n#endif\r\n",
};}}
